import { BaseLogger } from 'pino';
export { BaseLogger as Logger } from 'pino';
import { z } from 'zod';
import { File as File$1 } from 'buffer';

type ApiRequestOptions = {
    readonly method: "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH";
    readonly url: string;
    readonly path?: Record<string, any>;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    readonly errors?: Record<number, string>;
    readonly responseType?: // DO NOT REMOVE
    "arraybuffer" | "blob" | "document" | "json" | "text" | "stream";
};

interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;
    (cancelHandler: () => void): void;
}
declare class CancelablePromise<T> implements Promise<T> {
    #private;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: OnCancel) => void);
    get [Symbol.toStringTag](): string;
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | null): Promise<T>;
    cancel(): void;
    get isCancelled(): boolean;
}

/**
 * The minimum log level to print.
 */
type LogLevel = "silent" | "fatal" | "error" | "warn" | "info" | "debug" | "trace";

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;
type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    CREDENTIALS: "include" | "omit" | "same-origin";
    TOKEN?: string | Resolver<string> | undefined;
    USERNAME?: string | Resolver<string> | undefined;
    PASSWORD?: string | Resolver<string> | undefined;
    HEADERS?: Headers | Resolver<Headers> | undefined;
    ENCODE_PATH?: ((path: string) => string) | undefined;
    logger?: BaseLogger;
};

declare abstract class BaseHttpRequest {
    readonly config: OpenAPIConfig;
    constructor(config: OpenAPIConfig);
    abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;
}

/**
 * Generic response for any client action.
 * E.g. job submission, patch, delete
 */
type ActionResponse = {
    success?: boolean;
};

/**
 * Response containing an API key.
 *
 * This key is used in conjunction with the APIKey model
 * to authenticate users in the API.
 */
type APIKeyResponse = {
    /**
     * The API key. Will be `null` unless the key was created during the request. Keys are not stored in plaintext and can not be recovered after creation time.
     */
    api_key?: string;
    /**
     * The date that the API key was created.
     */
    date_created: string;
    /**
     * The date that the API key will automatically expire.
     */
    date_expires?: string;
    /**
     * The last time that the API key was used to authenticate with the API.
     */
    date_last_used?: string;
    /**
     * The database ID for the API key. Used when deleting keys.
     */
    id: string;
    /**
     * The human-readable name for the API key used for managing keys.
     */
    name: string;
    /**
     * The non-secret key prefix.
     */
    prefix: string;
    /**
     * The non-secret key suffix. Helpful for identifying keys if a name wasn't specified at creation time.
     */
    suffix: string;
};

/**
 * Client input to obtain an API key.
 */
type ObtainApikeyInput = {
    /**
     * Your account username.
     */
    username: string;
    /**
     * Your account password.
     */
    password: string;
    /**
     * A human readable name for your API key used to identify it when managing keys.
     */
    name?: string;
};

declare class AuthorizationService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Generate API Key
     * Generates a long-term API Key from your account's username and password.
     * @param requestBody
     * @returns APIKeyResponse OK
     * @throws ApiError
     */
    apikeyGenerate(requestBody: ObtainApikeyInput): CancelablePromise<APIKeyResponse>;
    /**
     * Generate long-term API Key (requires prior authentication)
     * Return a long-term API key for the user's team.
     * @param name An optional name or tag to assign to the generated API Key.
     * @returns APIKeyResponse Created
     * @throws ApiError
     */
    apikeyGenerateWithAuth(name?: string): CancelablePromise<APIKeyResponse>;
    /**
     * API Key List
     * Return a list of API Keys for the team.
     * @returns APIKeyResponse OK
     * @throws ApiError
     */
    apikeyList(): CancelablePromise<Array<APIKeyResponse>>;
    /**
     * Delete API Key
     * Mark the specified API Key as deleted.
     * @param apikeyId The UUID4 identifier associated with this API Key.
     * @returns ActionResponse OK
     * @throws ApiError
     */
    apikeyDelete(apikeyId: string): CancelablePromise<ActionResponse>;
}

/**
 * JobStatus choices
 */
type JobStatus = "Queued" | "In Progress" | "Ready" | "Failed";

/**
 * Response for getting Circom circuit info.
 */
type CircomCircuitInfoResponse = {
    /**
     * A unique identifier generated for the circuit. UUID4 format.
     */
    circuit_id: string;
    /**
     * The name of a circuit. This can be used in place of circuit_id for proving. This is specified during creation in the included sindri.json file.
     */
    circuit_name: string;
    /**
     * The development framework used to write the circuit. This is specified during creation in the included sindri.json file.
     */
    circuit_type: "circom";
    /**
     * The UTC datetime the circuit was uploaded in ISO8601 format.
     */
    date_created: string;
    /**
     * The number of proofs submitted for this circuit.
     */
    num_proofs: number;
    /**
     * The proving scheme for this circuit. This is specified during creation in the included sindri.json file.
     */
    proving_scheme: string;
    /**
     * Whether the circuit is public. Public circuits can be used by any user.
     */
    public: boolean;
    /**
     * The status of the circuit job.
     */
    status: JobStatus;
    /**
     * The user/team that owns this circuit.
     */
    team: string;
    /**
     * Total compute time in ISO8601 format.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds.
     */
    compute_time_sec?: number;
    /**
     * Detailed compute times for the circuit compilation.
     */
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    /**
     * Queue time in ISO8601 format.
     */
    queue_time?: number;
    /**
     * Queue time in seconds.
     */
    queue_time_sec?: number;
    /**
     * The name of the uploaded circuit file. Note: the CLI and SDKs create a generic name when a directory is specified for upload.
     */
    uploaded_file_name: string;
    /**
     * The verification key of this circuit.
     */
    verification_key?: Record<string, any>;
    /**
     * The error message for a failed circuit upload.
     */
    error?: string;
    /**
     * The elliptic curve over which the proving protocol takes place.
     */
    curve: string;
    /**
     * The number of constraints in the Rank-1 Constraint System (R1CS) of the circuit.
     */
    num_constraints?: number;
    /**
     * The number of public outputs from the circuit.
     */
    num_outputs?: number;
    /**
     * The number of private inputs for the circuit.
     */
    num_private_inputs?: number;
    /**
     * The number of public inputs for the circuit.
     */
    num_public_inputs?: number;
};

/**
 * Response for getting Gnark circuit info.
 */
type GnarkCircuitInfoResponse = {
    /**
     * A unique identifier generated for the circuit. UUID4 format.
     */
    circuit_id: string;
    /**
     * The name of a circuit. This can be used in place of circuit_id for proving. This is specified during creation in the included sindri.json file.
     */
    circuit_name: string;
    /**
     * The development framework used to write the circuit. This is specified during creation in the included sindri.json file.
     */
    circuit_type: "gnark";
    /**
     * The UTC datetime the circuit was uploaded in ISO8601 format.
     */
    date_created: string;
    /**
     * The number of proofs submitted for this circuit.
     */
    num_proofs: number;
    /**
     * The proving scheme for this circuit. This is specified during creation in the included sindri.json file.
     */
    proving_scheme: string;
    /**
     * Whether the circuit is public. Public circuits can be used by any user.
     */
    public: boolean;
    /**
     * The status of the circuit job.
     */
    status: JobStatus;
    /**
     * The user/team that owns this circuit.
     */
    team: string;
    /**
     * Total compute time in ISO8601 format.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds.
     */
    compute_time_sec?: number;
    /**
     * Detailed compute times for the circuit compilation.
     */
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    /**
     * Queue time in ISO8601 format.
     */
    queue_time?: number;
    /**
     * Queue time in seconds.
     */
    queue_time_sec?: number;
    /**
     * The name of the uploaded circuit file. Note: the CLI and SDKs create a generic name when a directory is specified for upload.
     */
    uploaded_file_name: string;
    /**
     * The verification key of this circuit.
     */
    verification_key?: Record<string, any>;
    /**
     * The error message for a failed circuit upload.
     */
    error?: string;
    /**
     * The elliptic curve over which the proving protocol takes place.
     */
    curve: string;
    /**
     * The Gnark frontend version tag.
     */
    gnark_version: string;
};

/**
 * Response for getting Halo2 circuit info.
 */
type Halo2CircuitInfoResponse = {
    /**
     * A unique identifier generated for the circuit. UUID4 format.
     */
    circuit_id: string;
    /**
     * The name of a circuit. This can be used in place of circuit_id for proving. This is specified during creation in the included sindri.json file.
     */
    circuit_name: string;
    /**
     * The development framework used to write the circuit. This is specified during creation in the included sindri.json file.
     */
    circuit_type: "halo2";
    /**
     * The UTC datetime the circuit was uploaded in ISO8601 format.
     */
    date_created: string;
    /**
     * The number of proofs submitted for this circuit.
     */
    num_proofs: number;
    /**
     * The proving scheme for this circuit. This is specified during creation in the included sindri.json file.
     */
    proving_scheme: string;
    /**
     * Whether the circuit is public. Public circuits can be used by any user.
     */
    public: boolean;
    /**
     * The status of the circuit job.
     */
    status: JobStatus;
    /**
     * The user/team that owns this circuit.
     */
    team: string;
    /**
     * Total compute time in ISO8601 format.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds.
     */
    compute_time_sec?: number;
    /**
     * Detailed compute times for the circuit compilation.
     */
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    /**
     * Queue time in ISO8601 format.
     */
    queue_time?: number;
    /**
     * Queue time in seconds.
     */
    queue_time_sec?: number;
    /**
     * The name of the uploaded circuit file. Note: the CLI and SDKs create a generic name when a directory is specified for upload.
     */
    uploaded_file_name: string;
    /**
     * The verification key of this circuit.
     */
    verification_key?: Record<string, any>;
    /**
     * The error message for a failed circuit upload.
     */
    error?: string;
    /**
     * The path to the circuit struct definition. This is specified during creation in the included sindri.json file.
     */
    class_name: string;
    /**
     * The elliptic curve over which the proving protocol takes place.
     */
    curve: string;
    /**
     * The log_2 of the number of rows in the circuit, expressed as a matrix.
     */
    degree: number;
    /**
     * The Halo2 frontend version tag.
     */
    halo2_version: string;
};

/**
 * Response for getting Noir circuit info.
 */
type NoirCircuitInfoResponse = {
    /**
     * A unique identifier generated for the circuit. UUID4 format.
     */
    circuit_id: string;
    /**
     * The name of a circuit. This can be used in place of circuit_id for proving. This is specified during creation in the included sindri.json file.
     */
    circuit_name: string;
    /**
     * The development framework used to write the circuit. This is specified during creation in the included sindri.json file.
     */
    circuit_type: "noir";
    /**
     * The UTC datetime the circuit was uploaded in ISO8601 format.
     */
    date_created: string;
    /**
     * The number of proofs submitted for this circuit.
     */
    num_proofs: number;
    /**
     * The proving scheme for this circuit. This is specified during creation in the included sindri.json file.
     */
    proving_scheme: string;
    /**
     * Whether the circuit is public. Public circuits can be used by any user.
     */
    public: boolean;
    /**
     * The status of the circuit job.
     */
    status: JobStatus;
    /**
     * The user/team that owns this circuit.
     */
    team: string;
    /**
     * Total compute time in ISO8601 format.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds.
     */
    compute_time_sec?: number;
    /**
     * Detailed compute times for the circuit compilation.
     */
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    /**
     * Queue time in ISO8601 format.
     */
    queue_time?: number;
    /**
     * Queue time in seconds.
     */
    queue_time_sec?: number;
    /**
     * The name of the uploaded circuit file. Note: the CLI and SDKs create a generic name when a directory is specified for upload.
     */
    uploaded_file_name: string;
    /**
     * The verification key of this circuit.
     */
    verification_key?: Record<string, any>;
    /**
     * The error message for a failed circuit upload.
     */
    error?: string;
    /**
     * The number of opcodes in the intermediate representation.
     */
    acir_opcodes?: number;
    /**
     * The number of constraints with an instantiated proving backend in the circuit.
     */
    circuit_size?: number;
    /**
     * The elliptic curve over which the proving protocol takes place.
     */
    curve: string;
    /**
     * The name of the circuit project specified in the included Nargo.toml file.
     */
    nargo_package_name: string;
    /**
     * The Noir frontend version tag.
     */
    noir_version: string;
};

/**
 * Response for getting circuit info.
 */
type CircuitInfoResponse$1 = CircomCircuitInfoResponse | Halo2CircuitInfoResponse | GnarkCircuitInfoResponse | NoirCircuitInfoResponse;

/**
 * CircuitType choices
 */
type CircuitType = "circom" | "gnark" | "halo2" | "noir";

/**
 * Response for getting proof info.
 */
type ProofInfoResponse = {
    /**
     * A unique identifier generated for the proof. UUID4 format.
     */
    proof_id: string;
    /**
     * The name of the circuit associated with this proof.
     */
    circuit_name: string;
    /**
     * The circuit_id of the circuit associated with this proof. UUID4 format.
     */
    circuit_id: string;
    /**
     * The development framework used to write the circuit. This is specified during creation in the included sindri.json file.
     */
    circuit_type: CircuitType;
    /**
     * The UTC datetime the circuit was uploaded in ISO8601 format.
     */
    date_created: string;
    /**
     * A boolean indicating whether an internal verification check occurred during the proof creation.
     */
    perform_verify: boolean;
    /**
     * The status of the proof job.
     */
    status: JobStatus;
    /**
     * The user/team that owns this proof.
     */
    team: string;
    /**
     * Total compute time in ISO8601 format.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds.
     */
    compute_time_sec?: number;
    /**
     * Detailed compute times for the proof generation.
     */
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    /**
     * The succinct argument(s) of knowledge.
     */
    proof?: Record<string, any>;
    /**
     * The public outputs of the circuit.
     */
    public?: any;
    /**
     * Queue time in ISO8601 format.
     */
    queue_time?: number;
    /**
     * Queue time in seconds.
     */
    queue_time_sec?: number;
    /**
     * The proof and public formatted as calldata for the smart contract verifier.
     */
    smart_contract_calldata?: string;
    /**
     * The verification key of this circuit.
     */
    verification_key?: Record<string, any>;
    /**
     * The error message for a failed proof.
     */
    error?: string;
};

declare class CircuitsService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Create Circuit
     * Create a circuit.
     * @param formData
     * @returns CircuitInfoResponse Created
     * @throws ApiError
     */
    circuitCreate(formData: FormData | {
        files: Array<Blob>;
        /**
         * Tags for a circuit.
         */
        tags?: Array<string>;
    }): CancelablePromise<CircuitInfoResponse$1>;
    /**
     * Circuit List
     * Return the list of all circuit infos.
     * @returns CircuitInfoResponse OK
     * @throws ApiError
     */
    circuitList(): CancelablePromise<Array<CircuitInfoResponse$1>>;
    /**
     * Circuit Detail
     * Get info for an existing circuit.
     * @param circuitId The circuit identifer of the circuit.
     * This can take one of the following forms:
     *
     * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.
     * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to
     * the most recent version of the circuit tagged as `latest`.
     * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit
     * tag. This corresponds to the most recent compilation of the circuit with the specified tag.
     * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will
     * default to the most recent version of the circuit tagged as `latest`.
     * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an
     * explicit tag. This corresponds to the most recent compilation of the team's circuit with the
     * specified tag.
     * @param includeVerificationKey Indicates whether to include the verification key in the response.
     * @returns CircuitInfoResponse OK
     * @throws ApiError
     */
    circuitDetail(circuitId: string, includeVerificationKey?: boolean): CancelablePromise<CircuitInfoResponse$1>;
    /**
     * Delete Circuit
     * Mark the specified circuit and any of its related proofs as deleted.
     * @param circuitId The circuit identifer of the circuit.
     * This can take one of the following forms:
     *
     * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.
     * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to
     * the most recent version of the circuit tagged as `latest`.
     * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit
     * tag. This corresponds to the most recent compilation of the circuit with the specified tag.
     * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will
     * default to the most recent version of the circuit tagged as `latest`.
     * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an
     * explicit tag. This corresponds to the most recent compilation of the team's circuit with the
     * specified tag.
     * @returns ActionResponse OK
     * @throws ApiError
     */
    circuitDelete(circuitId: string): CancelablePromise<ActionResponse>;
    /**
     * Circuit Proofs
     * Return a list of proof infos for the provided circuit_id.
     * @param circuitId The circuit identifer of the circuit.
     * This can take one of the following forms:
     *
     * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.
     * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to
     * the most recent version of the circuit tagged as `latest`.
     * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit
     * tag. This corresponds to the most recent compilation of the circuit with the specified tag.
     * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will
     * default to the most recent version of the circuit tagged as `latest`.
     * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an
     * explicit tag. This corresponds to the most recent compilation of the team's circuit with the
     * specified tag.
     * @returns ProofInfoResponse OK
     * @throws ApiError
     */
    circuitProofs(circuitId: string): CancelablePromise<Array<ProofInfoResponse>>;
    /**
     * Create Proof for Circuit
     * Prove a circuit with specific inputs.
     * @param circuitId The circuit identifer of the circuit.
     * This can take one of the following forms:
     *
     * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.
     * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to
     * the most recent version of the circuit tagged as `latest`.
     * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit
     * tag. This corresponds to the most recent compilation of the circuit with the specified tag.
     * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will
     * default to the most recent version of the circuit tagged as `latest`.
     * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an
     * explicit tag. This corresponds to the most recent compilation of the team's circuit with the
     * specified tag.
     * @param formData
     * @returns ProofInfoResponse Created
     * @throws ApiError
     */
    proofCreate(circuitId: string, formData: {
        /**
         * A string representing proof input which may be formatted as JSON for any framework. Noir circuits optionally accept TOML formatted proof input.
         */
        proof_input: string;
        /**
         * A boolean indicating whether to perform an internal verification check during the proof creation.
         */
        perform_verify?: boolean;
        /**
         * Internal prover implementation setting.
         */
        prover_implementation?: string;
    }): CancelablePromise<ProofInfoResponse>;
}

/**
 * Response providing the smart contract verifier code.
 */
type SmartContractVerifierResponse = {
    /**
     * The smart contract verifier code.
     */
    contract_code: string;
};

/**
 * Details about a team.
 */
type TeamDetail = {
    description: string;
    id: number;
    /**
     * Whether the team is a personal team.
     */
    is_personal: boolean;
    /**
     * The name of the team.
     */
    name: string;
    /**
     * Whether the team is a Sindri corporate team.
     */
    sindri_corporate: boolean;
    /**
     * The slug for the team (used for routing).
     */
    slug: string;
    /**
     * The URL for the team's website.
     */
    url: string;
};

/**
 * Details about the currently authenticated team.
 */
type TeamMeResponse = {
    team: TeamDetail;
};

/**
 * Details about the currently authenticated user.
 */
type UserMeResponse = {
    first_name: string;
    last_name: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * The email address of the user.
     */
    email: string;
    /**
     * The date that the user joined Sindri.
     */
    date_joined: string;
    /**
     * The teams that the user is a member of.
     */
    teams: Array<TeamDetail>;
};

type BinaryResponseType = typeof globalThis extends {
    ReadableStream: unknown;
} ? Blob : NodeJS.ReadableStream;
declare class InternalService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Circuit Download
     * Return the gzipped tarball for the specified circuit.
     * @param circuitId
     * @returns binary OK
     * @throws ApiError
     */
    circuitDownload(circuitId: string): CancelablePromise<BinaryResponseType>;
    /**
     * Circuit Smart Contract Verifier
     * Get smart contract verifier for existing circuit
     * @param circuitId The circuit identifer of the circuit.
     * This can take one of the following forms:
     *
     * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.
     * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to
     * the most recent version of the circuit tagged as `latest`.
     * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit
     * tag. This corresponds to the most recent compilation of the circuit with the specified tag.
     * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will
     * default to the most recent version of the circuit tagged as `latest`.
     * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an
     * explicit tag. This corresponds to the most recent compilation of the team's circuit with the
     * specified tag.
     * @returns SmartContractVerifierResponse OK
     * @throws ApiError
     */
    circuitSmartContractVerifier(circuitId: string): CancelablePromise<SmartContractVerifierResponse>;
    /**
     * Change user password (requires JWT authentication)
     * Change password for a user.
     *
     * This endpoint requires JWT authentication in order
     * to know which user is making the request. It expects to receive
     * an authenticated user in `request.auth`.
     *
     * We subsequently verify the old password and then update the user's password.
     * @param formData
     * @returns ActionResponse OK
     * @throws ApiError
     */
    passwordChangeWithJwtAuth(formData: {
        /**
         * Old password.
         */
        old_password: string;
        /**
         * New password.
         */
        new_password: string;
    }): CancelablePromise<ActionResponse>;
    /**
     * Proof List
     * Return the list of all proof infos.
     * @returns ProofInfoResponse OK
     * @throws ApiError
     */
    proofList(): CancelablePromise<Array<ProofInfoResponse>>;
    /**
     * Return the JSON schema for `sindri.json` manifest files
     * Return the JSON schema for `sindri.json` manifest files
     * @returns any OK
     * @throws ApiError
     */
    sindriManifestSchema(): CancelablePromise<Record<string, any>>;
    /**
     * Obtain team details for the currently authenticated team
     * Return details about the currently authenticated team.
     * @returns TeamMeResponse OK
     * @throws ApiError
     */
    teamMe(): CancelablePromise<TeamMeResponse>;
    /**
     * Obtain user details (requires JWT authentication)
     * Return details about the user and their teams.
     *
     * This endpoint requires JWT authentication in order
     * to know which user is making the request. It expects to receive
     * an authenticated user in `request.auth`.
     * @returns UserMeResponse OK
     * @throws ApiError
     */
    userMeWithJwtAuth(): CancelablePromise<UserMeResponse>;
}

declare class ProofsService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Proof Detail
     * Get info for an existing proof.
     * @param proofId The UUID4 identifier associated with this proof.
     * @param includeProof Indicates whether to include the proof in the response.
     * @param includePublic Indicates whether to include public inputs in the response.
     * @param includeSmartContractCalldata Indicates whether to include the proof and public formatted as smart contract calldata in the response.
     * @param includeVerificationKey Indicates whether to include the circuit's verification key in the response.
     * @returns ProofInfoResponse OK
     * @throws ApiError
     */
    proofDetail(proofId: string, includeProof?: boolean, includePublic?: boolean, includeSmartContractCalldata?: boolean, includeVerificationKey?: boolean): CancelablePromise<ProofInfoResponse>;
    /**
     * Delete Proof
     * Mark the specified proof as deleted.
     * @param proofId The UUID4 identifier associated with this proof.
     * @returns ActionResponse OK
     * @throws ApiError
     */
    proofDelete(proofId: string): CancelablePromise<ActionResponse>;
}

type Schema = {};

type TokenObtainPairInputSchema = {
    password: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     */
    username: string;
};

type TokenObtainPairOutputSchema = {
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     */
    username: string;
    refresh: string;
    access: string;
};

type TokenRefreshInputSchema = {
    refresh: string;
};

type TokenRefreshOutputSchema = {
    refresh: string;
    access?: string;
};

type TokenVerifyInputSchema = {
    token: string;
};

declare class TokenService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Obtain Token
     * @param requestBody
     * @returns TokenObtainPairOutputSchema OK
     * @throws ApiError
     */
    fd3Aaa7BControllerObtainToken(requestBody: TokenObtainPairInputSchema): CancelablePromise<TokenObtainPairOutputSchema>;
    /**
     * Refresh Token
     * @param requestBody
     * @returns TokenRefreshOutputSchema OK
     * @throws ApiError
     */
    b87E0720ControllerRefreshToken(requestBody: TokenRefreshInputSchema): CancelablePromise<TokenRefreshOutputSchema>;
    /**
     * Verify Token
     * @param requestBody
     * @returns Schema OK
     * @throws ApiError
     */
    d1C092ControllerVerifyToken(requestBody: TokenVerifyInputSchema): CancelablePromise<Schema>;
}

type HttpRequestConstructor = new (config: OpenAPIConfig) => BaseHttpRequest;
declare class ApiClient {
    readonly authorization: AuthorizationService;
    readonly circuits: CircuitsService;
    readonly internal: InternalService;
    readonly proofs: ProofsService;
    readonly token: TokenService;
    readonly request: BaseHttpRequest;
    constructor(config?: Partial<OpenAPIConfig>, HttpRequest?: HttpRequestConstructor);
}

declare const ConfigSchema: z.ZodObject<{
    auth: z.ZodDefault<z.ZodNullable<z.ZodObject<{
        apiKey: z.ZodString;
        apiKeyId: z.ZodString;
        apiKeyName: z.ZodString;
        baseUrl: z.ZodString;
        teamId: z.ZodNumber;
        teamSlug: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        apiKey: string;
        apiKeyId: string;
        apiKeyName: string;
        baseUrl: string;
        teamId: number;
        teamSlug: string;
    }, {
        apiKey: string;
        apiKeyId: string;
        apiKeyName: string;
        baseUrl: string;
        teamId: number;
        teamSlug: string;
    }>>>;
}, "strip", z.ZodTypeAny, {
    auth: {
        apiKey: string;
        apiKeyId: string;
        apiKeyName: string;
        baseUrl: string;
        teamId: number;
        teamSlug: string;
    } | null;
}, {
    auth?: {
        apiKey: string;
        apiKeyId: string;
        apiKeyName: string;
        baseUrl: string;
        teamId: number;
        teamSlug: string;
    } | null | undefined;
}>;
type ConfigSchema = z.infer<typeof ConfigSchema>;
declare class Config {
    protected _config: ConfigSchema;
    protected readonly logger: BaseLogger | undefined;
    constructor(logger?: BaseLogger);
    get auth(): ConfigSchema["auth"];
    get config(): ConfigSchema;
    reload(): void;
    update(configData: Partial<ConfigSchema>): void;
}

type BrowserFile = File;
declare const File: typeof File$1 | {
    new (fileBits: BlobPart[], fileName: string, options?: FilePropertyBag | undefined): File;
    prototype: File;
};

type CircuitInfoResponse = CircomCircuitInfoResponse | Halo2CircuitInfoResponse | GnarkCircuitInfoResponse | NoirCircuitInfoResponse;

/**
 * The options for authenticating with the API.
 */
interface AuthOptions {
    /**
     * The API key to use for authentication.
     */
    apiKey?: string;
    /**
     * The base URL for the API.
     */
    baseUrl?: string;
}
/**
 * Represents the primary client for interacting with the Sindri ZKP service API. This class serves
 * as the central entry point for the SDK, facilitating various operations such as compiling ZKP
 * circuits and generating proofs.
 *
 * The {@link SindriClient} class encapsulates all the necessary methods and properties required to
 * communicate effectively with the Sindri ZKP service, handling tasks like authentication, request
 * management, and response processing.
 *
 * Usage of this class typically involves instantiating it with appropriate authentication options
 * and then utilizing its methods to interact with the service.
 *
 * @example
 * // Create an instance of the `SindriClient` class.
 * const client = new SindriClient({ apiKey: 'your-api-key' });
 *
 * // Use the client to interact with the Sindri ZKP service...
 */
declare class SindriClient {
    /** @hidden */
    readonly _client: ApiClient;
    /** @hidden */
    readonly _clientConfig: OpenAPIConfig;
    /** @hidden */
    readonly _config: Config | undefined;
    readonly logger: BaseLogger;
    /**
     * Represents the polling interval in milliseconds used for querying the status of an endpoint.
     * This value determines the frequency at which the SDK polls an endpoint to check for any changes
     * in status.
     *
     * The choice of polling interval is critical for balancing responsiveness against resource
     * consumption.  A shorter interval leads to more frequent updates, beneficial for
     * rapidly-changing statuses, but at the expense of higher network and computational load. In
     * contrast, a longer interval reduces resource usage but may delay the detection of status
     * changes.
     *
     * For more complex ZKP circuits, which may take longer to compile, considering a larger polling
     * interval could be advantageous. This approach minimizes unnecessary network traffic and
     * computational effort while awaiting the completion of these time-intensive operations.
     *
     * The default value is set to 1000 milliseconds (1 second), offering a general balance. However,
     * it can and should be adjusted based on the expected complexity and compilation time of the
     * circuits being processed.
     */
    pollingInterval: number;
    /**
     * Constructs a new instance of the {@link SindriClient} class for interacting with the Sindri ZKP
     * service.  This constructor initializes the client with the necessary authentication options.
     *
     * The provided `authOptions` parameter allows for specifying authentication credentials and
     * configurations required for the client to communicate securely with the service.  See
     * {@link SindriClient.authorize} for more details about how authentication credentials are sourced.
     *
     * @param authOptions - The authentication options for the client, including
     * credentials like API keys or tokens. Defaults to an empty object if not provided.
     *
     * @example
     * // Instantiating the SindriClient with authentication options
     * const client = new SindriClient({ apiKey: 'sindri-...-fskd' });
     *
     * @see {@link SindriClient.authorize} for information on retrieving this value.
     */
    constructor(authOptions?: AuthOptions);
    /**
     * Retrieves the current value of the client's API key used for authenticating with the Sindri ZKP
     * service.  This property is crucial for ensuring secure communication with the API and is
     * typically set during client initialization.
     *
     * If the API key is not set or is in an invalid format (not a string), this getter returns
     * `null`.  Proper management of the API key is essential for the security and proper functioning
     * of the SDK.
     *
     * @returns The current API key if set and valid, otherwise `null`.
     *
     * @example
     * const currentApiKey = client.apiKey;
     * if (currentApiKey) {
     *   console.log('API Key is set.');
     * } else {
     *   console.log('API Key is not set or is invalid.');
     * }
     */
    get apiKey(): string | null;
    /**
     * Retrieves the current base URL of the Sindri ZKP service that the client is configured to
     * interact with.  This URL forms the foundation of all API requests made by the client and is
     * typically set during client initialization. Anyone other than employees at Sindri can typically
     * ignore this and use the default value of `https://sindri.app`.
     *
     * @returns The current base URL of the Sindri ZKP service.
     *
     * @example
     * console.log(`Current base URL: ${client.baseUrl}`);
     */
    get baseUrl(): string;
    /** Retrieves the current log level of the client. The log level determines the verbosity of logs
     * produced by the client which can be crucial for debugging and monitoring the client's
     * interactions with the Sindri ZKP service.
     *
     * @returns The current log level of the client.
     *
     * @example
     * console.log(`Current log level: ${client.logLevel}`);
     */
    get logLevel(): LogLevel;
    /**
     * Sets the client's log level. This level determines the verbosity of logs produced by the
     * client, allowing for flexible control over the amount of information logged during operation.
     *
     * @param level - The new log level to set for the client.
     *
     * @example
     * // Set log level to debug.
     * client.logLevel = "debug";
     */
    set logLevel(level: LogLevel);
    /**
     * Authorizes the client with the Sindri ZKP service using the provided authentication options.
     * This method is called automatically after initializing a client, but you may call it again if
     * you would like to change the credentials. The logic around how credentials is as follows:
     *
     * 1. Any explicitly specified options in `authOptions` are always used if provided.
     * 2. The `SINDRI_API_KEY` and `SINDRI_BASE_URL` environment variables are checked next.
     * 3. The settings in `sindri.conf.json` (produced by running `sindri login` on the command-line) will be checked after that.
     * 4. Finally, the default value of `https://sindri.app` will be used for the base URL (this is
     * typically what you want unless you're an employee at Sindri). The API key will remain unset and
     * you will only be able to make requests that allow anonymous access.
     *
     *
     * @param authOptions - The authentication details required to authorize the client.
     * @returns True if authorization is successful, false otherwise.
     *
     * @example
     * const authOptions = { apiKey: 'sindri-...-jskd' };
     * const isAuthorized = client.authorize(authOptions);
     * if (isAuthorized) {
     *   console.log('Client is fully authorized.');
     * } else {
     *   console.log('Client is not authorized.');
     * }
     */
    authorize(authOptions: AuthOptions): boolean;
    /**
     * Creates a new {@link SindriClient} client instance. The class itself is not exported, so use
     * this method on the exported (or any other) client instance to create a new instance. The new
     * instance can be configured and used completely independently from any other instances. For
     * example it can use different credentials or a different log level.
     *
     * @param authOptions - The authentication options for the client, including
     * credentials like API keys or tokens. Defaults to an empty object if not provided.
     *
     * @example
     * import sindri from 'sindri';
     *
     * // Equivalent to: const myClient = new SindriClient({ ... });
     * const myClient = sindri.create({ apiKey: 'sindri-mykey-1234'});
     *
     * @returns The new client instance.
     */
    create(authOptions: AuthOptions | undefined): SindriClient;
    /**
     * Asynchronously creates and deploys a new circuit, initiating its compilation process.  This
     * method is essential for submitting new versions of circuits to the Sindri ZKP service for
     * compilation. Upon deployment, it continuously polls the service to track the compilation status
     * until the process either completes successfully or fails.
     *
     * The method accepts two parameters: `project` and `tags`. The `project` parameter can be either
     * a string representing the path to the project or an array of files (browser or Node.js file
     * objects) constituting the circuit. The `tags` parameter is used to assign tags to the deployed
     * circuit, facilitating versioning and identification. By default, the circuit is tagged as
     * "latest".
     *
     * After successful deployment and compilation, the method returns a `CircuitInfoResponse` object,
     * which includes details about the compiled circuit, such as its identifier and status.
     *
     * @param project - In Node.js, this can either be a path to the root
     * directory of a Sindri project, the path to a gzipped tarball containing the project, or an
     * array of `buffer.File` objects. In a web browser, it can only be an array of `File` objects.
     * @param tags - The list of tags, or singular tag if a string is passed, that
     * should be associated with the deployed circuit. Defaults to `["latest"]`. Specify an empty
     * array to indicate that you don't care about the compilation outputs and just want to see if it
     * the circuit will compile.
     * @returns A promise which resolves to the details of the deployed circuit.
     *
     * @example
     * // Deploy a circuit with a project identifier and default `latest` tag.
     * const circuit = await client.createCircuit("/path/to/circuit-directory/");
     * console.log("Did circuit compilation succeed?", circuit.status);
     *
     * @example
     * // Deploy a circuit with files and custom tags.
     * await client.createCircuit([file1, file2], ['v1.0', 'experimental']);
     */
    createCircuit(project: string | Array<BrowserFile | File$1>, tags?: string | string[] | null): Promise<CircuitInfoResponse>;
    /**
     * Retrieves all proofs associated with a specified circuit.  This method is essential for
     * obtaining a comprehensive list of proofs generated for a given circuit, identified by its
     * unique circuit ID. It returns an array of `ProofInfoResponse` objects, each representing a
     * proof associated with the circuit.
     *
     * The method is particularly useful in scenarios where tracking or auditing all proofs of a
     * circuit is necessary. This could include verifying the integrity of proofs, understanding their
     * usage, or simply enumerating them for record-keeping.
     *
     * The `circuitId` parameter is a string that uniquely identifies the circuit in question. It's
     * crucial to provide the correct circuit ID to retrieve the corresponding proofs accurately.
     *
     * @param circuitId - The unique identifier of the circuit for which proofs are to be retrieved.
     * @returns A promise that resolves to an array of details for each associated proof.
     *
     * @example
     * const proofs = await client.getAllCircuitProofs(circuitId);
     * console.log("Proofs:', proofs);
     */
    getAllCircuitProofs(circuitId: string): Promise<ProofInfoResponse[]>;
    /**
     * Retrieves all circuits associated with the team.  This method fetches a list of all circuits
     * that have been created or accessed by the currently authenticated team. It's a key method for
     * managing and monitoring circuit usage within a team, offering insights into the variety and
     * scope of circuits in use.
     *
     * @returns A promise that resolves to an array of circuit information responses.
     *
     * @example
     * const circuits = await = client.getAllCircuits();
     * console.log("Circuits:", circuits);
     */
    getAllCircuits(): Promise<CircuitInfoResponse[]>;
    /**
     * Retrieves a specific circuit using its unique circuit ID.  This method is crucial for obtaining
     * detailed information about a particular circuit,  identified by the provided `circuitId`. It's
     * especially useful when detailed insights  or operations on a single circuit are required, rather
     * than handling multiple circuits.
     *
     * *Note:* In case the provided `circuitId` is invalid or does not correspond to an existing circuit,
     * the promise may reject, indicating an error. Proper error handling is therefore essential when using this method.
     *
     * @param circuitId - The unique identifier of the circuit to retrieve.
     * @returns A promise that resolves to the information about the specified circuit.
     *
     * @example
     * const circuit = await client.getCircuit(circuitId);
     * console.log('Circuit details:', circuit);
     */
    getCircuit(circuitId: string): Promise<CircuitInfoResponse>;
    /**
     * Retrieves detailed information about a specific proof, identified by its unique proof ID.  This
     * method is vital for obtaining individual proof details, facilitating in-depth analysis or
     * verification of a particular proof within the system.
     *
     * The `proofId` parameter is the key identifier for the proof, and it should be provided to fetch
     * the corresponding information. The method returns a promise that resolves to a
     * {@link ProofInfoResponse}, containing all relevant details of the proof.
     *
     * @param proofId - The unique identifier of the proof to retrieve.
     * @returns A promise that resolves to the data about the specified proof.
     *
     * @example
     * const proof = await client.getProof(proofId);
     * console.log("Proof details:", proof);
     */
    getProof(proofId: string): Promise<ProofInfoResponse>;
    /**
     * Generates a proof for a specified circuit.  This method is critical for creating a new proof
     * based on a given circuit, identified by `circuitId`, and the provided `proofInput`. It's
     * primarily used to validate or verify certain conditions or properties of the circuit without
     * revealing underlying data or specifics. The method continuously polls the service to track the
     * compilation status until the process either completes successfully or fails.
     *
     * The `circuitId` parameter specifies the unique identifier of the circuit for which the proof is
     * to be generated.  The `proofInput` is a string that represents the necessary input data or
     * parameters required for generating the proof.
     *
     * @param circuitId - The unique identifier of the circuit for which the proof is being generated.
     * @param proofInput - The input data required for generating the proof. This should be a string
     * containing either JSON data or TOML data (in the case of Noir).
     * @returns A promise that resolves to the information of the generated proof.
     *
     * @example
     * const proof = await client.proveCircuit(circuitId, '{"X": 23, "Y": 52}');
     * console.log("Generated proof:", proof);
     */
    proveCircuit(circuitId: string, proofInput: string, verify?: boolean, includeSmartContractCalldata?: boolean): Promise<ProofInfoResponse>;
}

declare const _default: SindriClient;

export { type AuthOptions, type CircomCircuitInfoResponse, type CircuitInfoResponse, type CircuitType, type GnarkCircuitInfoResponse, type Halo2CircuitInfoResponse, type JobStatus, type LogLevel, type NoirCircuitInfoResponse, type ProofInfoResponse, SindriClient, _default as default };
