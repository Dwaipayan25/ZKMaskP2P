{"version":3,"sources":["../../src/lib/client.ts","../../src/lib/api/core/BaseHttpRequest.ts","../../src/lib/api/core/request.ts","../../src/lib/isomorphic.ts","../../src/lib/api/core/ApiError.ts","../../src/lib/api/core/CancelablePromise.ts","../../src/lib/api/core/AxiosHttpRequest.ts","../../src/lib/api/services/AuthorizationService.ts","../../src/lib/api/services/CircuitsService.ts","../../src/lib/api/services/InternalService.ts","../../src/lib/api/services/ProofsService.ts","../../src/lib/api/services/TokenService.ts","../../src/lib/api/ApiClient.ts","../../src/lib/config.ts","../../src/lib/logging.ts","../../src/lib/index.ts"],"names":["readFile","stat","path","gzip","walk","tar","Tar","BaseHttpRequest","config","axios","NodeFile","NodeFormData","File","FormData","ApiError","request","response","message","CancelError","CancelablePromise","#isResolved","#isRejected","#isCancelled","#cancelHandlers","#promise","#resolve","#reject","executor","resolve","reject","onResolve","value","onReject","reason","onCancel","cancelHandler","onFulfilled","onRejected","onFinally","error","isDefined","isString","isStringWithValue","isBlob","isFormData","isSuccess","status","base64","str","getQueryString","params","qs","append","key","process","v","k","getUrl","options","encoder","substring","group","url","getFormData","formData","_","resolver","getHeaders","token","username","password","additionalHeaders","formHeaders","headers","credentials","getRequestBody","sendRequest","body","axiosClient","source","requestConfig","axiosError","getResponseHeader","responseHeader","content","getResponseBody","catchErrorCodes","result","errorStatus","errorStatusText","errorBody","startTime","getElapsedTime","ellapsedMilliseconds","ellapsedSeconds","ellapsedMinutes","logPrefix","responseBody","responseMessage","errorMessage","AxiosHttpRequest","AuthorizationService","httpRequest","requestBody","name","apikeyId","CircuitsService","circuitId","includeVerificationKey","InternalService","ProofsService","proofId","includeProof","includePublic","includeSmartContractCalldata","TokenService","ApiClient","HttpRequest","fs","envPaths","z","getConfigPath","paths","ConfigSchema","defaultConfig","loadConfig","logger","configPath","configFileContents","loadedConfig","Config","configData","newConfig","directory","pino","pretty","createLogger","level","SindriClient","_SindriClient","authOptions","versionTag","project","tags","tag","projectStats","tarballFilename","tarballContent","sindriJsonPath","sindriJsonContent","sindriJson","circuitName","files","file","sindriJsonFilename","a","b","tarStream","code","sindriJsonFile","tarball","gzippedTarball","tarFile","oldHeaders","createResponse","proofInput","verify","lib_default"],"mappings":"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","sourcesContent":["import { readFile, stat } from \"fs/promises\";\nimport path from \"path\";\nimport type { Readable } from \"stream\";\n\nimport gzip from \"gzip-js\";\nimport walk from \"ignore-walk\";\nimport tar from \"tar\";\nimport Tar from \"tar-js\";\n\nimport { ApiClient, CircuitType, JobStatus, OpenAPIConfig } from \"lib/api\";\nimport type {\n  CircomCircuitInfoResponse,\n  Halo2CircuitInfoResponse,\n  GnarkCircuitInfoResponse,\n  NoirCircuitInfoResponse,\n  ProofInfoResponse,\n} from \"lib/api\";\nimport { Config } from \"lib/config\";\nimport { createLogger, type Logger, type LogLevel } from \"lib/logging\";\nimport { File, FormData } from \"lib/isomorphic\";\nimport type {\n  BrowserFile,\n  BrowserFormData,\n  NodeFile,\n  NodeFormData,\n} from \"lib/isomorphic\";\n\n// Re-export types from the API.\nexport type {\n  CircomCircuitInfoResponse,\n  CircuitType,\n  GnarkCircuitInfoResponse,\n  Halo2CircuitInfoResponse,\n  JobStatus,\n  NoirCircuitInfoResponse,\n  ProofInfoResponse,\n};\nexport type CircuitInfoResponse =\n  | CircomCircuitInfoResponse\n  | Halo2CircuitInfoResponse\n  | GnarkCircuitInfoResponse\n  | NoirCircuitInfoResponse;\n\n// Re-export other internal types.\nexport type { Logger, LogLevel };\n\n/**\n * The options for authenticating with the API.\n */\nexport interface AuthOptions {\n  /**\n   * The API key to use for authentication.\n   */\n  apiKey?: string;\n  /**\n   * The base URL for the API.\n   */\n  baseUrl?: string;\n}\n\n/**\n * Represents the primary client for interacting with the Sindri ZKP service API. This class serves\n * as the central entry point for the SDK, facilitating various operations such as compiling ZKP\n * circuits and generating proofs.\n *\n * The {@link SindriClient} class encapsulates all the necessary methods and properties required to\n * communicate effectively with the Sindri ZKP service, handling tasks like authentication, request\n * management, and response processing.\n *\n * Usage of this class typically involves instantiating it with appropriate authentication options\n * and then utilizing its methods to interact with the service.\n *\n * @example\n * // Create an instance of the `SindriClient` class.\n * const client = new SindriClient({ apiKey: 'your-api-key' });\n *\n * // Use the client to interact with the Sindri ZKP service...\n */\nexport class SindriClient {\n  /** @hidden */\n  readonly _client: ApiClient;\n  /** @hidden */\n  readonly _clientConfig: OpenAPIConfig;\n  /** @hidden */\n  readonly _config: Config | undefined;\n\n  readonly logger: Logger;\n\n  /**\n   * Represents the polling interval in milliseconds used for querying the status of an endpoint.\n   * This value determines the frequency at which the SDK polls an endpoint to check for any changes\n   * in status.\n   *\n   * The choice of polling interval is critical for balancing responsiveness against resource\n   * consumption.  A shorter interval leads to more frequent updates, beneficial for\n   * rapidly-changing statuses, but at the expense of higher network and computational load. In\n   * contrast, a longer interval reduces resource usage but may delay the detection of status\n   * changes.\n   *\n   * For more complex ZKP circuits, which may take longer to compile, considering a larger polling\n   * interval could be advantageous. This approach minimizes unnecessary network traffic and\n   * computational effort while awaiting the completion of these time-intensive operations.\n   *\n   * The default value is set to 1000 milliseconds (1 second), offering a general balance. However,\n   * it can and should be adjusted based on the expected complexity and compilation time of the\n   * circuits being processed.\n   */\n  public pollingInterval: number = 1000;\n\n  /**\n   * Constructs a new instance of the {@link SindriClient} class for interacting with the Sindri ZKP\n   * service.  This constructor initializes the client with the necessary authentication options.\n   *\n   * The provided `authOptions` parameter allows for specifying authentication credentials and\n   * configurations required for the client to communicate securely with the service.  See\n   * {@link SindriClient.authorize} for more details about how authentication credentials are sourced.\n   *\n   * @param authOptions - The authentication options for the client, including\n   * credentials like API keys or tokens. Defaults to an empty object if not provided.\n   *\n   * @example\n   * // Instantiating the SindriClient with authentication options\n   * const client = new SindriClient({ apiKey: 'sindri-...-fskd' });\n   *\n   * @see {@link SindriClient.authorize} for information on retrieving this value.\n   */\n  constructor(authOptions: AuthOptions = {}) {\n    // Initialize the client and store a reference to its config.\n    this._client = new ApiClient();\n    this._clientConfig = this._client.request.config;\n\n    // Set the `Sindri-Client` header.\n    const versionTag = process.env.VERSION\n      ? `v${process.env.VERSION}`\n      : \"unknown\";\n    this._clientConfig.HEADERS = {\n      ...this._clientConfig.HEADERS,\n      \"Sindri-Client\": `sindri-js-sdk/${versionTag}`,\n    };\n\n    // Create a local logger instance.\n    this.logger = createLogger();\n    if (!process.env.BROWSER_BUILD) {\n      this._config = new Config(this.logger);\n    }\n    this._clientConfig.logger = this.logger;\n\n    // Authorize the client.\n    this.authorize(authOptions);\n  }\n\n  /**\n   * Retrieves the current value of the client's API key used for authenticating with the Sindri ZKP\n   * service.  This property is crucial for ensuring secure communication with the API and is\n   * typically set during client initialization.\n   *\n   * If the API key is not set or is in an invalid format (not a string), this getter returns\n   * `null`.  Proper management of the API key is essential for the security and proper functioning\n   * of the SDK.\n   *\n   * @returns The current API key if set and valid, otherwise `null`.\n   *\n   * @example\n   * const currentApiKey = client.apiKey;\n   * if (currentApiKey) {\n   *   console.log('API Key is set.');\n   * } else {\n   *   console.log('API Key is not set or is invalid.');\n   * }\n   */\n  get apiKey(): string | null {\n    if (\n      this._clientConfig.TOKEN &&\n      typeof this._clientConfig.TOKEN !== \"string\"\n    ) {\n      return null;\n    }\n    return this._clientConfig.TOKEN || null;\n  }\n\n  /**\n   * Retrieves the current base URL of the Sindri ZKP service that the client is configured to\n   * interact with.  This URL forms the foundation of all API requests made by the client and is\n   * typically set during client initialization. Anyone other than employees at Sindri can typically\n   * ignore this and use the default value of `https://sindri.app`.\n   *\n   * @returns The current base URL of the Sindri ZKP service.\n   *\n   * @example\n   * console.log(`Current base URL: ${client.baseUrl}`);\n   */\n  get baseUrl(): string {\n    return this._clientConfig.BASE;\n  }\n\n  /** Retrieves the current log level of the client. The log level determines the verbosity of logs\n   * produced by the client which can be crucial for debugging and monitoring the client's\n   * interactions with the Sindri ZKP service.\n   *\n   * @returns The current log level of the client.\n   *\n   * @example\n   * console.log(`Current log level: ${client.logLevel}`);\n   */\n  get logLevel(): LogLevel {\n    // We don't specify any custom log levels, so we can narrow the type to exclude strings.\n    return this.logger.level as LogLevel;\n  }\n\n  /**\n   * Sets the client's log level. This level determines the verbosity of logs produced by the\n   * client, allowing for flexible control over the amount of information logged during operation.\n   *\n   * @param level - The new log level to set for the client.\n   *\n   * @example\n   * // Set log level to debug.\n   * client.logLevel = \"debug\";\n   */\n  set logLevel(level: LogLevel) {\n    this.logger.level = level;\n    this.logger.debug(`Set log level to \"${this.logger.level}\".`);\n  }\n\n  /**\n   * Authorizes the client with the Sindri ZKP service using the provided authentication options.\n   * This method is called automatically after initializing a client, but you may call it again if\n   * you would like to change the credentials. The logic around how credentials is as follows:\n   *\n   * 1. Any explicitly specified options in `authOptions` are always used if provided.\n   * 2. The `SINDRI_API_KEY` and `SINDRI_BASE_URL` environment variables are checked next.\n   * 3. The settings in `sindri.conf.json` (produced by running `sindri login` on the command-line) will be checked after that.\n   * 4. Finally, the default value of `https://sindri.app` will be used for the base URL (this is\n   * typically what you want unless you're an employee at Sindri). The API key will remain unset and\n   * you will only be able to make requests that allow anonymous access.\n   *\n   *\n   * @param authOptions - The authentication details required to authorize the client.\n   * @returns True if authorization is successful, false otherwise.\n   *\n   * @example\n   * const authOptions = { apiKey: 'sindri-...-jskd' };\n   * const isAuthorized = client.authorize(authOptions);\n   * if (isAuthorized) {\n   *   console.log('Client is fully authorized.');\n   * } else {\n   *   console.log('Client is not authorized.');\n   * }\n   */\n  authorize(authOptions: AuthOptions): boolean {\n    if (process.env.BROWSER_BUILD) {\n      this._clientConfig.BASE = authOptions.baseUrl || \"https://sindri.app\";\n      this._clientConfig.TOKEN = authOptions.apiKey;\n    } else {\n      this._config!.reload();\n      this._clientConfig.BASE =\n        authOptions.baseUrl ||\n        process.env.SINDRI_BASE_URL ||\n        this._config!.auth?.baseUrl ||\n        this._clientConfig.BASE ||\n        \"https://sindri.app\";\n      this._clientConfig.TOKEN =\n        authOptions.apiKey ||\n        process.env.SINDRI_API_KEY ||\n        this._config!.auth?.apiKey;\n    }\n    return !!(this._clientConfig.BASE && this._clientConfig.TOKEN);\n  }\n\n  /**\n   * Creates a new {@link SindriClient} client instance. The class itself is not exported, so use\n   * this method on the exported (or any other) client instance to create a new instance. The new\n   * instance can be configured and used completely independently from any other instances. For\n   * example it can use different credentials or a different log level.\n   *\n   * @param authOptions - The authentication options for the client, including\n   * credentials like API keys or tokens. Defaults to an empty object if not provided.\n   *\n   * @example\n   * import sindri from 'sindri';\n   *\n   * // Equivalent to: const myClient = new SindriClient({ ... });\n   * const myClient = sindri.create({ apiKey: 'sindri-mykey-1234'});\n   *\n   * @returns The new client instance.\n   */\n  create(authOptions: AuthOptions | undefined): SindriClient {\n    return new SindriClient(authOptions);\n  }\n\n  /**\n   * Asynchronously creates and deploys a new circuit, initiating its compilation process.  This\n   * method is essential for submitting new versions of circuits to the Sindri ZKP service for\n   * compilation. Upon deployment, it continuously polls the service to track the compilation status\n   * until the process either completes successfully or fails.\n   *\n   * The method accepts two parameters: `project` and `tags`. The `project` parameter can be either\n   * a string representing the path to the project or an array of files (browser or Node.js file\n   * objects) constituting the circuit. The `tags` parameter is used to assign tags to the deployed\n   * circuit, facilitating versioning and identification. By default, the circuit is tagged as\n   * \"latest\".\n   *\n   * After successful deployment and compilation, the method returns a `CircuitInfoResponse` object,\n   * which includes details about the compiled circuit, such as its identifier and status.\n   *\n   * @param project - In Node.js, this can either be a path to the root\n   * directory of a Sindri project, the path to a gzipped tarball containing the project, or an\n   * array of `buffer.File` objects. In a web browser, it can only be an array of `File` objects.\n   * @param tags - The list of tags, or singular tag if a string is passed, that\n   * should be associated with the deployed circuit. Defaults to `[\"latest\"]`. Specify an empty\n   * array to indicate that you don't care about the compilation outputs and just want to see if it\n   * the circuit will compile.\n   * @returns A promise which resolves to the details of the deployed circuit.\n   *\n   * @example\n   * // Deploy a circuit with a project identifier and default `latest` tag.\n   * const circuit = await client.createCircuit(\"/path/to/circuit-directory/\");\n   * console.log(\"Did circuit compilation succeed?\", circuit.status);\n   *\n   * @example\n   * // Deploy a circuit with files and custom tags.\n   * await client.createCircuit([file1, file2], ['v1.0', 'experimental']);\n   */\n  async createCircuit(\n    project: string | Array<BrowserFile | NodeFile>,\n    tags: string | string[] | null = [\"latest\"],\n  ): Promise<CircuitInfoResponse> {\n    const formData = new FormData();\n\n    // First, validate the tags and them to the form data.\n    tags = typeof tags === \"string\" ? [tags] : tags ?? [];\n    for (const tag of tags) {\n      if (!/^[-a-zA-Z0-9_.]+$/.test(tag)) {\n        throw new Error(\n          `\"${tag}\" is not a valid tag. Tags may only contain alphanumeric characters, ` +\n            \"underscores, hyphens, and periods.\",\n        );\n      }\n      formData.append(\"tags\", tag);\n    }\n    if (tags.length === 0) {\n      formData.append(\"tags\", \"\");\n    }\n\n    // Handle `project` being a file or directory path.\n    if (typeof project === \"string\") {\n      if (process.env.BROWSER_BUILD) {\n        throw new Error(\n          \"Specifying `project` as a path is not allowed in the browser build.\",\n        );\n      }\n\n      let projectStats;\n      try {\n        projectStats = await stat(project);\n      } catch {\n        throw new Error(\n          `The \"${project}\" path does not exist or you do not have permission to access it.`,\n        );\n      }\n\n      // If `project` is a path, then it's a prepackaged tarball.\n      if (projectStats.isFile()) {\n        if (!/\\.(zip|tar|tar\\.gz|tgz)$/i.test(project)) {\n          throw new Error(\"Only gzipped tarballs or zip files are supported.\");\n        }\n        const tarballFilename = path.basename(project);\n        const tarballContent = await readFile(project);\n        (formData as NodeFormData).append(\n          \"files\",\n          new File([tarballContent], tarballFilename),\n        );\n\n        // If `project` is a directory, then we need to bundle it.\n      } else if (projectStats.isDirectory()) {\n        const sindriJsonPath = path.join(project, \"sindri.json\");\n        let sindriJsonContent;\n        try {\n          sindriJsonContent = await readFile(sindriJsonPath, {\n            encoding: \"utf-8\",\n          });\n        } catch {\n          throw new Error(\n            `Expected Sindri manifest file at \"${sindriJsonPath}\" does not exist.`,\n          );\n        }\n        let sindriJson;\n        try {\n          sindriJson = JSON.parse(sindriJsonContent) as { name: string };\n        } catch {\n          throw new Error(\n            `Could not parse \"${sindriJsonPath}\", is it valid JSON?`,\n          );\n        }\n        const circuitName = sindriJson?.name;\n        if (!circuitName) {\n          throw new Error(\n            `No circuit \"name\" field was found in \"${sindriJsonPath}\", the manifest is invalid.`,\n          );\n        }\n\n        // Create a tarball with all the files that should be included from the project.\n        const files = walk\n          .sync({\n            follow: true,\n            ignoreFiles: [\".sindriignore\"],\n            path: project,\n          })\n          .filter(\n            (file) =>\n              // Always exclude `.git` subdirectories.\n              !/(^|\\/)\\.git(\\/|$)/.test(file),\n          );\n        // Always include the `sindri.json` file.\n        const sindriJsonFilename = path.basename(sindriJsonPath);\n        if (!files.includes(sindriJsonFilename)) {\n          files.push(sindriJsonFilename);\n        }\n        const tarballFilename = `${circuitName}.tar.gz`;\n        files.sort((a, b) => a.localeCompare(b)); // Deterministic for tests.\n        const tarStream = tar.c(\n          {\n            cwd: project,\n            gzip: true,\n            onwarn: (code: string, message: string) => {\n              this.logger.warn(`While creating tarball: ${code} - ${message}`);\n            },\n            prefix: `${circuitName}/`,\n            sync: true,\n          },\n          files,\n          // This works around a bug in the typing of `tar` when using `sync`.\n        ) as unknown as Readable;\n\n        // Add the tarball to the form data.\n        (formData as NodeFormData).append(\n          \"files\",\n          new File([tarStream.read()], tarballFilename),\n        );\n      } else {\n        throw new Error(`The \"${project}\" path is not a file or directory.`);\n      }\n\n      // Handle an array of files.\n    } else if (Array.isArray(project)) {\n      // Validate the file array.\n      if (!project.every((file) => file instanceof File)) {\n        throw new Error(\"All entries in `project` must be `File` instances.\");\n      }\n      const sindriJsonFile = project.find(\n        (file) => file.name === \"sindri.json\",\n      );\n      if (!sindriJsonFile) {\n        throw new Error(\n          \"The `project` array must include a `sindri.json` file.\",\n        );\n      }\n      let sindriJson;\n      try {\n        sindriJson = JSON.parse(await sindriJsonFile.text()) as {\n          name: string;\n        };\n      } catch {\n        throw new Error(`Could not parse \"sindri.json\", is it valid JSON?`);\n      }\n      const circuitName = sindriJson?.name;\n      if (!circuitName) {\n        throw new Error(\n          `No circuit \"name\" field was found in \"sindri.json\", the manifest is invalid.`,\n        );\n      }\n\n      // Create the gzipped tarball.\n      const tarball = new Tar();\n      project.sort((a, b) => a.name.localeCompare(b.name)); // Deterministic for tests.\n      for (const file of project) {\n        const content = new Uint8Array(await file.arrayBuffer());\n        await new Promise((resolve) =>\n          tarball.append(`${circuitName}/${file.name}`, content, resolve),\n        );\n      }\n      const gzippedTarball = new Uint8Array(gzip.zip(tarball.out));\n      const tarFile = new File([gzippedTarball], `${circuitName}.tar.gz`);\n\n      // Append the tarball to the form data.\n      // These lines are functionally identical, but we want to typecheck node and browser.\n      if (process.env.BROWSER_BUILD) {\n        (formData as BrowserFormData).append(\"files\", tarFile as BrowserFile);\n      } else {\n        (formData as NodeFormData).append(\"files\", tarFile as NodeFile);\n      }\n    }\n\n    // We need to shuffle in a hard-coded form boundary for tests to be deterministic.\n    // Note that it's important the boundary matches the Chrome format because the test runner\n    // checks payloads for this format in order to compare non-deterministic gzips.\n    // TODO: These header changes are global, we need to make them local to this request.\n    const oldHeaders = this._clientConfig.HEADERS;\n    this._clientConfig.HEADERS = {\n      ...oldHeaders,\n      \"Content-Type\":\n        \"multipart/form-data; boundary=----WebKitFormBoundary0buQ8d6EhWcs9X9d\",\n    };\n    const createResponsePromise = this._client.circuits.circuitCreate(\n      formData as NodeFormData,\n    );\n    const createResponse = await createResponsePromise;\n    this._clientConfig.HEADERS = oldHeaders;\n    const circuitId = createResponse.circuit_id;\n\n    let response: CircuitInfoResponse;\n    while (true) {\n      response = await this._client.circuits.circuitDetail(circuitId, false);\n      if (response.status === \"Ready\" || response.status === \"Failed\") {\n        break;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, this.pollingInterval));\n    }\n    return response;\n  }\n\n  /**\n   * Retrieves all proofs associated with a specified circuit.  This method is essential for\n   * obtaining a comprehensive list of proofs generated for a given circuit, identified by its\n   * unique circuit ID. It returns an array of `ProofInfoResponse` objects, each representing a\n   * proof associated with the circuit.\n   *\n   * The method is particularly useful in scenarios where tracking or auditing all proofs of a\n   * circuit is necessary. This could include verifying the integrity of proofs, understanding their\n   * usage, or simply enumerating them for record-keeping.\n   *\n   * The `circuitId` parameter is a string that uniquely identifies the circuit in question. It's\n   * crucial to provide the correct circuit ID to retrieve the corresponding proofs accurately.\n   *\n   * @param circuitId - The unique identifier of the circuit for which proofs are to be retrieved.\n   * @returns A promise that resolves to an array of details for each associated proof.\n   *\n   * @example\n   * const proofs = await client.getAllCircuitProofs(circuitId);\n   * console.log(\"Proofs:', proofs);\n   */\n  async getAllCircuitProofs(circuitId: string): Promise<ProofInfoResponse[]> {\n    return await this._client.circuits.circuitProofs(circuitId);\n  }\n\n  /**\n   * Retrieves all circuits associated with the team.  This method fetches a list of all circuits\n   * that have been created or accessed by the currently authenticated team. It's a key method for\n   * managing and monitoring circuit usage within a team, offering insights into the variety and\n   * scope of circuits in use.\n   *\n   * @returns A promise that resolves to an array of circuit information responses.\n   *\n   * @example\n   * const circuits = await = client.getAllCircuits();\n   * console.log(\"Circuits:\", circuits);\n   */\n  async getAllCircuits(): Promise<CircuitInfoResponse[]> {\n    return await this._client.circuits.circuitList();\n  }\n\n  /**\n   * Retrieves a specific circuit using its unique circuit ID.  This method is crucial for obtaining\n   * detailed information about a particular circuit,  identified by the provided `circuitId`. It's\n   * especially useful when detailed insights  or operations on a single circuit are required, rather\n   * than handling multiple circuits.\n   *\n   * *Note:* In case the provided `circuitId` is invalid or does not correspond to an existing circuit,\n   * the promise may reject, indicating an error. Proper error handling is therefore essential when using this method.\n   *\n   * @param circuitId - The unique identifier of the circuit to retrieve.\n   * @returns A promise that resolves to the information about the specified circuit.\n   *\n   * @example\n   * const circuit = await client.getCircuit(circuitId);\n   * console.log('Circuit details:', circuit);\n   */\n  async getCircuit(circuitId: string): Promise<CircuitInfoResponse> {\n    return await this._client.circuits.circuitDetail(circuitId);\n  }\n\n  /**\n   * Retrieves detailed information about a specific proof, identified by its unique proof ID.  This\n   * method is vital for obtaining individual proof details, facilitating in-depth analysis or\n   * verification of a particular proof within the system.\n   *\n   * The `proofId` parameter is the key identifier for the proof, and it should be provided to fetch\n   * the corresponding information. The method returns a promise that resolves to a\n   * {@link ProofInfoResponse}, containing all relevant details of the proof.\n   *\n   * @param proofId - The unique identifier of the proof to retrieve.\n   * @returns A promise that resolves to the data about the specified proof.\n   *\n   * @example\n   * const proof = await client.getProof(proofId);\n   * console.log(\"Proof details:\", proof);\n   */\n  async getProof(proofId: string): Promise<ProofInfoResponse> {\n    return await this._client.proofs.proofDetail(proofId);\n  }\n\n  /**\n   * Generates a proof for a specified circuit.  This method is critical for creating a new proof\n   * based on a given circuit, identified by `circuitId`, and the provided `proofInput`. It's\n   * primarily used to validate or verify certain conditions or properties of the circuit without\n   * revealing underlying data or specifics. The method continuously polls the service to track the\n   * compilation status until the process either completes successfully or fails.\n   *\n   * The `circuitId` parameter specifies the unique identifier of the circuit for which the proof is\n   * to be generated.  The `proofInput` is a string that represents the necessary input data or\n   * parameters required for generating the proof.\n   *\n   * @param circuitId - The unique identifier of the circuit for which the proof is being generated.\n   * @param proofInput - The input data required for generating the proof. This should be a string\n   * containing either JSON data or TOML data (in the case of Noir).\n   * @returns A promise that resolves to the information of the generated proof.\n   *\n   * @example\n   * const proof = await client.proveCircuit(circuitId, '{\"X\": 23, \"Y\": 52}');\n   * console.log(\"Generated proof:\", proof);\n   */\n  async proveCircuit(\n    circuitId: string,\n    proofInput: string,\n    verify: boolean = false,\n    includeSmartContractCalldata: boolean = false,\n  ): Promise<ProofInfoResponse> {\n    const createResponse = await this._client.circuits.proofCreate(circuitId, {\n      perform_verify: verify,\n      proof_input: proofInput,\n    });\n    let response: ProofInfoResponse;\n    while (true) {\n      response = await this._client.proofs.proofDetail(\n        createResponse.proof_id,\n        true, // includeProof\n        true, // includePublic\n        includeSmartContractCalldata, // includeSmartContractCalldata\n        true, // includeVerificationKey\n      );\n      if (response.status === \"Ready\" || response.status === \"Failed\") {\n        break;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, this.pollingInterval));\n    }\n    return response;\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from \"./ApiRequestOptions\";\nimport type { CancelablePromise } from \"./CancelablePromise\";\nimport type { OpenAPIConfig } from \"./OpenAPI\";\n\nexport abstract class BaseHttpRequest {\n  constructor(public readonly config: OpenAPIConfig) {}\n\n  public abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;\n}\n","/* This file was originally generated by `openapi-typescript-codegen`, but we've customized it and\n * it is no longer regenerated. The key changes:\n *\n *   * Support pre-constructed `FormData` instances, and make `FormData` isomorphic.\n *   * Add request/response logging for all API requests in `request()`.\n */\n\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport axios from \"axios\";\nimport type {\n  AxiosError,\n  AxiosRequestConfig,\n  AxiosResponse,\n  AxiosInstance,\n} from \"axios\";\n// Manual edit to use our isomorphic `FormData`.\nimport { FormData } from \"lib/isomorphic\";\n\nimport { ApiError } from \"./ApiError\";\nimport type { ApiRequestOptions } from \"./ApiRequestOptions\";\nimport type { ApiResult } from \"./ApiResult\";\nimport { CancelablePromise } from \"./CancelablePromise\";\nimport type { OnCancel } from \"./CancelablePromise\";\nimport type { OpenAPIConfig } from \"./OpenAPI\";\n\nexport const isDefined = <T>(\n  value: T | null | undefined,\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\nexport const isString = (value: any): value is string => {\n  return typeof value === \"string\";\n};\n\nexport const isStringWithValue = (value: any): value is string => {\n  return isString(value) && value !== \"\";\n};\n\nexport const isBlob = (value: any): value is Blob => {\n  return (\n    typeof value === \"object\" &&\n    typeof value.type === \"string\" &&\n    typeof value.stream === \"function\" &&\n    typeof value.arrayBuffer === \"function\" &&\n    typeof value.constructor === \"function\" &&\n    typeof value.constructor.name === \"string\" &&\n    /^(Blob|File)$/.test(value.constructor.name) &&\n    /^(Blob|File)$/.test(value[Symbol.toStringTag])\n  );\n};\n\nexport const isFormData = (value: any): value is FormData => {\n  return value instanceof FormData;\n};\n\nexport const isSuccess = (status: number): boolean => {\n  return status >= 200 && status < 300;\n};\n\nexport const base64 = (str: string): string => {\n  try {\n    return btoa(str);\n  } catch (err) {\n    // @ts-ignore\n    return Buffer.from(str).toString(\"base64\");\n  }\n};\n\nexport const getQueryString = (params: Record<string, any>): string => {\n  const qs: string[] = [];\n\n  const append = (key: string, value: any) => {\n    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n  };\n\n  const process = (key: string, value: any) => {\n    if (isDefined(value)) {\n      if (Array.isArray(value)) {\n        value.forEach((v) => {\n          process(key, v);\n        });\n      } else if (typeof value === \"object\") {\n        Object.entries(value).forEach(([k, v]) => {\n          process(`${key}[${k}]`, v);\n        });\n      } else {\n        append(key, value);\n      }\n    }\n  };\n\n  Object.entries(params).forEach(([key, value]) => {\n    process(key, value);\n  });\n\n  if (qs.length > 0) {\n    return `?${qs.join(\"&\")}`;\n  }\n\n  return \"\";\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n  const encoder = config.ENCODE_PATH || encodeURI;\n\n  const path = options.url\n    .replace(\"{api-version}\", config.VERSION)\n    .replace(/{(.*?)}/g, (substring: string, group: string) => {\n      if (options.path?.hasOwnProperty(group)) {\n        return encoder(String(options.path[group]));\n      }\n      return substring;\n    });\n\n  const url = `${config.BASE}${path}`;\n  if (options.query) {\n    return `${url}${getQueryString(options.query)}`;\n  }\n  return url;\n};\n\nexport const getFormData = (\n  options: ApiRequestOptions,\n): FormData | undefined => {\n  if (options.formData) {\n    // This is a manual edit to allow `FormData` to be passed in directly.\n    if (options.formData instanceof FormData) {\n      return options.formData;\n    }\n\n    const formData = new FormData();\n\n    const process = (key: string, value: any) => {\n      if (isString(value) || isBlob(value)) {\n        formData.append(key, value);\n      } else {\n        formData.append(key, JSON.stringify(value));\n      }\n    };\n\n    Object.entries(options.formData)\n      .filter(([_, value]) => isDefined(value))\n      .forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((v) => process(key, v));\n        } else {\n          process(key, value);\n        }\n      });\n\n    return formData;\n  }\n  return undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nexport const resolve = async <T>(\n  options: ApiRequestOptions,\n  resolver?: T | Resolver<T>,\n): Promise<T | undefined> => {\n  if (typeof resolver === \"function\") {\n    return (resolver as Resolver<T>)(options);\n  }\n  return resolver;\n};\n\nexport const getHeaders = async (\n  config: OpenAPIConfig,\n  options: ApiRequestOptions,\n  formData?: FormData,\n): Promise<Record<string, string>> => {\n  const token = await resolve(options, config.TOKEN);\n  const username = await resolve(options, config.USERNAME);\n  const password = await resolve(options, config.PASSWORD);\n  const additionalHeaders = await resolve(options, config.HEADERS);\n  // Manual edit to support `FormData` implementations that don't include `getHeaders()`.\n  const formHeaders =\n    (formData &&\n      \"getHeaders\" in formData &&\n      typeof formData?.getHeaders === \"function\" &&\n      formData?.getHeaders()) ||\n    {};\n\n  const headers = Object.entries({\n    Accept: \"application/json\",\n    ...additionalHeaders,\n    ...options.headers,\n    ...formHeaders,\n  })\n    .filter(([_, value]) => isDefined(value))\n    .reduce(\n      (headers, [key, value]) => ({\n        ...headers,\n        [key]: String(value),\n      }),\n      {} as Record<string, string>,\n    );\n\n  if (isStringWithValue(token)) {\n    headers[\"Authorization\"] = `Bearer ${token}`;\n  }\n\n  if (isStringWithValue(username) && isStringWithValue(password)) {\n    const credentials = base64(`${username}:${password}`);\n    headers[\"Authorization\"] = `Basic ${credentials}`;\n  }\n\n  if (options.body) {\n    if (options.mediaType) {\n      headers[\"Content-Type\"] = options.mediaType;\n    } else if (isBlob(options.body)) {\n      headers[\"Content-Type\"] = options.body.type || \"application/octet-stream\";\n    } else if (isString(options.body)) {\n      headers[\"Content-Type\"] = \"text/plain\";\n    } else if (!isFormData(options.body)) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n  }\n\n  return headers;\n};\n\nexport const getRequestBody = (options: ApiRequestOptions): any => {\n  if (options.body) {\n    return options.body;\n  }\n  return undefined;\n};\n\nexport const sendRequest = async <T>(\n  config: OpenAPIConfig,\n  options: ApiRequestOptions,\n  url: string,\n  body: any,\n  formData: FormData | undefined,\n  headers: Record<string, string>,\n  onCancel: OnCancel,\n  axiosClient: AxiosInstance,\n): Promise<AxiosResponse<T>> => {\n  const source = axios.CancelToken.source();\n\n  const requestConfig: AxiosRequestConfig = {\n    url,\n    headers,\n    data: body ?? formData,\n    method: options.method,\n    withCredentials: config.WITH_CREDENTIALS,\n    cancelToken: source.token,\n    responseType: options.responseType,\n  };\n\n  onCancel(() => source.cancel(\"The user aborted a request.\"));\n\n  try {\n    const response = await axiosClient.request(requestConfig);\n    return response;\n  } catch (error) {\n    const axiosError = error as AxiosError<T>;\n    if (axiosError.response) {\n      return axiosError.response;\n    }\n    throw error;\n  }\n};\n\nexport const getResponseHeader = (\n  response: AxiosResponse<any>,\n  responseHeader?: string,\n): string | undefined => {\n  if (responseHeader) {\n    const content = response.headers[responseHeader];\n    if (isString(content)) {\n      return content;\n    }\n  }\n  return undefined;\n};\n\nexport const getResponseBody = (response: AxiosResponse<any>): any => {\n  if (response.status !== 204) {\n    return response.data;\n  }\n  return undefined;\n};\n\nexport const catchErrorCodes = (\n  options: ApiRequestOptions,\n  result: ApiResult,\n): void => {\n  const errors: Record<number, string> = {\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    500: \"Internal Server Error\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    ...options.errors,\n  };\n\n  const error = errors[result.status];\n  if (error) {\n    throw new ApiError(options, result, error);\n  }\n\n  if (!result.ok) {\n    const errorStatus = result.status ?? \"unknown\";\n    const errorStatusText = result.statusText ?? \"unknown\";\n    const errorBody = (() => {\n      try {\n        return JSON.stringify(result.body, null, 2);\n      } catch (e) {\n        return undefined;\n      }\n    })();\n\n    throw new ApiError(\n      options,\n      result,\n      `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`,\n    );\n  }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @param axiosClient The axios client instance to use\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(\n  config: OpenAPIConfig,\n  options: ApiRequestOptions,\n  axiosClient: AxiosInstance = axios,\n): CancelablePromise<T> => {\n  return new CancelablePromise(async (resolve, reject, onCancel) => {\n    // Get a nicely formatted timedelta to display after requests.\n    const startTime = Date.now();\n    const getElapsedTime = (): string => {\n      const ellapsedMilliseconds = Date.now() - startTime;\n      if (ellapsedMilliseconds < 1000) {\n        return `${ellapsedMilliseconds} ms`;\n      }\n      const ellapsedSeconds = ellapsedMilliseconds / 1000;\n      if (ellapsedSeconds < 60) {\n        return `${ellapsedSeconds.toFixed(2)} s`;\n      }\n      const ellapsedMinutes = ellapsedSeconds / 60;\n      if (ellapsedMinutes < 60) {\n        return `${ellapsedMinutes.toFixed(2)} m`;\n      }\n      const ellapsedHours = ellapsedMinutes / 60;\n      return `${ellapsedHours.toFixed(2)} h`;\n    };\n\n    const url = getUrl(config, options);\n    const logPrefix = `${options.method} ${url}`;\n    try {\n      const formData = getFormData(options);\n      const body = getRequestBody(options);\n      const headers = await getHeaders(config, options, formData);\n\n      if (!onCancel.isCancelled) {\n        config.logger?.debug(`${logPrefix} requested`);\n        const response = await sendRequest<T>(\n          config,\n          options,\n          url,\n          body,\n          formData,\n          headers,\n          onCancel,\n          axiosClient,\n        );\n        const responseBody = getResponseBody(response);\n        const responseHeader = getResponseHeader(\n          response,\n          options.responseHeader,\n        );\n\n        const result: ApiResult = {\n          url,\n          ok: isSuccess(response.status),\n          status: response.status,\n          statusText: response.statusText,\n          body: responseHeader ?? responseBody,\n        };\n        const responseMessage = `${logPrefix} ${response.status} ${\n          response.statusText\n        } (${getElapsedTime()})`;\n        if (!result.body || typeof result.body === \"string\") {\n          config.logger?.debug(\n            `${responseMessage} - ${result.body || \"<empty-body>\"}`,\n          );\n        } else if (options.responseType === \"stream\") {\n          config.logger?.debug(`${responseMessage} - <streaming-response>`);\n        } else if (options.responseType === \"blob\") {\n          config.logger?.debug(`${responseMessage} - <blob-response>`);\n        } else {\n          config.logger?.debug(result.body, responseMessage);\n        }\n\n        catchErrorCodes(options, result);\n\n        resolve(result.body);\n      }\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      config.logger?.debug(\n        `${logPrefix} ERROR (${getElapsedTime()}) - ${errorMessage}`,\n      );\n      reject(error);\n    }\n  });\n};\n","import { File as NodeFile } from \"buffer\";\n\nimport { FormData as NodeFormData } from \"formdata-node\";\n\nexport function assertType<T>(value: unknown) {\n  function isType<T>(value: unknown): value is T {\n    return true || value;\n  }\n  if (!isType<T>(value)) throw new Error(\"Impossible.\");\n}\n\nexport type { NodeFile, NodeFormData };\nexport type BrowserFile = File;\nexport type BrowserFormData = FormData;\n\nexport const File = process.env.BROWSER_BUILD ? window.File : NodeFile;\nexport const FormData = process.env.BROWSER_BUILD\n  ? window.FormData\n  : NodeFormData;\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from \"./ApiRequestOptions\";\nimport type { ApiResult } from \"./ApiResult\";\n\nexport class ApiError extends Error {\n  public readonly url: string;\n  public readonly status: number;\n  public readonly statusText: string;\n  public readonly body: any;\n  public readonly request: ApiRequestOptions;\n\n  constructor(\n    request: ApiRequestOptions,\n    response: ApiResult,\n    message: string,\n  ) {\n    super(message);\n\n    this.name = \"ApiError\";\n    this.url = response.url;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.body = response.body;\n    this.request = request;\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nexport class CancelError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"CancelError\";\n  }\n\n  public get isCancelled(): boolean {\n    return true;\n  }\n}\n\nexport interface OnCancel {\n  readonly isResolved: boolean;\n  readonly isRejected: boolean;\n  readonly isCancelled: boolean;\n\n  (cancelHandler: () => void): void;\n}\n\nexport class CancelablePromise<T> implements Promise<T> {\n  #isResolved: boolean;\n  #isRejected: boolean;\n  #isCancelled: boolean;\n  readonly #cancelHandlers: (() => void)[];\n  readonly #promise: Promise<T>;\n  #resolve?: (value: T | PromiseLike<T>) => void;\n  #reject?: (reason?: any) => void;\n\n  constructor(\n    executor: (\n      resolve: (value: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void,\n      onCancel: OnCancel,\n    ) => void,\n  ) {\n    this.#isResolved = false;\n    this.#isRejected = false;\n    this.#isCancelled = false;\n    this.#cancelHandlers = [];\n    this.#promise = new Promise<T>((resolve, reject) => {\n      this.#resolve = resolve;\n      this.#reject = reject;\n\n      const onResolve = (value: T | PromiseLike<T>): void => {\n        if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n          return;\n        }\n        this.#isResolved = true;\n        this.#resolve?.(value);\n      };\n\n      const onReject = (reason?: any): void => {\n        if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n          return;\n        }\n        this.#isRejected = true;\n        this.#reject?.(reason);\n      };\n\n      const onCancel = (cancelHandler: () => void): void => {\n        if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n          return;\n        }\n        this.#cancelHandlers.push(cancelHandler);\n      };\n\n      Object.defineProperty(onCancel, \"isResolved\", {\n        get: (): boolean => this.#isResolved,\n      });\n\n      Object.defineProperty(onCancel, \"isRejected\", {\n        get: (): boolean => this.#isRejected,\n      });\n\n      Object.defineProperty(onCancel, \"isCancelled\", {\n        get: (): boolean => this.#isCancelled,\n      });\n\n      return executor(onResolve, onReject, onCancel as OnCancel);\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Cancellable Promise\";\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n    onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,\n  ): Promise<TResult1 | TResult2> {\n    return this.#promise.then(onFulfilled, onRejected);\n  }\n\n  public catch<TResult = never>(\n    onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,\n  ): Promise<T | TResult> {\n    return this.#promise.catch(onRejected);\n  }\n\n  public finally(onFinally?: (() => void) | null): Promise<T> {\n    return this.#promise.finally(onFinally);\n  }\n\n  public cancel(): void {\n    if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n      return;\n    }\n    this.#isCancelled = true;\n    if (this.#cancelHandlers.length) {\n      try {\n        for (const cancelHandler of this.#cancelHandlers) {\n          cancelHandler();\n        }\n      } catch (error) {\n        console.warn(\"Cancellation threw an error\", error);\n        return;\n      }\n    }\n    this.#cancelHandlers.length = 0;\n    this.#reject?.(new CancelError(\"Request aborted\"));\n  }\n\n  public get isCancelled(): boolean {\n    return this.#isCancelled;\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from \"./ApiRequestOptions\";\nimport { BaseHttpRequest } from \"./BaseHttpRequest\";\nimport type { CancelablePromise } from \"./CancelablePromise\";\nimport type { OpenAPIConfig } from \"./OpenAPI\";\nimport { request as __request } from \"./request\";\n\nexport class AxiosHttpRequest extends BaseHttpRequest {\n  constructor(config: OpenAPIConfig) {\n    super(config);\n  }\n\n  /**\n   * Request method\n   * @param options The request options from the service\n   * @returns CancelablePromise<T>\n   * @throws ApiError\n   */\n  public override request<T>(options: ApiRequestOptions): CancelablePromise<T> {\n    return __request(this.config, options);\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ActionResponse } from \"../models/ActionResponse\";\nimport type { APIKeyResponse } from \"../models/APIKeyResponse\";\nimport type { ObtainApikeyInput } from \"../models/ObtainApikeyInput\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\nexport class AuthorizationService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Generate API Key\n   * Generates a long-term API Key from your account's username and password.\n   * @param requestBody\n   * @returns APIKeyResponse OK\n   * @throws ApiError\n   */\n  public apikeyGenerate(\n    requestBody: ObtainApikeyInput,\n  ): CancelablePromise<APIKeyResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/apikey/generate\",\n      body: requestBody,\n      mediaType: \"application/json\",\n      errors: {\n        401: `Unauthorized`,\n        412: `Precondition Failed`,\n      },\n    });\n  }\n\n  /**\n   * Generate long-term API Key (requires prior authentication)\n   * Return a long-term API key for the user's team.\n   * @param name An optional name or tag to assign to the generated API Key.\n   * @returns APIKeyResponse Created\n   * @throws ApiError\n   */\n  public apikeyGenerateWithAuth(\n    name?: string,\n  ): CancelablePromise<APIKeyResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/v1/apikey/generate\",\n      query: {\n        name: name,\n      },\n      errors: {\n        412: `Precondition Failed`,\n      },\n    });\n  }\n\n  /**\n   * API Key List\n   * Return a list of API Keys for the team.\n   * @returns APIKeyResponse OK\n   * @throws ApiError\n   */\n  public apikeyList(): CancelablePromise<Array<APIKeyResponse>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/apikey/list\",\n      errors: {\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Delete API Key\n   * Mark the specified API Key as deleted.\n   * @param apikeyId The UUID4 identifier associated with this API Key.\n   * @returns ActionResponse OK\n   * @throws ApiError\n   */\n  public apikeyDelete(apikeyId: string): CancelablePromise<ActionResponse> {\n    return this.httpRequest.request({\n      method: \"DELETE\",\n      url: \"/api/v1/apikey/{apikey_id}/delete\",\n      path: {\n        apikey_id: apikeyId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ActionResponse } from \"../models/ActionResponse\";\nimport type { CircuitInfoResponse } from \"../models/CircuitInfoResponse\";\nimport type { ProofInfoResponse } from \"../models/ProofInfoResponse\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\nexport class CircuitsService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Create Circuit\n   * Create a circuit.\n   * @param formData\n   * @returns CircuitInfoResponse Created\n   * @throws ApiError\n   */\n  public circuitCreate(\n    formData: // This is a manual edit to allow `FormData` to be passed in directly:\n    | FormData // DO NOT REMOVE THIS!\n      | {\n          files: Array<Blob>;\n          /**\n           * Tags for a circuit.\n           */\n          tags?: Array<string>;\n        },\n  ): CancelablePromise<CircuitInfoResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/v1/circuit/create\",\n      formData: formData,\n      mediaType: \"multipart/form-data\",\n      errors: {\n        412: `Precondition Failed`,\n        422: `Unprocessable Entity`,\n        500: `Internal Server Error`,\n        501: `Not Implemented`,\n      },\n    });\n  }\n\n  /**\n   * Circuit List\n   * Return the list of all circuit infos.\n   * @returns CircuitInfoResponse OK\n   * @throws ApiError\n   */\n  public circuitList(): CancelablePromise<Array<CircuitInfoResponse>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/list\",\n      errors: {\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Circuit Detail\n   * Get info for an existing circuit.\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @param includeVerificationKey Indicates whether to include the verification key in the response.\n   * @returns CircuitInfoResponse OK\n   * @throws ApiError\n   */\n  public circuitDetail(\n    circuitId: string,\n    includeVerificationKey: boolean = true,\n  ): CancelablePromise<CircuitInfoResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/{circuit_id}/detail\",\n      path: {\n        circuit_id: circuitId,\n      },\n      query: {\n        include_verification_key: includeVerificationKey,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Delete Circuit\n   * Mark the specified circuit and any of its related proofs as deleted.\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @returns ActionResponse OK\n   * @throws ApiError\n   */\n  public circuitDelete(circuitId: string): CancelablePromise<ActionResponse> {\n    return this.httpRequest.request({\n      method: \"DELETE\",\n      url: \"/api/v1/circuit/{circuit_id}/delete\",\n      path: {\n        circuit_id: circuitId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Circuit Proofs\n   * Return a list of proof infos for the provided circuit_id.\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @returns ProofInfoResponse OK\n   * @throws ApiError\n   */\n  public circuitProofs(\n    circuitId: string,\n  ): CancelablePromise<Array<ProofInfoResponse>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/{circuit_id}/proofs\",\n      path: {\n        circuit_id: circuitId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Create Proof for Circuit\n   * Prove a circuit with specific inputs.\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @param formData\n   * @returns ProofInfoResponse Created\n   * @throws ApiError\n   */\n  public proofCreate(\n    circuitId: string,\n    formData: {\n      /**\n       * A string representing proof input which may be formatted as JSON for any framework. Noir circuits optionally accept TOML formatted proof input.\n       */\n      proof_input: string;\n      /**\n       * A boolean indicating whether to perform an internal verification check during the proof creation.\n       */\n      perform_verify?: boolean;\n      /**\n       * Internal prover implementation setting.\n       */\n      prover_implementation?: string;\n    },\n  ): CancelablePromise<ProofInfoResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/v1/circuit/{circuit_id}/prove\",\n      path: {\n        circuit_id: circuitId,\n      },\n      formData: formData,\n      mediaType: \"application/x-www-form-urlencoded\",\n      errors: {\n        404: `Not Found`,\n        412: `Precondition Failed`,\n        501: `Not Implemented`,\n      },\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ActionResponse } from \"../models/ActionResponse\";\nimport type { ProofInfoResponse } from \"../models/ProofInfoResponse\";\nimport type { SmartContractVerifierResponse } from \"../models/SmartContractVerifierResponse\";\nimport type { TeamMeResponse } from \"../models/TeamMeResponse\";\nimport type { UserMeResponse } from \"../models/UserMeResponse\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\n// DO NOT REMOVE\ntype BinaryResponseType = typeof globalThis extends { ReadableStream: unknown }\n  ? Blob\n  : NodeJS.ReadableStream;\n\nexport class InternalService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Circuit Download\n   * Return the gzipped tarball for the specified circuit.\n   * @param circuitId\n   * @returns binary OK\n   * @throws ApiError\n   */\n  public circuitDownload(\n    circuitId: string,\n    // DO NOT REMOVE\n  ): CancelablePromise<BinaryResponseType> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/{circuit_id}/download\",\n      path: {\n        circuit_id: circuitId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n      responseType: process.env.BROWSER_BUILD ? \"blob\" : \"stream\", // DO NOT REMOVE\n    });\n  }\n\n  /**\n   * Circuit Smart Contract Verifier\n   * Get smart contract verifier for existing circuit\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @returns SmartContractVerifierResponse OK\n   * @throws ApiError\n   */\n  public circuitSmartContractVerifier(\n    circuitId: string,\n  ): CancelablePromise<SmartContractVerifierResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/{circuit_id}/smart_contract_verifier\",\n      path: {\n        circuit_id: circuitId,\n      },\n      errors: {\n        404: `Not Found`,\n        412: `Precondition Failed`,\n        500: `Internal Server Error`,\n        501: `Not Implemented`,\n      },\n    });\n  }\n\n  /**\n   * Change user password (requires JWT authentication)\n   * Change password for a user.\n   *\n   * This endpoint requires JWT authentication in order\n   * to know which user is making the request. It expects to receive\n   * an authenticated user in `request.auth`.\n   *\n   * We subsequently verify the old password and then update the user's password.\n   * @param formData\n   * @returns ActionResponse OK\n   * @throws ApiError\n   */\n  public passwordChangeWithJwtAuth(formData: {\n    /**\n     * Old password.\n     */\n    old_password: string;\n    /**\n     * New password.\n     */\n    new_password: string;\n  }): CancelablePromise<ActionResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/v1/password/change\",\n      formData: formData,\n      mediaType: \"application/x-www-form-urlencoded\",\n      errors: {\n        422: `Unprocessable Entity`,\n      },\n    });\n  }\n\n  /**\n   * Proof List\n   * Return the list of all proof infos.\n   * @returns ProofInfoResponse OK\n   * @throws ApiError\n   */\n  public proofList(): CancelablePromise<Array<ProofInfoResponse>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/proof/list\",\n      errors: {\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Return the JSON schema for `sindri.json` manifest files\n   * Return the JSON schema for `sindri.json` manifest files\n   * @returns any OK\n   * @throws ApiError\n   */\n  public sindriManifestSchema(): CancelablePromise<Record<string, any>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/sindri-manifest-schema.json\",\n    });\n  }\n\n  /**\n   * Obtain team details for the currently authenticated team\n   * Return details about the currently authenticated team.\n   * @returns TeamMeResponse OK\n   * @throws ApiError\n   */\n  public teamMe(): CancelablePromise<TeamMeResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/team/me\",\n    });\n  }\n\n  /**\n   * Obtain user details (requires JWT authentication)\n   * Return details about the user and their teams.\n   *\n   * This endpoint requires JWT authentication in order\n   * to know which user is making the request. It expects to receive\n   * an authenticated user in `request.auth`.\n   * @returns UserMeResponse OK\n   * @throws ApiError\n   */\n  public userMeWithJwtAuth(): CancelablePromise<UserMeResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/user/me\",\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ActionResponse } from \"../models/ActionResponse\";\nimport type { ProofInfoResponse } from \"../models/ProofInfoResponse\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\nexport class ProofsService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Proof Detail\n   * Get info for an existing proof.\n   * @param proofId The UUID4 identifier associated with this proof.\n   * @param includeProof Indicates whether to include the proof in the response.\n   * @param includePublic Indicates whether to include public inputs in the response.\n   * @param includeSmartContractCalldata Indicates whether to include the proof and public formatted as smart contract calldata in the response.\n   * @param includeVerificationKey Indicates whether to include the circuit's verification key in the response.\n   * @returns ProofInfoResponse OK\n   * @throws ApiError\n   */\n  public proofDetail(\n    proofId: string,\n    includeProof: boolean = true,\n    includePublic: boolean = true,\n    includeSmartContractCalldata: boolean = false,\n    includeVerificationKey: boolean = true,\n  ): CancelablePromise<ProofInfoResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/proof/{proof_id}/detail\",\n      path: {\n        proof_id: proofId,\n      },\n      query: {\n        include_proof: includeProof,\n        include_public: includePublic,\n        include_smart_contract_calldata: includeSmartContractCalldata,\n        include_verification_key: includeVerificationKey,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n        501: `Not Implemented`,\n      },\n    });\n  }\n\n  /**\n   * Delete Proof\n   * Mark the specified proof as deleted.\n   * @param proofId The UUID4 identifier associated with this proof.\n   * @returns ActionResponse OK\n   * @throws ApiError\n   */\n  public proofDelete(proofId: string): CancelablePromise<ActionResponse> {\n    return this.httpRequest.request({\n      method: \"DELETE\",\n      url: \"/api/v1/proof/{proof_id}/delete\",\n      path: {\n        proof_id: proofId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { Schema } from \"../models/Schema\";\nimport type { TokenObtainPairInputSchema } from \"../models/TokenObtainPairInputSchema\";\nimport type { TokenObtainPairOutputSchema } from \"../models/TokenObtainPairOutputSchema\";\nimport type { TokenRefreshInputSchema } from \"../models/TokenRefreshInputSchema\";\nimport type { TokenRefreshOutputSchema } from \"../models/TokenRefreshOutputSchema\";\nimport type { TokenVerifyInputSchema } from \"../models/TokenVerifyInputSchema\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\nexport class TokenService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Obtain Token\n   * @param requestBody\n   * @returns TokenObtainPairOutputSchema OK\n   * @throws ApiError\n   */\n  public fd3Aaa7BControllerObtainToken(\n    requestBody: TokenObtainPairInputSchema,\n  ): CancelablePromise<TokenObtainPairOutputSchema> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/token/pair\",\n      body: requestBody,\n      mediaType: \"application/json\",\n    });\n  }\n\n  /**\n   * Refresh Token\n   * @param requestBody\n   * @returns TokenRefreshOutputSchema OK\n   * @throws ApiError\n   */\n  public b87E0720ControllerRefreshToken(\n    requestBody: TokenRefreshInputSchema,\n  ): CancelablePromise<TokenRefreshOutputSchema> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/token/refresh\",\n      body: requestBody,\n      mediaType: \"application/json\",\n    });\n  }\n\n  /**\n   * Verify Token\n   * @param requestBody\n   * @returns Schema OK\n   * @throws ApiError\n   */\n  public d1C092ControllerVerifyToken(\n    requestBody: TokenVerifyInputSchema,\n  ): CancelablePromise<Schema> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/token/verify\",\n      body: requestBody,\n      mediaType: \"application/json\",\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { BaseHttpRequest } from './core/BaseHttpRequest';\nimport type { OpenAPIConfig } from './core/OpenAPI';\nimport { AxiosHttpRequest } from './core/AxiosHttpRequest';\n\nimport { AuthorizationService } from './services/AuthorizationService';\nimport { CircuitsService } from './services/CircuitsService';\nimport { InternalService } from './services/InternalService';\nimport { ProofsService } from './services/ProofsService';\nimport { TokenService } from './services/TokenService';\n\ntype HttpRequestConstructor = new (config: OpenAPIConfig) => BaseHttpRequest;\n\nexport class ApiClient {\n\n    public readonly authorization: AuthorizationService;\n    public readonly circuits: CircuitsService;\n    public readonly internal: InternalService;\n    public readonly proofs: ProofsService;\n    public readonly token: TokenService;\n\n    public readonly request: BaseHttpRequest;\n\n    constructor(config?: Partial<OpenAPIConfig>, HttpRequest: HttpRequestConstructor = AxiosHttpRequest) {\n        this.request = new HttpRequest({\n            BASE: config?.BASE ?? 'https://sindri.app',\n            VERSION: config?.VERSION ?? '1.6.14',\n            WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,\n            CREDENTIALS: config?.CREDENTIALS ?? 'include',\n            TOKEN: config?.TOKEN,\n            USERNAME: config?.USERNAME,\n            PASSWORD: config?.PASSWORD,\n            HEADERS: config?.HEADERS,\n            ENCODE_PATH: config?.ENCODE_PATH,\n        });\n\n        this.authorization = new AuthorizationService(this.request);\n        this.circuits = new CircuitsService(this.request);\n        this.internal = new InternalService(this.request);\n        this.proofs = new ProofsService(this.request);\n        this.token = new TokenService(this.request);\n    }\n}\n\n","import fs from \"fs\";\nimport path from \"path\";\n\nimport envPaths from \"env-paths\";\nimport _ from \"lodash\";\nimport { z } from \"zod\";\n\nimport { type Logger } from \"lib/logging\";\n\nconst getConfigPath = (): string => {\n  const paths = envPaths(\"sindri\", {\n    suffix: \"\",\n  });\n  return path.join(paths.config, \"sindri.conf.json\");\n};\n\nconst ConfigSchema = z.object({\n  auth: z\n    .nullable(\n      z.object({\n        apiKey: z.string(),\n        apiKeyId: z.string(),\n        apiKeyName: z.string(),\n        baseUrl: z.string().url(),\n        teamId: z.number(),\n        teamSlug: z.string(),\n      }),\n    )\n    .default(null),\n});\n\ntype ConfigSchema = z.infer<typeof ConfigSchema>;\n\nconst defaultConfig: ConfigSchema = ConfigSchema.parse({});\n\nexport const loadConfig = (logger?: Logger): ConfigSchema => {\n  const configPath = getConfigPath();\n  if (fs.existsSync(configPath)) {\n    logger?.debug(`Loading config from \"${configPath}\".`);\n    try {\n      const configFileContents: string = fs.readFileSync(configPath, {\n        encoding: \"utf-8\",\n      });\n      const loadedConfig = ConfigSchema.parse(JSON.parse(configFileContents));\n      logger?.debug(\"Config loaded successfully.\");\n      return loadedConfig;\n    } catch (error) {\n      logger?.warn(\n        `The config schema in \"${configPath}\" is invalid and will not be used.\\n` +\n          `To remove it and start fresh, run:\\n    rm ${configPath}`,\n      );\n      logger?.debug(error);\n    }\n  }\n  logger?.debug(\n    `Config file \"${configPath}\" does not exist, initializing default config.`,\n  );\n  return _.cloneDeep(defaultConfig);\n};\n\nexport class Config {\n  protected _config!: ConfigSchema;\n  protected readonly logger: Logger | undefined;\n\n  constructor(logger?: Logger) {\n    this.logger = logger;\n    this.reload();\n  }\n\n  get auth(): ConfigSchema[\"auth\"] {\n    return _.cloneDeep(this._config.auth);\n  }\n\n  get config(): ConfigSchema {\n    return _.cloneDeep(this._config);\n  }\n\n  reload() {\n    this._config = loadConfig(this.logger);\n  }\n\n  update(configData: Partial<ConfigSchema>) {\n    // Merge and validate the configs.\n    this.logger?.debug(\"Merging in config update:\");\n    this.logger?.debug(configData);\n    const newConfig: ConfigSchema = _.cloneDeep(this._config);\n    _.merge(newConfig, configData);\n    this._config = ConfigSchema.parse(newConfig);\n\n    // Create the directory if it doesn't exist.\n    const configPath = getConfigPath();\n    const directory = path.dirname(configPath);\n    if (!fs.existsSync(directory)) {\n      fs.mkdirSync(directory, { recursive: true });\n    }\n\n    // Write out the new config.\n    this.logger?.debug(\n      `Writing merged config to \"${configPath}\":`,\n      this._config,\n    );\n    fs.writeFileSync(configPath, JSON.stringify(this._config, null, 2), {\n      encoding: \"utf-8\",\n    });\n  }\n}\n","import pino, { type BaseLogger as Logger } from \"pino\";\nimport pretty from \"pino-pretty\";\n\nexport type { Logger };\n\n/**\n * The minimum log level to print.\n */\nexport type LogLevel =\n  | \"silent\"\n  | \"fatal\"\n  | \"error\"\n  | \"warn\"\n  | \"info\"\n  | \"debug\"\n  | \"trace\";\n\nexport const createLogger = (level?: LogLevel): Logger => {\n  const logger = pino(\n    process.env.BROWSER_BUILD\n      ? {\n          browser: { asObject: true },\n        }\n      : pretty({\n          colorize: true,\n          destination: 2,\n          ignore: \"hostname,pid\",\n          levelFirst: false,\n          sync: true,\n        }),\n  );\n  logger.level =\n    level ?? process.env.NODE_ENV === \"production\" ? \"silent\" : \"info\";\n  return logger;\n};\nexport const logger = createLogger();\n\nexport const print = console.log;\n","import { SindriClient } from \"./client\";\n\nexport default new SindriClient();\n\nexport type * from \"./client\";\nexport type { LogLevel } from \"./logging\";\n"]}