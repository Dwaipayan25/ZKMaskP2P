#! /usr/bin/env node
"use strict";var Kr=Object.create;var ae=Object.defineProperty;var Mr=Object.getOwnPropertyDescriptor;var Vr=Object.getOwnPropertyNames;var Wr=Object.getPrototypeOf,Gr=Object.prototype.hasOwnProperty;var Yr=(r,e)=>{for(var i in e)ae(r,i,{get:e[i],enumerable:!0})},He=(r,e,i,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of Vr(e))!Gr.call(r,o)&&o!==i&&ae(r,o,{get:()=>e[o],enumerable:!(n=Mr(e,o))||n.enumerable});return r};var h=(r,e,i)=>(i=r!=null?Kr(Wr(r)):{},He(e||!r||!r.__esModule?ae(i,"default",{value:r,enumerable:!0}):i,r)),Zr=r=>He(ae({},"__esModule",{value:!0}),r);var Tt={};Yr(Tt,{program:()=>Ur});module.exports=Zr(Tt);var Qr=()=>typeof document>"u"?new URL("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("main.js",document.baseURI).href,w=Qr();var Te=require("process"),zr=require("@commander-js/extra-typings");var er=h(require("assert")),Oe=h(require("fs")),rr=h(require("path")),F=h(require("process")),tr=require("@commander-js/extra-typings"),or=h(require("tar"));var te=require("fs/promises"),me=h(require("path")),Ye=h(require("gzip-js")),Ze=h(require("ignore-walk")),Qe=h(require("tar")),Xe=h(require("tar-js"));var V=class{constructor(e){this.config=e}};var Ee=h(require("axios"));var Je=require("buffer"),ze=require("formdata-node");var W=process.env.BROWSER_BUILD?window.File:Je.File,J=process.env.BROWSER_BUILD?window.FormData:ze.FormData;var T=class extends Error{url;status;statusText;body;request;constructor(e,i,n){super(n),this.name="ApiError",this.url=i.url,this.status=i.status,this.statusText=i.statusText,this.body=i.body,this.request=e}};var ce=class extends Error{constructor(e){super(e),this.name="CancelError"}get isCancelled(){return!0}},G=class{#r;#t;#e;#o;#i;#s;#n;constructor(e){this.#r=!1,this.#t=!1,this.#e=!1,this.#o=[],this.#i=new Promise((i,n)=>{this.#s=i,this.#n=n;let o=a=>{this.#r||this.#t||this.#e||(this.#r=!0,this.#s?.(a))},s=a=>{this.#r||this.#t||this.#e||(this.#t=!0,this.#n?.(a))},c=a=>{this.#r||this.#t||this.#e||this.#o.push(a)};return Object.defineProperty(c,"isResolved",{get:()=>this.#r}),Object.defineProperty(c,"isRejected",{get:()=>this.#t}),Object.defineProperty(c,"isCancelled",{get:()=>this.#e}),e(o,s,c)})}get[Symbol.toStringTag](){return"Cancellable Promise"}then(e,i){return this.#i.then(e,i)}catch(e){return this.#i.catch(e)}finally(e){return this.#i.finally(e)}cancel(){if(!(this.#r||this.#t||this.#e)){if(this.#e=!0,this.#o.length)try{for(let e of this.#o)e()}catch(e){console.warn("Cancellation threw an error",e);return}this.#o.length=0,this.#n?.(new ce("Request aborted"))}}get isCancelled(){return this.#e}};var Pe=r=>r!=null,pe=r=>typeof r=="string",ve=r=>pe(r)&&r!=="",Ue=r=>typeof r=="object"&&typeof r.type=="string"&&typeof r.stream=="function"&&typeof r.arrayBuffer=="function"&&typeof r.constructor=="function"&&typeof r.constructor.name=="string"&&/^(Blob|File)$/.test(r.constructor.name)&&/^(Blob|File)$/.test(r[Symbol.toStringTag]),Xr=r=>r instanceof J,et=r=>r>=200&&r<300,rt=r=>{try{return btoa(r)}catch{return Buffer.from(r).toString("base64")}},tt=r=>{let e=[],i=(o,s)=>{e.push(`${encodeURIComponent(o)}=${encodeURIComponent(String(s))}`)},n=(o,s)=>{Pe(s)&&(Array.isArray(s)?s.forEach(c=>{n(o,c)}):typeof s=="object"?Object.entries(s).forEach(([c,a])=>{n(`${o}[${c}]`,a)}):i(o,s))};return Object.entries(r).forEach(([o,s])=>{n(o,s)}),e.length>0?`?${e.join("&")}`:""},ot=(r,e)=>{let i=r.ENCODE_PATH||encodeURI,n=e.url.replace("{api-version}",r.VERSION).replace(/{(.*?)}/g,(s,c)=>e.path?.hasOwnProperty(c)?i(String(e.path[c])):s),o=`${r.BASE}${n}`;return e.query?`${o}${tt(e.query)}`:o},it=r=>{if(r.formData){if(r.formData instanceof J)return r.formData;let e=new J,i=(n,o)=>{pe(o)||Ue(o)?e.append(n,o):e.append(n,JSON.stringify(o))};return Object.entries(r.formData).filter(([n,o])=>Pe(o)).forEach(([n,o])=>{Array.isArray(o)?o.forEach(s=>i(n,s)):i(n,o)}),e}},le=async(r,e)=>typeof e=="function"?e(r):e,nt=async(r,e,i)=>{let n=await le(e,r.TOKEN),o=await le(e,r.USERNAME),s=await le(e,r.PASSWORD),c=await le(e,r.HEADERS),a=i&&"getHeaders"in i&&typeof i?.getHeaders=="function"&&i?.getHeaders()||{},m=Object.entries({Accept:"application/json",...c,...e.headers,...a}).filter(([f,l])=>Pe(l)).reduce((f,[l,d])=>({...f,[l]:String(d)}),{});if(ve(n)&&(m.Authorization=`Bearer ${n}`),ve(o)&&ve(s)){let f=rt(`${o}:${s}`);m.Authorization=`Basic ${f}`}return e.body&&(e.mediaType?m["Content-Type"]=e.mediaType:Ue(e.body)?m["Content-Type"]=e.body.type||"application/octet-stream":pe(e.body)?m["Content-Type"]="text/plain":Xr(e.body)||(m["Content-Type"]="application/json")),m},st=r=>{if(r.body)return r.body},at=async(r,e,i,n,o,s,c,a)=>{let m=Ee.default.CancelToken.source(),f={url:i,headers:s,data:n??o,method:e.method,withCredentials:r.WITH_CREDENTIALS,cancelToken:m.token,responseType:e.responseType};c(()=>m.cancel("The user aborted a request."));try{return await a.request(f)}catch(l){let d=l;if(d.response)return d.response;throw l}},ct=(r,e)=>{if(e){let i=r.headers[e];if(pe(i))return i}},lt=r=>{if(r.status!==204)return r.data},pt=(r,e)=>{let n={400:"Bad Request",401:"Unauthorized",403:"Forbidden",404:"Not Found",500:"Internal Server Error",502:"Bad Gateway",503:"Service Unavailable",...r.errors}[e.status];if(n)throw new T(r,e,n);if(!e.ok){let o=e.status??"unknown",s=e.statusText??"unknown",c=(()=>{try{return JSON.stringify(e.body,null,2)}catch{return}})();throw new T(r,e,`Generic Error: status: ${o}; status text: ${s}; body: ${c}`)}},Ke=(r,e,i=Ee.default)=>new G(async(n,o,s)=>{let c=Date.now(),a=()=>{let l=Date.now()-c;if(l<1e3)return`${l} ms`;let d=l/1e3;if(d<60)return`${d.toFixed(2)} s`;let g=d/60;return g<60?`${g.toFixed(2)} m`:`${(g/60).toFixed(2)} h`},m=ot(r,e),f=`${e.method} ${m}`;try{let l=it(e),d=st(e),g=await nt(r,e,l);if(!s.isCancelled){r.logger?.debug(`${f} requested`);let u=await at(r,e,m,d,l,g,s,i),p=lt(u),y=ct(u,e.responseHeader),R={url:m,ok:et(u.status),status:u.status,statusText:u.statusText,body:y??p},C=`${f} ${u.status} ${u.statusText} (${a()})`;!R.body||typeof R.body=="string"?r.logger?.debug(`${C} - ${R.body||"<empty-body>"}`):e.responseType==="stream"?r.logger?.debug(`${C} - <streaming-response>`):e.responseType==="blob"?r.logger?.debug(`${C} - <blob-response>`):r.logger?.debug(R.body,C),pt(e,R),n(R.body)}}catch(l){let d=l instanceof Error?l.message:"Unknown error";r.logger?.debug(`${f} ERROR (${a()}) - ${d}`),o(l)}});var ue=class extends V{constructor(e){super(e)}request(e){return Ke(this.config,e)}};var Y=class{constructor(e){this.httpRequest=e}apikeyGenerate(e){return this.httpRequest.request({method:"POST",url:"/api/apikey/generate",body:e,mediaType:"application/json",errors:{401:"Unauthorized",412:"Precondition Failed"}})}apikeyGenerateWithAuth(e){return this.httpRequest.request({method:"POST",url:"/api/v1/apikey/generate",query:{name:e},errors:{412:"Precondition Failed"}})}apikeyList(){return this.httpRequest.request({method:"GET",url:"/api/v1/apikey/list",errors:{500:"Internal Server Error"}})}apikeyDelete(e){return this.httpRequest.request({method:"DELETE",url:"/api/v1/apikey/{apikey_id}/delete",path:{apikey_id:e},errors:{404:"Not Found",500:"Internal Server Error"}})}};var Z=class{constructor(e){this.httpRequest=e}circuitCreate(e){return this.httpRequest.request({method:"POST",url:"/api/v1/circuit/create",formData:e,mediaType:"multipart/form-data",errors:{412:"Precondition Failed",422:"Unprocessable Entity",500:"Internal Server Error",501:"Not Implemented"}})}circuitList(){return this.httpRequest.request({method:"GET",url:"/api/v1/circuit/list",errors:{500:"Internal Server Error"}})}circuitDetail(e,i=!0){return this.httpRequest.request({method:"GET",url:"/api/v1/circuit/{circuit_id}/detail",path:{circuit_id:e},query:{include_verification_key:i},errors:{404:"Not Found",500:"Internal Server Error"}})}circuitDelete(e){return this.httpRequest.request({method:"DELETE",url:"/api/v1/circuit/{circuit_id}/delete",path:{circuit_id:e},errors:{404:"Not Found",500:"Internal Server Error"}})}circuitProofs(e){return this.httpRequest.request({method:"GET",url:"/api/v1/circuit/{circuit_id}/proofs",path:{circuit_id:e},errors:{404:"Not Found",500:"Internal Server Error"}})}proofCreate(e,i){return this.httpRequest.request({method:"POST",url:"/api/v1/circuit/{circuit_id}/prove",path:{circuit_id:e},formData:i,mediaType:"application/x-www-form-urlencoded",errors:{404:"Not Found",412:"Precondition Failed",501:"Not Implemented"}})}};var Q=class{constructor(e){this.httpRequest=e}circuitDownload(e){return this.httpRequest.request({method:"GET",url:"/api/v1/circuit/{circuit_id}/download",path:{circuit_id:e},errors:{404:"Not Found",500:"Internal Server Error"},responseType:process.env.BROWSER_BUILD?"blob":"stream"})}circuitSmartContractVerifier(e){return this.httpRequest.request({method:"GET",url:"/api/v1/circuit/{circuit_id}/smart_contract_verifier",path:{circuit_id:e},errors:{404:"Not Found",412:"Precondition Failed",500:"Internal Server Error",501:"Not Implemented"}})}passwordChangeWithJwtAuth(e){return this.httpRequest.request({method:"POST",url:"/api/v1/password/change",formData:e,mediaType:"application/x-www-form-urlencoded",errors:{422:"Unprocessable Entity"}})}proofList(){return this.httpRequest.request({method:"GET",url:"/api/v1/proof/list",errors:{500:"Internal Server Error"}})}sindriManifestSchema(){return this.httpRequest.request({method:"GET",url:"/api/v1/sindri-manifest-schema.json"})}teamMe(){return this.httpRequest.request({method:"GET",url:"/api/v1/team/me"})}userMeWithJwtAuth(){return this.httpRequest.request({method:"GET",url:"/api/v1/user/me"})}};var X=class{constructor(e){this.httpRequest=e}proofDetail(e,i=!0,n=!0,o=!1,s=!0){return this.httpRequest.request({method:"GET",url:"/api/v1/proof/{proof_id}/detail",path:{proof_id:e},query:{include_proof:i,include_public:n,include_smart_contract_calldata:o,include_verification_key:s},errors:{404:"Not Found",500:"Internal Server Error",501:"Not Implemented"}})}proofDelete(e){return this.httpRequest.request({method:"DELETE",url:"/api/v1/proof/{proof_id}/delete",path:{proof_id:e},errors:{404:"Not Found",500:"Internal Server Error"}})}};var ee=class{constructor(e){this.httpRequest=e}fd3Aaa7BControllerObtainToken(e){return this.httpRequest.request({method:"POST",url:"/api/token/pair",body:e,mediaType:"application/json"})}b87E0720ControllerRefreshToken(e){return this.httpRequest.request({method:"POST",url:"/api/token/refresh",body:e,mediaType:"application/json"})}d1C092ControllerVerifyToken(e){return this.httpRequest.request({method:"POST",url:"/api/token/verify",body:e,mediaType:"application/json"})}};var re=class{authorization;circuits;internal;proofs;token;request;constructor(e,i=ue){this.request=new i({BASE:e?.BASE??"https://sindri.app",VERSION:e?.VERSION??"1.6.14",WITH_CREDENTIALS:e?.WITH_CREDENTIALS??!1,CREDENTIALS:e?.CREDENTIALS??"include",TOKEN:e?.TOKEN,USERNAME:e?.USERNAME,PASSWORD:e?.PASSWORD,HEADERS:e?.HEADERS,ENCODE_PATH:e?.ENCODE_PATH}),this.authorization=new Y(this.request),this.circuits=new Z(this.request),this.internal=new Q(this.request),this.proofs=new X(this.request),this.token=new ee(this.request)}};var U=h(require("fs")),Ae=h(require("path")),Me=h(require("env-paths")),z=h(require("lodash")),$=require("zod"),Ve=()=>{let r=(0,Me.default)("sindri",{suffix:""});return Ae.default.join(r.config,"sindri.conf.json")},Ie=$.z.object({auth:$.z.nullable($.z.object({apiKey:$.z.string(),apiKeyId:$.z.string(),apiKeyName:$.z.string(),baseUrl:$.z.string().url(),teamId:$.z.number(),teamSlug:$.z.string()})).default(null)}),ut=Ie.parse({}),mt=r=>{let e=Ve();if(U.default.existsSync(e)){r?.debug(`Loading config from "${e}".`);try{let i=U.default.readFileSync(e,{encoding:"utf-8"}),n=Ie.parse(JSON.parse(i));return r?.debug("Config loaded successfully."),n}catch(i){r?.warn(`The config schema in "${e}" is invalid and will not be used.
To remove it and start fresh, run:
    rm ${e}`),r?.debug(i)}}return r?.debug(`Config file "${e}" does not exist, initializing default config.`),z.default.cloneDeep(ut)},D=class{_config;logger;constructor(e){this.logger=e,this.reload()}get auth(){return z.default.cloneDeep(this._config.auth)}get config(){return z.default.cloneDeep(this._config)}reload(){this._config=mt(this.logger)}update(e){this.logger?.debug("Merging in config update:"),this.logger?.debug(e);let i=z.default.cloneDeep(this._config);z.default.merge(i,e),this._config=Ie.parse(i);let n=Ve(),o=Ae.default.dirname(n);U.default.existsSync(o)||U.default.mkdirSync(o,{recursive:!0}),this.logger?.debug(`Writing merged config to "${n}":`,this._config),U.default.writeFileSync(n,JSON.stringify(this._config,null,2),{encoding:"utf-8"})}};var We=h(require("pino")),Ge=h(require("pino-pretty")),ke=r=>{let e=(0,We.default)(process.env.BROWSER_BUILD?{browser:{asObject:!0}}:(0,Ge.default)({colorize:!0,destination:2,ignore:"hostname,pid",levelFirst:!1,sync:!0}));return e.level=r??!0?"silent":"info",e},Eo=ke(),q=console.log;var de=class r{_client;_clientConfig;_config;logger;pollingInterval=1e3;constructor(e={}){this._client=new re,this._clientConfig=this._client.request.config;let i="v0.0.1-alpha.44";this._clientConfig.HEADERS={...this._clientConfig.HEADERS,"Sindri-Client":`sindri-js-sdk/${i}`},this.logger=ke(),process.env.BROWSER_BUILD||(this._config=new D(this.logger)),this._clientConfig.logger=this.logger,this.authorize(e)}get apiKey(){return this._clientConfig.TOKEN&&typeof this._clientConfig.TOKEN!="string"?null:this._clientConfig.TOKEN||null}get baseUrl(){return this._clientConfig.BASE}get logLevel(){return this.logger.level}set logLevel(e){this.logger.level=e,this.logger.debug(`Set log level to "${this.logger.level}".`)}authorize(e){return process.env.BROWSER_BUILD?(this._clientConfig.BASE=e.baseUrl||"https://sindri.app",this._clientConfig.TOKEN=e.apiKey):(this._config.reload(),this._clientConfig.BASE=e.baseUrl||process.env.SINDRI_BASE_URL||this._config.auth?.baseUrl||this._clientConfig.BASE||"https://sindri.app",this._clientConfig.TOKEN=e.apiKey||process.env.SINDRI_API_KEY||this._config.auth?.apiKey),!!(this._clientConfig.BASE&&this._clientConfig.TOKEN)}create(e){return new r(e)}async createCircuit(e,i=["latest"]){let n=new J;i=typeof i=="string"?[i]:i??[];for(let f of i){if(!/^[-a-zA-Z0-9_.]+$/.test(f))throw new Error(`"${f}" is not a valid tag. Tags may only contain alphanumeric characters, underscores, hyphens, and periods.`);n.append("tags",f)}if(i.length===0&&n.append("tags",""),typeof e=="string"){if(process.env.BROWSER_BUILD)throw new Error("Specifying `project` as a path is not allowed in the browser build.");let f;try{f=await(0,te.stat)(e)}catch{throw new Error(`The "${e}" path does not exist or you do not have permission to access it.`)}if(f.isFile()){if(!/\.(zip|tar|tar\.gz|tgz)$/i.test(e))throw new Error("Only gzipped tarballs or zip files are supported.");let l=me.default.basename(e),d=await(0,te.readFile)(e);n.append("files",new W([d],l))}else if(f.isDirectory()){let l=me.default.join(e,"sindri.json"),d;try{d=await(0,te.readFile)(l,{encoding:"utf-8"})}catch{throw new Error(`Expected Sindri manifest file at "${l}" does not exist.`)}let g;try{g=JSON.parse(d)}catch{throw new Error(`Could not parse "${l}", is it valid JSON?`)}let u=g?.name;if(!u)throw new Error(`No circuit "name" field was found in "${l}", the manifest is invalid.`);let p=Ze.default.sync({follow:!0,ignoreFiles:[".sindriignore"],path:e}).filter(b=>!/(^|\/)\.git(\/|$)/.test(b)),y=me.default.basename(l);p.includes(y)||p.push(y);let R=`${u}.tar.gz`;p.sort((b,x)=>b.localeCompare(x));let C=Qe.default.c({cwd:e,gzip:!0,onwarn:(b,x)=>{this.logger.warn(`While creating tarball: ${b} - ${x}`)},prefix:`${u}/`,sync:!0},p);n.append("files",new W([C.read()],R))}else throw new Error(`The "${e}" path is not a file or directory.`)}else if(Array.isArray(e)){if(!e.every(y=>y instanceof W))throw new Error("All entries in `project` must be `File` instances.");let f=e.find(y=>y.name==="sindri.json");if(!f)throw new Error("The `project` array must include a `sindri.json` file.");let l;try{l=JSON.parse(await f.text())}catch{throw new Error('Could not parse "sindri.json", is it valid JSON?')}let d=l?.name;if(!d)throw new Error('No circuit "name" field was found in "sindri.json", the manifest is invalid.');let g=new Xe.default;e.sort((y,R)=>y.name.localeCompare(R.name));for(let y of e){let R=new Uint8Array(await y.arrayBuffer());await new Promise(C=>g.append(`${d}/${y.name}`,R,C))}let u=new Uint8Array(Ye.default.zip(g.out)),p=new W([u],`${d}.tar.gz`);process.env.BROWSER_BUILD,n.append("files",p)}let o=this._clientConfig.HEADERS;this._clientConfig.HEADERS={...o,"Content-Type":"multipart/form-data; boundary=----WebKitFormBoundary0buQ8d6EhWcs9X9d"};let c=await this._client.circuits.circuitCreate(n);this._clientConfig.HEADERS=o;let a=c.circuit_id,m;for(;m=await this._client.circuits.circuitDetail(a,!1),!(m.status==="Ready"||m.status==="Failed");)await new Promise(f=>setTimeout(f,this.pollingInterval));return m}async getAllCircuitProofs(e){return await this._client.circuits.circuitProofs(e)}async getAllCircuits(){return await this._client.circuits.circuitList()}async getCircuit(e){return await this._client.circuits.circuitDetail(e)}async getProof(e){return await this._client.proofs.proofDetail(e)}async proveCircuit(e,i,n=!1,o=!1){let s=await this._client.circuits.proofCreate(e,{perform_verify:n,proof_input:i}),c;for(;c=await this._client.proofs.proofDetail(s.proof_id,!0,!0,o,!0),!(c.status==="Ready"||c.status==="Failed");)await new Promise(a=>setTimeout(a,this.pollingInterval));return c}};var t=new de;var ir=new tr.Command().name("clone").description("Clone a circuit into a local directory.").argument("<circuit>","The circuit to clone.").argument("[directory]","The directory to clone the circuit into.").action(async(r,e)=>{let n=/^(?:([-a-zA-Z0-9_]+)\/)?([-a-zA-Z0-9_]+)(?::([-a-zA-Z0-9_.]+))?$/.exec(r);if(!n)return t.logger.error(`"${r}" is not a valid circuit identifier.`),F.default.exit(1);(0,er.default)(n[2],"The circuit name must be provided.");let o=n[2],s=rr.default.resolve(e??o);if(Oe.default.existsSync(s))return t.logger.error(`The directory "${s}" already exists. Aborting.`),F.default.exit(1);if(!t.apiKey||!t.baseUrl)return t.logger.warn("You must login first with `sindri login`."),F.default.exit(1);let c;t.logger.info(`Cloning the circuit "${r}" into "${s}".`);try{c=await t._client.internal.circuitDownload(r)}catch(a){return a instanceof T&&a.status===401?(t.logger.error("Your credentials are invalid. Please log in again with `sindri login`."),F.default.exit(1)):a instanceof T&&a.status===404?(t.logger.error(`The circuit "${r}" does not exist or you lack permission to access it.`),F.default.exit(1)):(t.logger.fatal("An unknown error occurred."),t.logger.error(a),F.default.exit(1))}try{Oe.default.mkdirSync(s,{recursive:!0})}catch(a){return t.logger.fatal(`Failed to create the directory "${s}". Aborting.`),t.logger.error(a),F.default.exit(1)}await new Promise((a,m)=>{c.on("end",a),c.on("error",m),c.pipe(or.default.x({cwd:s,noChmod:!0,noMtime:!0,onwarn:(f,l)=>{t.logger.warn(`While extracting tarball: ${f} - ${l}`)},preserveOwner:!1,preservePaths:!1,strip:1}))}),t.logger.info("Circuit cloned successfully.")});var $e=require("@commander-js/extra-typings");var dt=new $e.Command().name("list").description("Show the current config.").action(async()=>{t._config.reload(),q(t._config.config)}),nr=new $e.Command().name("config").description("Commands related to configuration and config files.").addCommand(dt);var yr=h(require("assert")),ye=h(require("path")),_=h(require("process")),we=require("@commander-js/extra-typings");var sr=h(require("assert")),Ne=require("child_process"),fe=require("fs"),ar=h(require("fs")),A=require("fs/promises"),cr=h(require("os")),E=h(require("path")),v=h(require("process")),lr=require("stream"),pr=require("url"),ur=h(require("axios")),mr=require("compare-versions"),ge=h(require("dockerode")),dr=h(require("nunjucks")),ft=(0,pr.fileURLToPath)(w),gt=E.default.dirname(ft);function ht(r){return new Promise(e=>{let i=(0,Ne.spawn)(r,["--version"]);i.on("error",()=>{e(!1)}),i.on("exit",n=>{e(n!==127&&n!==null)})})}async function De(r){let e=new ge.default;try{await e.ping()}catch(i){return r?.debug("Failed to connect to the Docker daemon."),r?.debug(i),!1}return r?.debug("Docker daemon is accessible."),!0}var yt=new lr.Writable({write(r,e,i){i()}});async function fr(r,e=[],{cwd:i=v.default.cwd(),docker:n=new ge.default,logger:o,rootDirectory:s,tag:c="auto",tty:a=!1}){if(wt(v.default.env.SINDRI_FORCE_DOCKER??"false"))o?.debug(`Forcing docker usage for command "${r}" because "SINDRI_FORCE_DOCKER" is set to "${v.default.env.SINDRI_FORCE_DOCKER}".`);else{if(await ht(r))return o?.debug(`Executing the "${r}" command locally.`),{code:await bt(r,e,{cwd:i,logger:o,tty:a}),method:"local"};o?.debug(`The "${r}" command was not found locally, trying Docker instead.`)}return await De(o)?(o?.debug(`Executing the "${r}" command in a Docker container.`),{code:await he(r,e,{cwd:i,docker:n,logger:o,rootDirectory:s,tag:c,tty:a}),method:"docker"}):(o?.debug(`The "${r}" command is not available locally or in Docker.`),{code:null,method:null})}async function he(r,e=[],{cwd:i=v.default.cwd(),docker:n=new ge.default,logger:o,rootDirectory:s,tag:c="auto",tty:a=!1}){let m=k(/^sindri.json$/i,i);s||(m?s=E.default.dirname(m):(s=i,o?.warn(`No "sindri.json" file was found in or above "${i}", using the current directory as the project root.`))),s=E.default.normalize(E.default.resolve(s));let f;if(r==="nargo"&&c==="auto"){let p="latest";if(m)try{let y=await(0,A.readFile)(m,{encoding:"utf-8"}),R=JSON.parse(y);R.noirVersion&&(p=R.noirVersion,p&&!p.startsWith("v")&&(p=`v${p}`))}catch(y){o?.error(`Failed to parse the "${m}" file, using the "latest" tag for the "nargo" command.`),o?.debug(y)}else o?.warn(`No "sindri.json" file was found in or above "${i}", using the "latest" tag for the "nargo" command.`);f=`sindrilabs/${r}:${p}`}else if(["circomspect","nargo"].includes(r))f=`sindrilabs/${r}:${c==="auto"?"latest":c}`;else throw new Error(`The command "${r}" is not supported.`);o?.debug(`Pulling the "${f}" image.`);try{await new Promise((p,y)=>{n.pull(f,(R,C)=>{R?y(R):n.modem.followProgress(C,(b,x)=>b?y(b):p(x))})})}catch(p){return o?.error(`Failed to pull the "${f}" image.`),o?.error(p),v.default.exit(1)}let l=s;if(v.default.env.SINDRI_DEVELOPMENT_HOST_ROOT)if(s==="/sindri"||s.startsWith("/sindri/"))l=s.replace("/sindri",v.default.env.SINDRI_DEVELOPMENT_HOST_ROOT),o?.debug(`Remapped "${s}" to "${l}" for bind mount on the Docker host.`);else return o?.fatal(`The root directory path "${s}" must be under "/sindri/"when using "SINDRI_DEVELOPMENT_HOST_ROOT".`),v.default.exit(1);let d=E.default.relative(s,i),g;return d.startsWith("..")?(g="/sindri/",o?.warn(`The current working directory ("${i}") is not under the project root ("${s}"), will use the project root as the current working directory.`)):g=E.default.join("/sindri/",d),o?.debug(`Remapped the "${i}" working directory to "${g}" in the Docker container.`),(await new Promise((p,y)=>{n.run(f,e,a?[v.default.stdout,v.default.stderr]:yt,{AttachStderr:a,AttachStdin:a,AttachStdout:a,HostConfig:{Binds:[`${l}:/sindri`,"/tmp/sindri/:/tmp/sindri/"]},OpenStdin:a,StdinOnce:!1,Tty:a,WorkingDir:g},(R,C)=>{R?y(R):p(C)}).on("container",R=>{if(!a)return;let C=R.attach({stream:!0,stdin:!0,stdout:!0,stderr:!0},function(b,x){b&&y(b),x.pipe(v.default.stdout)});C&&C.resume()})})).StatusCode}async function bt(r,e=[],{cwd:i=v.default.cwd(),logger:n,tty:o=!1}){let s=(0,Ne.spawn)(r,e,{cwd:i,stdio:o?"inherit":"ignore"});try{return await new Promise((a,m)=>{s.on("error",f=>{m(f)}),s.on("close",(f,l)=>{f==null&&l!=null&&(f=128+cr.default.constants.signals[l]),(0,sr.default)(f!=null),a(f)})})}catch(c){return n?.error(`Failed to execute the "${r}" command.`),n?.error(c),v.default.exit(1)}}async function _e(r){try{return await ar.default.promises.stat(r),!0}catch{return!1}}function k(r,e=gt){let i=(0,fe.readdirSync)(e);for(let o of i)if(typeof r=="string"?o===r:r.test(o))return E.default.join(e,o);let n=E.default.dirname(e);return n===e?null:k(r,n)}async function gr(r,e="sindrilabs"){let i=`https://hub.docker.com/v2/repositories/${e}/${r}/tags/?page_size=1`,n=[];for(;i;){let o=await ur.default.get(i);n=n.concat(o.data.results),i=o.data.next}return n.filter(({tag_status:o})=>o==="active").filter(({name:o})=>o!=="dev").sort((o,s)=>o.last_updated.localeCompare(s.last_updated)).map(({name:o})=>o).sort((o,s)=>o==="latest"?1:s==="latest"?-1:(0,mr.compareVersions)(o,s))}function wt(r){return["1","true","t","yes","y","on"].includes(r.toLowerCase())}function hr(){let r=k("sindri-manifest.json");if(!r)throw new Error("A `sindri-manifest.json` file was unexpectedly not found.");let e=(0,fe.readFileSync)(r,{encoding:"utf-8"});return JSON.parse(e)}async function qe(r,e,i,n){let o=E.default.resolve(e);await _e(o)||await(0,A.mkdir)(o,{recursive:!0});let s=k("templates");if(!s)throw new Error("Root template directory not found.");let c=E.default.isAbsolute(r)?r:E.default.resolve(s,r);if(!await _e(c))throw new Error(`The "${c}" directory does not exist.`);let a=(f,l)=>{let d=f;return Object.entries(l).forEach(([g,u])=>{typeof u=="string"&&(d=d.replace(new RegExp(`template${g.toUpperCase()}`,"gi"),u))}),dr.default.renderString(d,l)},m=async(f,l)=>{if((await(0,A.stat)(f)).isDirectory()){if(await _e(l)||(await(0,A.mkdir)(l,{recursive:!0}),n?.debug(`Created directory: "${l}"`)),!(await(0,A.stat)(l)).isDirectory())throw new Error(`"File ${l} exists and is not a directory.`);let u=await(0,A.readdir)(f);await Promise.all(u.map(async p=>{let y=a(p,i);await m(E.default.join(f,p),E.default.join(l,y))}));return}let d=await(0,A.readFile)(f,{encoding:"utf-8"}),g=a(d,i);await(0,A.writeFile)(l,g,{encoding:"utf-8"}),n?.debug(`Rendered "${f}" template to "${l}".`)};await m(c,o)}var be,K,Fe,Rt=new we.Command().name("circomspect").description("Trail of Bit's Circomspect static analysis tool for Circom circuits.").helpOption(!1).addHelpCommand(!1).allowUnknownOption().passThroughOptions().argument("[args...]","Arguments to pass to the tool.").action(async r=>{if(!be)try{let e=await he("circomspect",r,{logger:t.logger,rootDirectory:K,tag:Fe,tty:!0});_.default.exit(e)}catch(e){return t.logger.error("Failed to run the circomspect command."),t.logger.debug(e),_.default.exit(1)}}),Ct=new we.Command().name("nargo").description("Aztec Lab's Noir compiler and package manager.").helpOption(!1).addHelpCommand(!1).allowUnknownOption().passThroughOptions().argument("[args...]","Arguments to pass to the tool.").action(async r=>{if(!be)try{let e=await he("nargo",r,{logger:t.logger,rootDirectory:K,tag:Fe,tty:!0});_.default.exit(e)}catch(e){return t.logger.error("Failed to run the nargo command."),t.logger.debug(e),_.default.exit(1)}}),br=new we.Command().name("exec").alias("x").description("Run a ZKP tool in your project root inside of an optimized docker container.").passThroughOptions().option("-l, --list-tags","List the available docker image tags for a given tool.").option("-t, --tag <tag>","The version tag of the docker image to use.","auto").addCommand(Rt).addCommand(Ct).hook("preAction",async r=>{let e=r.opts();if(be=!!e.listTags,Fe=e.tag,be){let o=r.args[0];(0,yr.default)(o,"The preAction hook should only run if there's a subcommand.");try{(await gr(o)).forEach(c=>q(c))}catch(s){return t.logger.fatal("Error listing available docker image tags."),t.logger.error(s),_.default.exit(1)}return _.default.exit(0)}let i=_.default.cwd(),n=k(/^sindri.json$/i,i);n?K=ye.default.dirname(n):(K=i,t.logger.warn(`No "sindri.json" file was found in or above "${i}", using the current directory as the project root.`)),K=ye.default.normalize(ye.default.resolve(K)),await De(t.logger)||(t.logger.fatal(`Docker is either not installed or the daemon isn't currently running, but it is required by "sindri exec".
Please install Docker by following the instructions at: https://docs.docker.com/get-docker/`),_.default.exit(1))});var j=require("child_process"),O=require("fs"),oe=h(require("path")),Re=h(require("process")),wr=require("@commander-js/extra-typings"),S=require("@inquirer/prompts");var Rr=new wr.Command().name("init").description("Initialize a new Sindri project.").argument("[directory]","The directory where the new project should be initialized.",".").action(async r=>{let e=oe.default.resolve(r),i=oe.default.basename(e);if(!(0,O.existsSync)(e))(0,O.mkdirSync)(e,{recursive:!0});else if(!(0,O.statSync)(e).isDirectory())return t.logger.warn(`File "${e}" exists and is not a directory, aborting.`),Re.default.exit(1);if((0,O.readdirSync)(e).length>0&&!await(0,S.confirm)({message:`The "${e}" directory already exists and contains files. Continuing will overwrite your existing files. Are you *SURE* you would like to proceed?`,default:!1}))return t.logger.info("Aborting."),Re.default.exit(1);let o=await(0,S.input)({message:"Circuit Name:",default:i.replace(/[^-a-zA-Z0-9_]/g,"-"),validate:l=>l.length===0?"You must specify a circuit name.":/^[-a-zA-Z0-9_]+$/.test(l)?!0:"Only alphanumeric characters, hyphens, and underscores are allowed."}),s=await(0,S.select)({message:"Proving Framework:",default:"circom",choices:[{name:"Circom",value:"circom"},{name:"Gnark",value:"gnark"},{name:"Halo2",value:"halo2"},{name:"Noir",value:"noir"}]}),c={circuitName:o,circuitType:s};if(s==="circom"){let l=await(0,S.select)({message:"Proving Scheme:",default:"groth16",choices:[{name:"Groth16",value:"groth16"}]}),d=await(0,S.select)({message:"Curve Name:",default:"bn254",choices:[{name:"BN254",value:"bn254"}]}),g=await(0,S.select)({message:"Witness Compiler:",default:"c++",choices:[{name:"C++",value:"c++"},{name:"Wasm",value:"wasm"}]});Object.assign(c,{curveName:d,provingScheme:l,witnessCompiler:g})}else if(s==="gnark"){let l=await(0,S.input)({message:"Go Package Name:",default:o.replace(/[^a-zA-Z0-9]/g,"").replace(/^[^a-z]*/g,""),validate:p=>p.length===0?"You must specify a package name.":/^[a-z][a-z0-9]*$/.test(p)?!0:"Package names must begin with a lowercase letter and only be followed by alphanumeric characters."}),d=await(0,S.select)({message:"Proving Scheme:",default:"groth16",choices:[{name:"Groth16",value:"groth16"}]}),g=await(0,S.select)({message:"Curve Name:",default:"bn254",choices:[{name:"BN254",value:"bn254"},{name:"BLS12-377",value:"bls12-377"},{name:"BLS12-381",value:"bls12-381"},{name:"BLS24-315",value:"bls24-315"},{name:"BW6-633",value:"bw6-633"},{name:"BW6-761",value:"bw6-761"}]}),u=g.toUpperCase().replace("-","_");Object.assign(c,{curveName:g,gnarkCurveName:u,packageName:l,provingScheme:d})}else if(s==="halo2"){let l=await(0,S.input)({message:"Halo2 Package Name:",default:o.toLowerCase().replace(/^[^a-z0-9_]+/,"_").replace(/_+/g,"_").replace(/-+/g,"-"),validate:y=>y.length===0?"You must specify a package name.":/^[a-z0-9_]+(?:-[a-z0-9_]+)*$/.test(y)?!0:"Package names must begin with a lowercase letter, number, or underscore, and only be followed by lowercase or numeric characters and underscores (optionally separated hyphens)."}),d=await(0,S.select)({message:"Halo2 Base Version:",default:"axiom-v0.3.0",choices:[{name:"Axiom v0.3.0",value:"axiom-v0.3.0"}]}),g=d!=="axiom-v0.3.0"?void 0:await(0,S.select)({message:"Halo2 Base Version:",default:"GateThreadBuilder",choices:[{name:"Gate Thread Builder",value:"GateThreadBuilder"}]}),u=parseInt(await(0,S.input)({message:"Degree:",default:"13",validate:y=>y.length===0?"You must specify a degree.":/^[1-9]\d*$/.test(y)?!0:"Degree must be a positive integer."}),10),p=`${l.replace(/-/g,"_")}::circuit_def::CircuitInput`;Object.assign(c,{className:p,halo2Version:d,degree:u,packageName:l,threadBuilder:g})}else if(s==="noir"){let l=await(0,S.input)({message:"Noir Package Name:",default:o.toLowerCase().replace(/[- ]/g,"_").replace(/[^a-zA-Z0-9_]+/,"").replace(/_+/g,"_"),validate:u=>u.length===0?"You must specify a package name.":/^[a-zA-Z0-9_]+$/.test(u)?!0:"Package names must only contain alphanumeric characters and underscores."}),d=await(0,S.select)({message:"Noir Version:",default:"0.23.0",choices:[{name:"0.17.0",value:"0.17.0"},{name:"0.18.0",value:"0.18.0"},{name:"0.19.4",value:"0.19.4"},{name:"0.22.0",value:"0.22.0"},{name:"0.23.0",value:"0.23.0"}]}),g=await(0,S.select)({message:"Proving Scheme:",default:"barretenberg",choices:[{name:"Barretenberg",value:"barretenberg"}]});Object.assign(c,{packageName:l,noirVersion:d,provingScheme:g})}else return t.logger.fatal(`Sorry, ${s} is not yet supported.`),Re.default.exit(1);t.logger.info(`Proceeding to generate scaffolded project in "${e}".`),await qe("common",e,c,t.logger),await qe(s,e,c,t.logger);let a=oe.default.join(e,".gitkeep");if((0,O.existsSync)(a)&&(0,O.rmSync)(a),t.logger.info("Project scaffolding successful."),s==="circom"){let l=!1;try{(0,j.execSync)("npm --version"),l=!0}catch{t.logger.warn("NPM is not installed, cannot install circomlib as a dependency. You will need to install NPM and run `npm install` yourself.")}l&&(t.logger.info("Installing circomlib."),(0,j.execSync)("npm install",{cwd:e}))}let m=!1;try{(0,j.execSync)("git --version"),m=!0}catch{t.logger.debug("Git is not installed, skipping git initialization questions.")}let f=(0,O.existsSync)(oe.default.join(e,".git"));if(m&&!f&&await(0,S.confirm)({message:`Would you like to initialize a git repository in "${e}"?`,default:!0})){t.logger.info(`Initializing git repository in "${e}".`);try{(0,j.execSync)("git init .",{cwd:e}),(0,j.execSync)("git add .",{cwd:e}),(0,j.execSync)("git commit -m 'Initial commit.'",{cwd:e}),t.logger.info("Successfully initialized git repository.")}catch(d){t.logger.error("Error occurred while initializing the git repository.");let g=d;["output","stderr","stdout"].forEach(p=>{p in g&&(g[p]="<truncated>")}),t.logger.error(g)}}});var Cr=require("buffer"),Se=require("fs"),Ce=h(require("path")),I=h(require("process")),Sr=require("@commander-js/extra-typings"),xr=require("formdata-node"),Tr=h(require("ignore-walk")),vr=h(require("tar"));var Er=new Sr.Command().name("deploy").description("Deploy the current Sindri project.").option("-t, --tag <tag...>","Tag to apply to the circuit.",["latest"]).option("-u, --untagged","Discard the current circuit after compiling.").argument("[directory]","The location of the Sindri project to deploy.",".").action(async(r,{tag:e,untagged:i})=>{if(i){if(e.length!==1||e[0]!=="latest")return t.logger.error("You cannot use both the `--tag` and `--untagged` options together."),I.default.exit(1)}else for(let p of e)if(!/^[-a-zA-Z0-9_.]+$/.test(p))return t.logger.error(`"${p}" is not a valid tag. Tags may only contain alphanumeric characters, underscores, hyphens, and periods.`),I.default.exit(1);let n=Ce.default.resolve(r);if(!(0,Se.existsSync)(n))return t.logger.error(`The "${n}" directory does not exist. Aborting.`),I.default.exit(1);let o=k(/^sindri.json$/i,n);if(!o)return t.logger.error(`No "sindri.json" file was found in or above "${n}". Aborting.`),I.default.exit(1);t.logger.debug(`Found "sindri.json" at "${o}".`);let s=Ce.default.dirname(o);t.logger.debug(`Changing current directory to "${s}".`),I.default.chdir(s);let c={};try{let p=(0,Se.readFileSync)(o,{encoding:"utf-8"});c=JSON.parse(p),t.logger.debug(`Successfully loaded "sindri.json" from "${o}":`),t.logger.debug(c)}catch(p){return t.logger.fatal(`Error loading "${o}", perhaps it is not valid JSON?`),t.logger.error(p),I.default.exit(1)}if(!("name"in c))return t.logger.error('No "name" field found in "sindri.json". Aborting.'),I.default.exit(1);let a=c.name;if(!t.apiKey||!t.baseUrl)return t.logger.warn("You must login first with `sindri login`."),I.default.exit(1);let m=Tr.default.sync({follow:!0,ignoreFiles:[".sindriignore"],path:"."}).filter(p=>!/(^|\/)\.git(\/|$)/.test(p)),f=Ce.default.basename(o);m.includes(f)||m.push(f);let l=new xr.FormData,d=`${a}.tar.gz`;if(t.logger.info(`Creating "${d}" package with ${m.length} files.`),l.append("files",new Cr.Blob([vr.default.c({gzip:!0,onwarn:(p,y)=>{t.logger.warn(`While creating tarball: ${p} - ${y}`)},prefix:`${a}/`,sync:!0},m).read()]),d),i)l.append("tags","");else for(let p of e)l.append("tags",p);let g;try{t.logger.info("Circuit compilation initiated."),g=(await t._client.circuits.circuitCreate(l)).circuit_id}catch(p){if(p instanceof T&&p.status===401)t.logger.error("Your credentials are invalid. Please log in again with `sindri login`.");else return t.logger.fatal("An unknown error occurred."),t.logger.error(p),I.default.exit(1)}if(!g)return t.logger.error("No circuit ID was returned from the API. Aborting."),I.default.exit(1);let u=Date.now();for(;;){try{t.logger.debug("Polling for circuit compilation status.");let p=await t._client.circuits.circuitDetail(g,!1),y=((Date.now()-u)/1e3).toFixed(1);if(p.status==="Ready"){t.logger.info(`Circuit compiled successfully after ${y} seconds.`);break}else{if(p.status==="Failed")return t.logger.error(`Circuit compilation failed after ${y} seconds: `+(p.error??"Unknown error.")),I.default.exit(1);p.status==="Queued"?t.logger.debug("Circuit compilation is queued."):p.status==="In Progress"&&t.logger.debug("Circuit compilation is in progress.")}}catch(p){return t.logger.fatal("An unknown error occurred while polling for compilation to finish."),t.logger.error(p),I.default.exit(1)}await new Promise(p=>setTimeout(p,1e3))}});var Pr=h(require("assert")),Ar=require("crypto"),B=require("fs"),M=h(require("path")),L=h(require("process")),Ir=require("@commander-js/extra-typings"),kr=require("jsonschema");var Or=new Ir.Command().name("lint").description("Lint the current Sindri project for potential issues.").argument("[directory]","The directory, or subdirectory, of the project to lint.",".").action(async r=>{let e=0,i=0,n;try{if(n=hr(),!n)throw new Error('No "sindri-manifest.json" file found.');t.logger.debug('Successfully loaded "sindri-manifest.json".')}catch{return t.logger.error('No "sindri-manifest.json" JSON Schema file found. Aborting.'),L.default.exit(1)}let o=M.default.resolve(r);if(!(0,B.existsSync)(o))return t.logger.error(`The "${o}" directory does not exist. Aborting.`),L.default.exit(1);let s=k(/^sindri.json$/i,o);if(!s)return t.logger.error(`No "sindri.json" file was found in or above "${o}". Aborting.`),L.default.exit(1);t.logger.debug(`Found "sindri.json" at "${s}".`);let c=M.default.dirname(s);t.logger.debug(`Changing current directory to "${c}".`),L.default.chdir(o);let a={};try{let u=(0,B.readFileSync)(s,{encoding:"utf-8"});a=JSON.parse(u),t.logger.debug(`Successfully loaded "sindri.json" from "${s}":`),t.logger.debug(a)}catch(u){return t.logger.fatal(`Error loading "${s}", perhaps it is not valid JSON?`),t.logger.error(u),L.default.exit(1)}(0,Pr.default)(Array.isArray(n.anyOf));let m;!("circuitType"in a)||!a.circuitType?m=void 0:a.circuitType==="circom"?m=n.anyOf.find(u=>/circom/i.test(u.$ref??"")):a.circuitType==="gnark"?m=n.anyOf.find(u=>/gnark/i.test(u.$ref??"")):a.circuitType==="halo2"?"halo2Version"in a&&a.halo2Version==="axiom-v0.2.2"?m=n.anyOf.find(u=>/halo2axiomv022/i.test(u.$ref??"")):"halo2Version"in a&&a.halo2Version==="axiom-v0.3.0"?m=n.anyOf.find(u=>/halo2axiomv030/i.test(u.$ref??"")):m={anyOf:n.anyOf.filter(u=>/halo2/i.test(u.$ref??""))}:a.circuitType==="noir"&&(m=n.anyOf.find(u=>/noir/i.test(u.$ref??""))),m?(delete n.anyOf,n={...n,...m}):(t.logger.warn(`Circuit type is not configured in "${s}" so some linting steps will be skipped and the manifest linting output will be very noisy. Please correct "circuiType" in "sindri.json" and rerun "sindri lint" to get better linting.`),i+=1);let f="circuitType"in a&&typeof a.circuitType=="string"&&["circom","gnark","halo2","noir"].includes(a.circuitType)?a.circuitType:null;f?t.logger.debug(`Detected circuit type "${f}".`):t.logger.debug("No circuit type detected!");let d=new kr.Validator().validate(a,n,{nestedErrors:!0});if(d.valid)t.logger.info(`Sindri manifest file "${s}" is valid.`);else{t.logger.warn(`Sindri manifest file "${s}" contains errors:`);for(let u of d.errors){let p=u.property.replace(/^instance/,"sindri.json").replace(/\./g,":")+(typeof u.schema=="object"&&u.schema.title?`:${u.schema.title}`:"");t.logger.error(`${p} ${u.message}`),e+=1}}let g=M.default.join(c,"README.md");if((0,B.existsSync)(g)?t.logger.debug(`README file found at "${g}".`):(t.logger.warn(`No project README was found at "${g}", consider adding one.`),i+=1),f==="circom")try{t.logger.info("Running static analysis with Circomspect by Trail of Bits...");let u=M.default.join("/","tmp","sindri",`circomspect-${(0,Ar.randomUUID)()}.sarif`),p,y;try{let R="circuitPath"in a&&a.circuitPath?a.circuitPath:"circuit.circom",{method:C}=await fr("circomspect",["--level","INFO","--sarif-file",u,R],{cwd:c,logger:t.logger,rootDirectory:c,tty:!1});if(y=C==="docker",C!==null){t.logger.debug("Parsing Circomspect SARIF results.");let b=(0,B.readFileSync)(u,{encoding:"utf-8"});p=JSON.parse(b)}else t.logger.warn(`Circomspect is not installed, skipping circomspect static analysis.
Please install Docker by following the directions at: https://docs.docker.com/get-docker/
Or install Circomspect by following the directions at: https://github.com/trailofbits/circomspect#installing-circomspect`),i+=1}catch(R){t.logger.fatal(`Error running Circomspect in "${c}".`),t.logger.error(R),e+=1}finally{try{(0,B.unlinkSync)(u)}catch{t.logger.debug(`Failed to delete temporary SARIF file "${u}".`)}}if(p){let R=p.runs[0]?.results??[];R.sort((b,x)=>{if(!b?.locations?.length||!x?.locations?.length||!b.locations[0]?.physicalLocation?.artifactLocation?.uri||!x.locations[0]?.physicalLocation?.artifactLocation?.uri||b.locations[0]?.physicalLocation?.region?.startLine==null||x.locations[0]?.physicalLocation?.region?.startLine==null||b.locations[0]?.physicalLocation?.region?.startColumn==null||x.locations[0]?.physicalLocation?.region?.startColumn==null)return 0;let ie=b.locations[0].physicalLocation.artifactLocation.uri.localeCompare(x.locations[0].physicalLocation.artifactLocation.uri);if(ie!==0)return ie;let ne=b.locations[0].physicalLocation.region.startLine-x.locations[0].physicalLocation.region.startLine;return ne!==0?ne:b.locations[0].physicalLocation.region.startColumn-x.locations[0].physicalLocation.region.startColumn});let C=!1;R.forEach(b=>{if(!b?.locations?.length||!b.locations[0]?.physicalLocation?.artifactLocation?.uri||b.locations[0]?.physicalLocation?.region?.startLine==null||b.locations[0]?.physicalLocation?.region?.startColumn==null||!b?.message?.text){t.logger.warn("Circomspect result is missing required fields, skipping."),t.logger.debug(b,"Missing Circomspect result fields:");return}let x=M.default.relative(y?"/sindri/":c,b.locations[0].physicalLocation.artifactLocation.uri.replace(/^file:\/\//,"")),{startColumn:ie,startLine:ne}=b.locations[0].physicalLocation.region,se=`${x}:${ne}:${ie} ${b.message.text} [Circomspect: ${b.ruleId}]`;b.level==="error"?(t.logger.error(se),C=!0,e+=1):b.level==="warning"?(t.logger.warn(se),C=!0,i+=1):t.logger.debug(se)}),C||t.logger.info("No issues found with Circomspect, good job!")}}catch(u){return t.logger.fatal("Error running Circomspect, aborting."),t.logger.debug(u),L.default.exit(1)}if(e===0&&i===0)t.logger.info("No issues found, good job!");else if(t.logger.warn(`Found ${e+i} problems (${e} errors, ${i} warnings).`),e>0)return t.logger.error(`Linting failed with ${e} errors.`),L.default.exit(1)});var $r=h(require("os")),Le=h(require("process")),_r=require("@commander-js/extra-typings"),N=require("@inquirer/prompts");var Nr=new _r.Command().name("login").description("Authorize the client.").option("-u, --base-url <URL>","The base URL for the Sindri API. Mainly useful for development.","https://sindri.app").action(async({baseUrl:r})=>{let e=new D;if(!e.auth){let c;try{c=await t._client.internal.teamMe()}catch(a){if(a instanceof T&&a.status===401)t.logger.warn("Existing credentials found, but invalid. Please continue logging in to update them.");else return t.logger.fatal("An unknown error occurred."),t.logger.error(a),Le.default.exit(1)}if(c&&!await(0,N.confirm)({message:`You are already logged in as ${c.team.slug} on ${t.baseUrl}, are you sure you want to proceed?`,default:!1})){t.logger.info("Aborting.");return}}let n=await(0,N.input)({message:"Username:"}),o=await(0,N.password)({mask:!0,message:"Password:"}),s=await(0,N.input)({default:`${$r.default.hostname()}-sdk`,message:"New API Key Name:"});try{t._clientConfig.BASE=r;let c=await t._client.token.fd3Aaa7BControllerObtainToken({username:n,password:o});t._clientConfig.TOKEN=c.access;let a=await t._client.internal.userMeWithJwtAuth(),m=await(0,N.select)({message:"Select a Organization:",choices:a.teams.map(({id:p,slug:y})=>({name:y,value:p}))}),f=a.teams.find(p=>p.id===m);if(!f)throw new Error("No organization selected.");t._clientConfig.HEADERS={...t._clientConfig.HEADERS,"Sindri-Team-Id":`${m}`};let l=await t._client.authorization.apikeyGenerate({username:n,password:o,name:s}),d=l.api_key,g=l.id,u=l.name;if(!d||!g||!u)throw new Error("Error generating API key.");e.update({auth:{apiKey:d,apiKeyId:g,apiKeyName:u,baseUrl:r,teamId:m,teamSlug:f.slug}}),t.logger.info("You have successfully authorized the client with your Sindri account.")}catch(c){t.logger.fatal("An irrecoverable error occurred."),t.logger.error(c),Le.default.exit(1)}});var Dr=require("@commander-js/extra-typings"),qr=require("@inquirer/prompts");var Fr=new Dr.Command().name("logout").description("Remove the current client authorization credentials.").action(async()=>{let r=new D,e=r.auth;if(!e){t.logger.error("You must log in first with `sindri login`.");return}if(await(0,qr.confirm)({message:`Would you like to also revoke the "${e.apiKeyName}" API key? (recommended)`,default:!0}))try{await t._client.authorization.apikeyDelete(e.apiKeyId),t.logger.info(`Successfully revoked "${e.apiKeyName}" key.`)}catch(n){t.logger.warn(`Error revoking "${e.apiKeyName}" key, proceeding to clear credentials anyway.`),t.logger.error(n)}else t.logger.warn("Skipping revocation of existing key.");r.update({auth:null}),t.logger.info("You have successfully logged out.")});var H=h(require("fs")),xe=h(require("path")),P=h(require("process")),Be=require("@commander-js/extra-typings");var St=async()=>{let r="";return new Promise(e=>{P.default.stdin.on("data",i=>r+=i),P.default.stdin.on("end",()=>e(r))})},xt=new Be.Command().name("create").description("Create a proof for the circuit.").option("-i, --input <input>","Input file for the proof (defaults to stdin if non-TTY; `input.json`, `example-input.json`, or `Prover.toml` otherwise).").option("-t, --tag <tag>","Tag to generate the proof from.","latest").option("-v, --verify","Perform verification of the proof after creating it.").action(async({input:r,tag:e,verify:i})=>{if(!t.apiKey||!t.baseUrl)return t.logger.warn("You must login first with `sindri login`."),P.default.exit(1);let n=xe.default.resolve(".");if(!H.default.existsSync(n))return t.logger.error(`The "${n}" directory does not exist. Aborting.`),P.default.exit(1);let o=k(/^sindri.json$/i,n);if(!o)return t.logger.error(`No "sindri.json" file was found in or above "${n}". Aborting.`),P.default.exit(1);t.logger.debug(`Found "sindri.json" at "${o}".`);let s=xe.default.dirname(o);t.logger.debug(`Changing current directory to "${s}".`),P.default.chdir(s);let c={};try{let d=H.default.readFileSync(o,{encoding:"utf-8"});c=JSON.parse(d),t.logger.debug(`Successfully loaded "sindri.json" from "${o}":`),t.logger.debug(c)}catch(d){return t.logger.fatal(`Error loading "${o}", perhaps it is not valid JSON?`),t.logger.error(d),P.default.exit(1)}if(!("name"in c))return t.logger.error('No "name" field found in "sindri.json". Aborting.'),P.default.exit(1);let a=c.name,m;if(r&&H.default.existsSync(r)?m=H.default.readFileSync(r,"utf-8"):(!P.default.stdin.isTTY||r==="-")&&(m=await St()),!m||!m.trim()){let d=["input.json","example-input.json","Prover.toml"];for(let g of d){let u=xe.default.join(s,g);if(H.default.existsSync(g)){m=H.default.readFileSync(u,"utf-8");break}}m||(console.error("No input file specified, none of the default files found, and not in a non-TTY context."),P.default.exit(1))}let f="circuitType"in c&&typeof c.circuitType=="string"&&["circom"].includes(c.circuitType),l=`${a}:${e}`;try{let d=Date.now(),g=await t.proveCircuit(l,m,!!i,f),u=((Date.now()-d)/1e3).toFixed(1);if(g.status==="Ready")t.logger.info(`Proof generated successfully after ${u} seconds.`);else return g.status==="Failed"?(t.logger.error(`Proof generation failed after ${u} seconds: `+(g.error??"Unknown error.")),P.default.exit(1)):(t.logger.fatal(`Unexpected response status: ${g.status}`),P.default.exit(1));q(JSON.stringify({proofId:g.proof_id,proof:g.proof,public:g.public,verification_key:g.verification_key},null,2))}catch(d){return d instanceof T&&d.status===404?t.logger.error(`No circuit found with the name "${a}" and tag "${e}".`):(t.logger.fatal("An unknown error occurred."),t.logger.error(d)),P.default.exit(1)}}),Lr=new Be.Command().name("proof").description("Commands related to proofs for the current circuit.").addCommand(xt);var je=h(require("process")),Br=require("@commander-js/extra-typings");var jr=new Br.Command().name("whoami").description("Display the currently authorized organization name.").action(async()=>{if(!t.apiKey||!t.baseUrl)return t.logger.warn("You must login first with `sindri login`."),je.default.exit(1);try{let r=await t._client.internal.teamMe();q(r.team.slug)}catch(r){if(r instanceof T&&r.status===401)t.logger.error("Your credentials are invalid. Please log in again with `sindri login`.");else return t.logger.fatal("An unknown error occurred."),t.logger.error(r),je.default.exit(1)}});var Hr="0.0.1-alpha.44",Jr=Hr?`v${Hr}`:"unknown",Ur=new zr.Command().name("sindri").description("The Sindri CLI client.").version(Jr).enablePositionalOptions().option("-d, --debug","Enable debug logging.",!1).option("-q, --quiet","Disable all logging aside from direct command outputs for programmatic consumption.",!1).addCommand(ir).addCommand(nr).addCommand(br).addCommand(Rr).addCommand(Er).addCommand(Or).addCommand(Nr).addCommand(Fr).addCommand(Lr).addCommand(jr).hook("preAction",async r=>{let{debug:e,quiet:i}=r.opts();if(e&&i)return t.logLevel="error",t.logger.error("You cannot specify both the `--debug` and `--quiet` arguments."),(0,Te.exit)(1);e?t.logLevel="trace":i?t.logLevel="silent":t.logLevel="info",t._clientConfig.HEADERS={...t._clientConfig.HEADERS,"Sindri-Client":`sindri-js-cli/${Jr}`}});require.main===module&&Ur.parse(Te.argv);0&&(module.exports={program});
//# sourceMappingURL=index.js.map