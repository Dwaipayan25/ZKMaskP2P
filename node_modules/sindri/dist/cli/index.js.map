{"version":3,"sources":["../../src/cli/index.ts","../../node_modules/tsup/assets/cjs_shims.js","../../src/cli/clone.ts","../../src/lib/client.ts","../../src/lib/api/core/BaseHttpRequest.ts","../../src/lib/api/core/request.ts","../../src/lib/isomorphic.ts","../../src/lib/api/core/ApiError.ts","../../src/lib/api/core/CancelablePromise.ts","../../src/lib/api/core/AxiosHttpRequest.ts","../../src/lib/api/services/AuthorizationService.ts","../../src/lib/api/services/CircuitsService.ts","../../src/lib/api/services/InternalService.ts","../../src/lib/api/services/ProofsService.ts","../../src/lib/api/services/TokenService.ts","../../src/lib/api/ApiClient.ts","../../src/lib/config.ts","../../src/lib/logging.ts","../../src/lib/index.ts","../../src/cli/config.ts","../../src/cli/exec.ts","../../src/cli/utils.ts","../../src/cli/init.ts","../../src/cli/deploy.ts","../../src/cli/lint.ts","../../src/cli/login.ts","../../src/cli/logout.ts","../../src/cli/proof.ts","../../src/cli/whoami.ts"],"sourcesContent":["#! /usr/bin/env node\nimport { argv, exit } from \"process\";\n\nimport { Command } from \"@commander-js/extra-typings\";\n\nimport { cloneCommand } from \"cli/clone\";\nimport { configCommand } from \"cli/config\";\nimport { execCommand } from \"cli/exec\";\nimport { initCommand } from \"cli/init\";\nimport { deployCommand } from \"cli/deploy\";\nimport { lintCommand } from \"cli/lint\";\nimport { loginCommand } from \"cli/login\";\nimport { logoutCommand } from \"cli/logout\";\nimport { proofCommand } from \"cli/proof\";\nimport { whoamiCommand } from \"cli/whoami\";\nimport { loadPackageJson } from \"cli/utils\";\nimport sindri from \"lib\";\n\nconst version = process.env.VERSION || loadPackageJson().version;\nconst versionTag = version ? `v${version}` : \"unknown\";\n\nexport const program = new Command()\n  .name(\"sindri\")\n  .description(\"The Sindri CLI client.\")\n  .version(versionTag)\n  .enablePositionalOptions()\n  .option(\"-d, --debug\", \"Enable debug logging.\", false)\n  .option(\n    \"-q, --quiet\",\n    \"Disable all logging aside from direct command outputs for programmatic consumption.\",\n    false,\n  )\n  .addCommand(cloneCommand)\n  .addCommand(configCommand)\n  .addCommand(execCommand)\n  .addCommand(initCommand)\n  .addCommand(deployCommand)\n  .addCommand(lintCommand)\n  .addCommand(loginCommand)\n  .addCommand(logoutCommand)\n  .addCommand(proofCommand)\n  .addCommand(whoamiCommand)\n  // Parse the base command options and respond to them before invoking the subcommand.\n  .hook(\"preAction\", async (command) => {\n    // Set the logging level.\n    const { debug, quiet } = command.opts();\n    if (debug && quiet) {\n      sindri.logLevel = \"error\";\n      sindri.logger.error(\n        \"You cannot specify both the `--debug` and `--quiet` arguments.\",\n      );\n      return exit(1);\n    }\n    if (debug) {\n      sindri.logLevel = \"trace\";\n    } else if (quiet) {\n      sindri.logLevel = \"silent\";\n    } else {\n      sindri.logLevel = \"info\";\n    }\n\n    // Set the `Sindri-Client` header.\n    sindri._clientConfig.HEADERS = {\n      ...sindri._clientConfig.HEADERS,\n      \"Sindri-Client\": `sindri-js-cli/${versionTag}`,\n    };\n  });\n\nif (require.main === module) {\n  program.parse(argv);\n}\n","// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL('file:' + __filename).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","import assert from \"assert\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport process from \"process\";\n\nimport { Command } from \"@commander-js/extra-typings\";\nimport tar from \"tar\";\n\nimport sindri from \"lib\";\nimport { ApiError } from \"lib/api\";\n\nexport const cloneCommand = new Command()\n  .name(\"clone\")\n  .description(\"Clone a circuit into a local directory.\")\n  .argument(\"<circuit>\", \"The circuit to clone.\")\n  .argument(\"[directory]\", \"The directory to clone the circuit into.\")\n  .action(async (circuit, directory) => {\n    // Validate the circuit identifier.\n    const circuitIdentifierRegex =\n      /^(?:([-a-zA-Z0-9_]+)\\/)?([-a-zA-Z0-9_]+)(?::([-a-zA-Z0-9_.]+))?$/;\n    const match = circuitIdentifierRegex.exec(circuit);\n    if (!match) {\n      sindri.logger.error(`\"${circuit}\" is not a valid circuit identifier.`);\n      return process.exit(1);\n    }\n    assert(match[2], \"The circuit name must be provided.\");\n    const circuitName: string = match[2];\n    const outputDirectory: string = path.resolve(directory ?? circuitName);\n\n    // Check that the output directory does not exist.\n    if (fs.existsSync(outputDirectory)) {\n      sindri.logger.error(\n        `The directory \"${outputDirectory}\" already exists. Aborting.`,\n      );\n      return process.exit(1);\n    }\n\n    // Check that the API client is authorized.\n    if (!sindri.apiKey || !sindri.baseUrl) {\n      sindri.logger.warn(\"You must login first with `sindri login`.\");\n      return process.exit(1);\n    }\n\n    // Request the circuit tarball from the server.\n    let responseStream: NodeJS.ReadableStream;\n    sindri.logger.info(\n      `Cloning the circuit \"${circuit}\" into \"${outputDirectory}\".`,\n    );\n    try {\n      responseStream = (await sindri._client.internal.circuitDownload(\n        circuit,\n      )) as unknown as NodeJS.ReadableStream;\n    } catch (error) {\n      if (error instanceof ApiError && error.status === 401) {\n        sindri.logger.error(\n          \"Your credentials are invalid. Please log in again with `sindri login`.\",\n        );\n        return process.exit(1);\n      } else if (error instanceof ApiError && error.status === 404) {\n        sindri.logger.error(\n          `The circuit \"${circuit}\" does not exist or you lack permission to access it.`,\n        );\n        return process.exit(1);\n      } else {\n        sindri.logger.fatal(\"An unknown error occurred.\");\n        sindri.logger.error(error);\n        return process.exit(1);\n      }\n    }\n\n    // Make the output directory.\n    try {\n      fs.mkdirSync(outputDirectory, { recursive: true });\n    } catch (error) {\n      sindri.logger.fatal(\n        `Failed to create the directory \"${outputDirectory}\". Aborting.`,\n      );\n      sindri.logger.error(error);\n      return process.exit(1);\n    }\n\n    // Extract the tarball into the output directory.\n    await new Promise((resolve, reject) => {\n      responseStream.on(\"end\", resolve);\n      responseStream.on(\"error\", reject);\n      responseStream.pipe(\n        tar.x({\n          cwd: outputDirectory,\n          noChmod: true,\n          noMtime: true,\n          onwarn: (code: string, message: string) => {\n            sindri.logger.warn(\n              `While extracting tarball: ${code} - ${message}`,\n            );\n          },\n          preserveOwner: false,\n          // @ts-expect-error - `preservePaths` is missing from the library's type definitions.\n          preservePaths: false,\n          strip: 1,\n        }),\n      );\n    });\n    sindri.logger.info(\"Circuit cloned successfully.\");\n  });\n","import { readFile, stat } from \"fs/promises\";\nimport path from \"path\";\nimport type { Readable } from \"stream\";\n\nimport gzip from \"gzip-js\";\nimport walk from \"ignore-walk\";\nimport tar from \"tar\";\nimport Tar from \"tar-js\";\n\nimport { ApiClient, CircuitType, JobStatus, OpenAPIConfig } from \"lib/api\";\nimport type {\n  CircomCircuitInfoResponse,\n  Halo2CircuitInfoResponse,\n  GnarkCircuitInfoResponse,\n  NoirCircuitInfoResponse,\n  ProofInfoResponse,\n} from \"lib/api\";\nimport { Config } from \"lib/config\";\nimport { createLogger, type Logger, type LogLevel } from \"lib/logging\";\nimport { File, FormData } from \"lib/isomorphic\";\nimport type {\n  BrowserFile,\n  BrowserFormData,\n  NodeFile,\n  NodeFormData,\n} from \"lib/isomorphic\";\n\n// Re-export types from the API.\nexport type {\n  CircomCircuitInfoResponse,\n  CircuitType,\n  GnarkCircuitInfoResponse,\n  Halo2CircuitInfoResponse,\n  JobStatus,\n  NoirCircuitInfoResponse,\n  ProofInfoResponse,\n};\nexport type CircuitInfoResponse =\n  | CircomCircuitInfoResponse\n  | Halo2CircuitInfoResponse\n  | GnarkCircuitInfoResponse\n  | NoirCircuitInfoResponse;\n\n// Re-export other internal types.\nexport type { Logger, LogLevel };\n\n/**\n * The options for authenticating with the API.\n */\nexport interface AuthOptions {\n  /**\n   * The API key to use for authentication.\n   */\n  apiKey?: string;\n  /**\n   * The base URL for the API.\n   */\n  baseUrl?: string;\n}\n\n/**\n * Represents the primary client for interacting with the Sindri ZKP service API. This class serves\n * as the central entry point for the SDK, facilitating various operations such as compiling ZKP\n * circuits and generating proofs.\n *\n * The {@link SindriClient} class encapsulates all the necessary methods and properties required to\n * communicate effectively with the Sindri ZKP service, handling tasks like authentication, request\n * management, and response processing.\n *\n * Usage of this class typically involves instantiating it with appropriate authentication options\n * and then utilizing its methods to interact with the service.\n *\n * @example\n * // Create an instance of the `SindriClient` class.\n * const client = new SindriClient({ apiKey: 'your-api-key' });\n *\n * // Use the client to interact with the Sindri ZKP service...\n */\nexport class SindriClient {\n  /** @hidden */\n  readonly _client: ApiClient;\n  /** @hidden */\n  readonly _clientConfig: OpenAPIConfig;\n  /** @hidden */\n  readonly _config: Config | undefined;\n\n  readonly logger: Logger;\n\n  /**\n   * Represents the polling interval in milliseconds used for querying the status of an endpoint.\n   * This value determines the frequency at which the SDK polls an endpoint to check for any changes\n   * in status.\n   *\n   * The choice of polling interval is critical for balancing responsiveness against resource\n   * consumption.  A shorter interval leads to more frequent updates, beneficial for\n   * rapidly-changing statuses, but at the expense of higher network and computational load. In\n   * contrast, a longer interval reduces resource usage but may delay the detection of status\n   * changes.\n   *\n   * For more complex ZKP circuits, which may take longer to compile, considering a larger polling\n   * interval could be advantageous. This approach minimizes unnecessary network traffic and\n   * computational effort while awaiting the completion of these time-intensive operations.\n   *\n   * The default value is set to 1000 milliseconds (1 second), offering a general balance. However,\n   * it can and should be adjusted based on the expected complexity and compilation time of the\n   * circuits being processed.\n   */\n  public pollingInterval: number = 1000;\n\n  /**\n   * Constructs a new instance of the {@link SindriClient} class for interacting with the Sindri ZKP\n   * service.  This constructor initializes the client with the necessary authentication options.\n   *\n   * The provided `authOptions` parameter allows for specifying authentication credentials and\n   * configurations required for the client to communicate securely with the service.  See\n   * {@link SindriClient.authorize} for more details about how authentication credentials are sourced.\n   *\n   * @param authOptions - The authentication options for the client, including\n   * credentials like API keys or tokens. Defaults to an empty object if not provided.\n   *\n   * @example\n   * // Instantiating the SindriClient with authentication options\n   * const client = new SindriClient({ apiKey: 'sindri-...-fskd' });\n   *\n   * @see {@link SindriClient.authorize} for information on retrieving this value.\n   */\n  constructor(authOptions: AuthOptions = {}) {\n    // Initialize the client and store a reference to its config.\n    this._client = new ApiClient();\n    this._clientConfig = this._client.request.config;\n\n    // Set the `Sindri-Client` header.\n    const versionTag = process.env.VERSION\n      ? `v${process.env.VERSION}`\n      : \"unknown\";\n    this._clientConfig.HEADERS = {\n      ...this._clientConfig.HEADERS,\n      \"Sindri-Client\": `sindri-js-sdk/${versionTag}`,\n    };\n\n    // Create a local logger instance.\n    this.logger = createLogger();\n    if (!process.env.BROWSER_BUILD) {\n      this._config = new Config(this.logger);\n    }\n    this._clientConfig.logger = this.logger;\n\n    // Authorize the client.\n    this.authorize(authOptions);\n  }\n\n  /**\n   * Retrieves the current value of the client's API key used for authenticating with the Sindri ZKP\n   * service.  This property is crucial for ensuring secure communication with the API and is\n   * typically set during client initialization.\n   *\n   * If the API key is not set or is in an invalid format (not a string), this getter returns\n   * `null`.  Proper management of the API key is essential for the security and proper functioning\n   * of the SDK.\n   *\n   * @returns The current API key if set and valid, otherwise `null`.\n   *\n   * @example\n   * const currentApiKey = client.apiKey;\n   * if (currentApiKey) {\n   *   console.log('API Key is set.');\n   * } else {\n   *   console.log('API Key is not set or is invalid.');\n   * }\n   */\n  get apiKey(): string | null {\n    if (\n      this._clientConfig.TOKEN &&\n      typeof this._clientConfig.TOKEN !== \"string\"\n    ) {\n      return null;\n    }\n    return this._clientConfig.TOKEN || null;\n  }\n\n  /**\n   * Retrieves the current base URL of the Sindri ZKP service that the client is configured to\n   * interact with.  This URL forms the foundation of all API requests made by the client and is\n   * typically set during client initialization. Anyone other than employees at Sindri can typically\n   * ignore this and use the default value of `https://sindri.app`.\n   *\n   * @returns The current base URL of the Sindri ZKP service.\n   *\n   * @example\n   * console.log(`Current base URL: ${client.baseUrl}`);\n   */\n  get baseUrl(): string {\n    return this._clientConfig.BASE;\n  }\n\n  /** Retrieves the current log level of the client. The log level determines the verbosity of logs\n   * produced by the client which can be crucial for debugging and monitoring the client's\n   * interactions with the Sindri ZKP service.\n   *\n   * @returns The current log level of the client.\n   *\n   * @example\n   * console.log(`Current log level: ${client.logLevel}`);\n   */\n  get logLevel(): LogLevel {\n    // We don't specify any custom log levels, so we can narrow the type to exclude strings.\n    return this.logger.level as LogLevel;\n  }\n\n  /**\n   * Sets the client's log level. This level determines the verbosity of logs produced by the\n   * client, allowing for flexible control over the amount of information logged during operation.\n   *\n   * @param level - The new log level to set for the client.\n   *\n   * @example\n   * // Set log level to debug.\n   * client.logLevel = \"debug\";\n   */\n  set logLevel(level: LogLevel) {\n    this.logger.level = level;\n    this.logger.debug(`Set log level to \"${this.logger.level}\".`);\n  }\n\n  /**\n   * Authorizes the client with the Sindri ZKP service using the provided authentication options.\n   * This method is called automatically after initializing a client, but you may call it again if\n   * you would like to change the credentials. The logic around how credentials is as follows:\n   *\n   * 1. Any explicitly specified options in `authOptions` are always used if provided.\n   * 2. The `SINDRI_API_KEY` and `SINDRI_BASE_URL` environment variables are checked next.\n   * 3. The settings in `sindri.conf.json` (produced by running `sindri login` on the command-line) will be checked after that.\n   * 4. Finally, the default value of `https://sindri.app` will be used for the base URL (this is\n   * typically what you want unless you're an employee at Sindri). The API key will remain unset and\n   * you will only be able to make requests that allow anonymous access.\n   *\n   *\n   * @param authOptions - The authentication details required to authorize the client.\n   * @returns True if authorization is successful, false otherwise.\n   *\n   * @example\n   * const authOptions = { apiKey: 'sindri-...-jskd' };\n   * const isAuthorized = client.authorize(authOptions);\n   * if (isAuthorized) {\n   *   console.log('Client is fully authorized.');\n   * } else {\n   *   console.log('Client is not authorized.');\n   * }\n   */\n  authorize(authOptions: AuthOptions): boolean {\n    if (process.env.BROWSER_BUILD) {\n      this._clientConfig.BASE = authOptions.baseUrl || \"https://sindri.app\";\n      this._clientConfig.TOKEN = authOptions.apiKey;\n    } else {\n      this._config!.reload();\n      this._clientConfig.BASE =\n        authOptions.baseUrl ||\n        process.env.SINDRI_BASE_URL ||\n        this._config!.auth?.baseUrl ||\n        this._clientConfig.BASE ||\n        \"https://sindri.app\";\n      this._clientConfig.TOKEN =\n        authOptions.apiKey ||\n        process.env.SINDRI_API_KEY ||\n        this._config!.auth?.apiKey;\n    }\n    return !!(this._clientConfig.BASE && this._clientConfig.TOKEN);\n  }\n\n  /**\n   * Creates a new {@link SindriClient} client instance. The class itself is not exported, so use\n   * this method on the exported (or any other) client instance to create a new instance. The new\n   * instance can be configured and used completely independently from any other instances. For\n   * example it can use different credentials or a different log level.\n   *\n   * @param authOptions - The authentication options for the client, including\n   * credentials like API keys or tokens. Defaults to an empty object if not provided.\n   *\n   * @example\n   * import sindri from 'sindri';\n   *\n   * // Equivalent to: const myClient = new SindriClient({ ... });\n   * const myClient = sindri.create({ apiKey: 'sindri-mykey-1234'});\n   *\n   * @returns The new client instance.\n   */\n  create(authOptions: AuthOptions | undefined): SindriClient {\n    return new SindriClient(authOptions);\n  }\n\n  /**\n   * Asynchronously creates and deploys a new circuit, initiating its compilation process.  This\n   * method is essential for submitting new versions of circuits to the Sindri ZKP service for\n   * compilation. Upon deployment, it continuously polls the service to track the compilation status\n   * until the process either completes successfully or fails.\n   *\n   * The method accepts two parameters: `project` and `tags`. The `project` parameter can be either\n   * a string representing the path to the project or an array of files (browser or Node.js file\n   * objects) constituting the circuit. The `tags` parameter is used to assign tags to the deployed\n   * circuit, facilitating versioning and identification. By default, the circuit is tagged as\n   * \"latest\".\n   *\n   * After successful deployment and compilation, the method returns a `CircuitInfoResponse` object,\n   * which includes details about the compiled circuit, such as its identifier and status.\n   *\n   * @param project - In Node.js, this can either be a path to the root\n   * directory of a Sindri project, the path to a gzipped tarball containing the project, or an\n   * array of `buffer.File` objects. In a web browser, it can only be an array of `File` objects.\n   * @param tags - The list of tags, or singular tag if a string is passed, that\n   * should be associated with the deployed circuit. Defaults to `[\"latest\"]`. Specify an empty\n   * array to indicate that you don't care about the compilation outputs and just want to see if it\n   * the circuit will compile.\n   * @returns A promise which resolves to the details of the deployed circuit.\n   *\n   * @example\n   * // Deploy a circuit with a project identifier and default `latest` tag.\n   * const circuit = await client.createCircuit(\"/path/to/circuit-directory/\");\n   * console.log(\"Did circuit compilation succeed?\", circuit.status);\n   *\n   * @example\n   * // Deploy a circuit with files and custom tags.\n   * await client.createCircuit([file1, file2], ['v1.0', 'experimental']);\n   */\n  async createCircuit(\n    project: string | Array<BrowserFile | NodeFile>,\n    tags: string | string[] | null = [\"latest\"],\n  ): Promise<CircuitInfoResponse> {\n    const formData = new FormData();\n\n    // First, validate the tags and them to the form data.\n    tags = typeof tags === \"string\" ? [tags] : tags ?? [];\n    for (const tag of tags) {\n      if (!/^[-a-zA-Z0-9_.]+$/.test(tag)) {\n        throw new Error(\n          `\"${tag}\" is not a valid tag. Tags may only contain alphanumeric characters, ` +\n            \"underscores, hyphens, and periods.\",\n        );\n      }\n      formData.append(\"tags\", tag);\n    }\n    if (tags.length === 0) {\n      formData.append(\"tags\", \"\");\n    }\n\n    // Handle `project` being a file or directory path.\n    if (typeof project === \"string\") {\n      if (process.env.BROWSER_BUILD) {\n        throw new Error(\n          \"Specifying `project` as a path is not allowed in the browser build.\",\n        );\n      }\n\n      let projectStats;\n      try {\n        projectStats = await stat(project);\n      } catch {\n        throw new Error(\n          `The \"${project}\" path does not exist or you do not have permission to access it.`,\n        );\n      }\n\n      // If `project` is a path, then it's a prepackaged tarball.\n      if (projectStats.isFile()) {\n        if (!/\\.(zip|tar|tar\\.gz|tgz)$/i.test(project)) {\n          throw new Error(\"Only gzipped tarballs or zip files are supported.\");\n        }\n        const tarballFilename = path.basename(project);\n        const tarballContent = await readFile(project);\n        (formData as NodeFormData).append(\n          \"files\",\n          new File([tarballContent], tarballFilename),\n        );\n\n        // If `project` is a directory, then we need to bundle it.\n      } else if (projectStats.isDirectory()) {\n        const sindriJsonPath = path.join(project, \"sindri.json\");\n        let sindriJsonContent;\n        try {\n          sindriJsonContent = await readFile(sindriJsonPath, {\n            encoding: \"utf-8\",\n          });\n        } catch {\n          throw new Error(\n            `Expected Sindri manifest file at \"${sindriJsonPath}\" does not exist.`,\n          );\n        }\n        let sindriJson;\n        try {\n          sindriJson = JSON.parse(sindriJsonContent) as { name: string };\n        } catch {\n          throw new Error(\n            `Could not parse \"${sindriJsonPath}\", is it valid JSON?`,\n          );\n        }\n        const circuitName = sindriJson?.name;\n        if (!circuitName) {\n          throw new Error(\n            `No circuit \"name\" field was found in \"${sindriJsonPath}\", the manifest is invalid.`,\n          );\n        }\n\n        // Create a tarball with all the files that should be included from the project.\n        const files = walk\n          .sync({\n            follow: true,\n            ignoreFiles: [\".sindriignore\"],\n            path: project,\n          })\n          .filter(\n            (file) =>\n              // Always exclude `.git` subdirectories.\n              !/(^|\\/)\\.git(\\/|$)/.test(file),\n          );\n        // Always include the `sindri.json` file.\n        const sindriJsonFilename = path.basename(sindriJsonPath);\n        if (!files.includes(sindriJsonFilename)) {\n          files.push(sindriJsonFilename);\n        }\n        const tarballFilename = `${circuitName}.tar.gz`;\n        files.sort((a, b) => a.localeCompare(b)); // Deterministic for tests.\n        const tarStream = tar.c(\n          {\n            cwd: project,\n            gzip: true,\n            onwarn: (code: string, message: string) => {\n              this.logger.warn(`While creating tarball: ${code} - ${message}`);\n            },\n            prefix: `${circuitName}/`,\n            sync: true,\n          },\n          files,\n          // This works around a bug in the typing of `tar` when using `sync`.\n        ) as unknown as Readable;\n\n        // Add the tarball to the form data.\n        (formData as NodeFormData).append(\n          \"files\",\n          new File([tarStream.read()], tarballFilename),\n        );\n      } else {\n        throw new Error(`The \"${project}\" path is not a file or directory.`);\n      }\n\n      // Handle an array of files.\n    } else if (Array.isArray(project)) {\n      // Validate the file array.\n      if (!project.every((file) => file instanceof File)) {\n        throw new Error(\"All entries in `project` must be `File` instances.\");\n      }\n      const sindriJsonFile = project.find(\n        (file) => file.name === \"sindri.json\",\n      );\n      if (!sindriJsonFile) {\n        throw new Error(\n          \"The `project` array must include a `sindri.json` file.\",\n        );\n      }\n      let sindriJson;\n      try {\n        sindriJson = JSON.parse(await sindriJsonFile.text()) as {\n          name: string;\n        };\n      } catch {\n        throw new Error(`Could not parse \"sindri.json\", is it valid JSON?`);\n      }\n      const circuitName = sindriJson?.name;\n      if (!circuitName) {\n        throw new Error(\n          `No circuit \"name\" field was found in \"sindri.json\", the manifest is invalid.`,\n        );\n      }\n\n      // Create the gzipped tarball.\n      const tarball = new Tar();\n      project.sort((a, b) => a.name.localeCompare(b.name)); // Deterministic for tests.\n      for (const file of project) {\n        const content = new Uint8Array(await file.arrayBuffer());\n        await new Promise((resolve) =>\n          tarball.append(`${circuitName}/${file.name}`, content, resolve),\n        );\n      }\n      const gzippedTarball = new Uint8Array(gzip.zip(tarball.out));\n      const tarFile = new File([gzippedTarball], `${circuitName}.tar.gz`);\n\n      // Append the tarball to the form data.\n      // These lines are functionally identical, but we want to typecheck node and browser.\n      if (process.env.BROWSER_BUILD) {\n        (formData as BrowserFormData).append(\"files\", tarFile as BrowserFile);\n      } else {\n        (formData as NodeFormData).append(\"files\", tarFile as NodeFile);\n      }\n    }\n\n    // We need to shuffle in a hard-coded form boundary for tests to be deterministic.\n    // Note that it's important the boundary matches the Chrome format because the test runner\n    // checks payloads for this format in order to compare non-deterministic gzips.\n    // TODO: These header changes are global, we need to make them local to this request.\n    const oldHeaders = this._clientConfig.HEADERS;\n    this._clientConfig.HEADERS = {\n      ...oldHeaders,\n      \"Content-Type\":\n        \"multipart/form-data; boundary=----WebKitFormBoundary0buQ8d6EhWcs9X9d\",\n    };\n    const createResponsePromise = this._client.circuits.circuitCreate(\n      formData as NodeFormData,\n    );\n    const createResponse = await createResponsePromise;\n    this._clientConfig.HEADERS = oldHeaders;\n    const circuitId = createResponse.circuit_id;\n\n    let response: CircuitInfoResponse;\n    while (true) {\n      response = await this._client.circuits.circuitDetail(circuitId, false);\n      if (response.status === \"Ready\" || response.status === \"Failed\") {\n        break;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, this.pollingInterval));\n    }\n    return response;\n  }\n\n  /**\n   * Retrieves all proofs associated with a specified circuit.  This method is essential for\n   * obtaining a comprehensive list of proofs generated for a given circuit, identified by its\n   * unique circuit ID. It returns an array of `ProofInfoResponse` objects, each representing a\n   * proof associated with the circuit.\n   *\n   * The method is particularly useful in scenarios where tracking or auditing all proofs of a\n   * circuit is necessary. This could include verifying the integrity of proofs, understanding their\n   * usage, or simply enumerating them for record-keeping.\n   *\n   * The `circuitId` parameter is a string that uniquely identifies the circuit in question. It's\n   * crucial to provide the correct circuit ID to retrieve the corresponding proofs accurately.\n   *\n   * @param circuitId - The unique identifier of the circuit for which proofs are to be retrieved.\n   * @returns A promise that resolves to an array of details for each associated proof.\n   *\n   * @example\n   * const proofs = await client.getAllCircuitProofs(circuitId);\n   * console.log(\"Proofs:', proofs);\n   */\n  async getAllCircuitProofs(circuitId: string): Promise<ProofInfoResponse[]> {\n    return await this._client.circuits.circuitProofs(circuitId);\n  }\n\n  /**\n   * Retrieves all circuits associated with the team.  This method fetches a list of all circuits\n   * that have been created or accessed by the currently authenticated team. It's a key method for\n   * managing and monitoring circuit usage within a team, offering insights into the variety and\n   * scope of circuits in use.\n   *\n   * @returns A promise that resolves to an array of circuit information responses.\n   *\n   * @example\n   * const circuits = await = client.getAllCircuits();\n   * console.log(\"Circuits:\", circuits);\n   */\n  async getAllCircuits(): Promise<CircuitInfoResponse[]> {\n    return await this._client.circuits.circuitList();\n  }\n\n  /**\n   * Retrieves a specific circuit using its unique circuit ID.  This method is crucial for obtaining\n   * detailed information about a particular circuit,  identified by the provided `circuitId`. It's\n   * especially useful when detailed insights  or operations on a single circuit are required, rather\n   * than handling multiple circuits.\n   *\n   * *Note:* In case the provided `circuitId` is invalid or does not correspond to an existing circuit,\n   * the promise may reject, indicating an error. Proper error handling is therefore essential when using this method.\n   *\n   * @param circuitId - The unique identifier of the circuit to retrieve.\n   * @returns A promise that resolves to the information about the specified circuit.\n   *\n   * @example\n   * const circuit = await client.getCircuit(circuitId);\n   * console.log('Circuit details:', circuit);\n   */\n  async getCircuit(circuitId: string): Promise<CircuitInfoResponse> {\n    return await this._client.circuits.circuitDetail(circuitId);\n  }\n\n  /**\n   * Retrieves detailed information about a specific proof, identified by its unique proof ID.  This\n   * method is vital for obtaining individual proof details, facilitating in-depth analysis or\n   * verification of a particular proof within the system.\n   *\n   * The `proofId` parameter is the key identifier for the proof, and it should be provided to fetch\n   * the corresponding information. The method returns a promise that resolves to a\n   * {@link ProofInfoResponse}, containing all relevant details of the proof.\n   *\n   * @param proofId - The unique identifier of the proof to retrieve.\n   * @returns A promise that resolves to the data about the specified proof.\n   *\n   * @example\n   * const proof = await client.getProof(proofId);\n   * console.log(\"Proof details:\", proof);\n   */\n  async getProof(proofId: string): Promise<ProofInfoResponse> {\n    return await this._client.proofs.proofDetail(proofId);\n  }\n\n  /**\n   * Generates a proof for a specified circuit.  This method is critical for creating a new proof\n   * based on a given circuit, identified by `circuitId`, and the provided `proofInput`. It's\n   * primarily used to validate or verify certain conditions or properties of the circuit without\n   * revealing underlying data or specifics. The method continuously polls the service to track the\n   * compilation status until the process either completes successfully or fails.\n   *\n   * The `circuitId` parameter specifies the unique identifier of the circuit for which the proof is\n   * to be generated.  The `proofInput` is a string that represents the necessary input data or\n   * parameters required for generating the proof.\n   *\n   * @param circuitId - The unique identifier of the circuit for which the proof is being generated.\n   * @param proofInput - The input data required for generating the proof. This should be a string\n   * containing either JSON data or TOML data (in the case of Noir).\n   * @returns A promise that resolves to the information of the generated proof.\n   *\n   * @example\n   * const proof = await client.proveCircuit(circuitId, '{\"X\": 23, \"Y\": 52}');\n   * console.log(\"Generated proof:\", proof);\n   */\n  async proveCircuit(\n    circuitId: string,\n    proofInput: string,\n    verify: boolean = false,\n    includeSmartContractCalldata: boolean = false,\n  ): Promise<ProofInfoResponse> {\n    const createResponse = await this._client.circuits.proofCreate(circuitId, {\n      perform_verify: verify,\n      proof_input: proofInput,\n    });\n    let response: ProofInfoResponse;\n    while (true) {\n      response = await this._client.proofs.proofDetail(\n        createResponse.proof_id,\n        true, // includeProof\n        true, // includePublic\n        includeSmartContractCalldata, // includeSmartContractCalldata\n        true, // includeVerificationKey\n      );\n      if (response.status === \"Ready\" || response.status === \"Failed\") {\n        break;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, this.pollingInterval));\n    }\n    return response;\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from \"./ApiRequestOptions\";\nimport type { CancelablePromise } from \"./CancelablePromise\";\nimport type { OpenAPIConfig } from \"./OpenAPI\";\n\nexport abstract class BaseHttpRequest {\n  constructor(public readonly config: OpenAPIConfig) {}\n\n  public abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;\n}\n","/* This file was originally generated by `openapi-typescript-codegen`, but we've customized it and\n * it is no longer regenerated. The key changes:\n *\n *   * Support pre-constructed `FormData` instances, and make `FormData` isomorphic.\n *   * Add request/response logging for all API requests in `request()`.\n */\n\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport axios from \"axios\";\nimport type {\n  AxiosError,\n  AxiosRequestConfig,\n  AxiosResponse,\n  AxiosInstance,\n} from \"axios\";\n// Manual edit to use our isomorphic `FormData`.\nimport { FormData } from \"lib/isomorphic\";\n\nimport { ApiError } from \"./ApiError\";\nimport type { ApiRequestOptions } from \"./ApiRequestOptions\";\nimport type { ApiResult } from \"./ApiResult\";\nimport { CancelablePromise } from \"./CancelablePromise\";\nimport type { OnCancel } from \"./CancelablePromise\";\nimport type { OpenAPIConfig } from \"./OpenAPI\";\n\nexport const isDefined = <T>(\n  value: T | null | undefined,\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\nexport const isString = (value: any): value is string => {\n  return typeof value === \"string\";\n};\n\nexport const isStringWithValue = (value: any): value is string => {\n  return isString(value) && value !== \"\";\n};\n\nexport const isBlob = (value: any): value is Blob => {\n  return (\n    typeof value === \"object\" &&\n    typeof value.type === \"string\" &&\n    typeof value.stream === \"function\" &&\n    typeof value.arrayBuffer === \"function\" &&\n    typeof value.constructor === \"function\" &&\n    typeof value.constructor.name === \"string\" &&\n    /^(Blob|File)$/.test(value.constructor.name) &&\n    /^(Blob|File)$/.test(value[Symbol.toStringTag])\n  );\n};\n\nexport const isFormData = (value: any): value is FormData => {\n  return value instanceof FormData;\n};\n\nexport const isSuccess = (status: number): boolean => {\n  return status >= 200 && status < 300;\n};\n\nexport const base64 = (str: string): string => {\n  try {\n    return btoa(str);\n  } catch (err) {\n    // @ts-ignore\n    return Buffer.from(str).toString(\"base64\");\n  }\n};\n\nexport const getQueryString = (params: Record<string, any>): string => {\n  const qs: string[] = [];\n\n  const append = (key: string, value: any) => {\n    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n  };\n\n  const process = (key: string, value: any) => {\n    if (isDefined(value)) {\n      if (Array.isArray(value)) {\n        value.forEach((v) => {\n          process(key, v);\n        });\n      } else if (typeof value === \"object\") {\n        Object.entries(value).forEach(([k, v]) => {\n          process(`${key}[${k}]`, v);\n        });\n      } else {\n        append(key, value);\n      }\n    }\n  };\n\n  Object.entries(params).forEach(([key, value]) => {\n    process(key, value);\n  });\n\n  if (qs.length > 0) {\n    return `?${qs.join(\"&\")}`;\n  }\n\n  return \"\";\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n  const encoder = config.ENCODE_PATH || encodeURI;\n\n  const path = options.url\n    .replace(\"{api-version}\", config.VERSION)\n    .replace(/{(.*?)}/g, (substring: string, group: string) => {\n      if (options.path?.hasOwnProperty(group)) {\n        return encoder(String(options.path[group]));\n      }\n      return substring;\n    });\n\n  const url = `${config.BASE}${path}`;\n  if (options.query) {\n    return `${url}${getQueryString(options.query)}`;\n  }\n  return url;\n};\n\nexport const getFormData = (\n  options: ApiRequestOptions,\n): FormData | undefined => {\n  if (options.formData) {\n    // This is a manual edit to allow `FormData` to be passed in directly.\n    if (options.formData instanceof FormData) {\n      return options.formData;\n    }\n\n    const formData = new FormData();\n\n    const process = (key: string, value: any) => {\n      if (isString(value) || isBlob(value)) {\n        formData.append(key, value);\n      } else {\n        formData.append(key, JSON.stringify(value));\n      }\n    };\n\n    Object.entries(options.formData)\n      .filter(([_, value]) => isDefined(value))\n      .forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((v) => process(key, v));\n        } else {\n          process(key, value);\n        }\n      });\n\n    return formData;\n  }\n  return undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nexport const resolve = async <T>(\n  options: ApiRequestOptions,\n  resolver?: T | Resolver<T>,\n): Promise<T | undefined> => {\n  if (typeof resolver === \"function\") {\n    return (resolver as Resolver<T>)(options);\n  }\n  return resolver;\n};\n\nexport const getHeaders = async (\n  config: OpenAPIConfig,\n  options: ApiRequestOptions,\n  formData?: FormData,\n): Promise<Record<string, string>> => {\n  const token = await resolve(options, config.TOKEN);\n  const username = await resolve(options, config.USERNAME);\n  const password = await resolve(options, config.PASSWORD);\n  const additionalHeaders = await resolve(options, config.HEADERS);\n  // Manual edit to support `FormData` implementations that don't include `getHeaders()`.\n  const formHeaders =\n    (formData &&\n      \"getHeaders\" in formData &&\n      typeof formData?.getHeaders === \"function\" &&\n      formData?.getHeaders()) ||\n    {};\n\n  const headers = Object.entries({\n    Accept: \"application/json\",\n    ...additionalHeaders,\n    ...options.headers,\n    ...formHeaders,\n  })\n    .filter(([_, value]) => isDefined(value))\n    .reduce(\n      (headers, [key, value]) => ({\n        ...headers,\n        [key]: String(value),\n      }),\n      {} as Record<string, string>,\n    );\n\n  if (isStringWithValue(token)) {\n    headers[\"Authorization\"] = `Bearer ${token}`;\n  }\n\n  if (isStringWithValue(username) && isStringWithValue(password)) {\n    const credentials = base64(`${username}:${password}`);\n    headers[\"Authorization\"] = `Basic ${credentials}`;\n  }\n\n  if (options.body) {\n    if (options.mediaType) {\n      headers[\"Content-Type\"] = options.mediaType;\n    } else if (isBlob(options.body)) {\n      headers[\"Content-Type\"] = options.body.type || \"application/octet-stream\";\n    } else if (isString(options.body)) {\n      headers[\"Content-Type\"] = \"text/plain\";\n    } else if (!isFormData(options.body)) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n  }\n\n  return headers;\n};\n\nexport const getRequestBody = (options: ApiRequestOptions): any => {\n  if (options.body) {\n    return options.body;\n  }\n  return undefined;\n};\n\nexport const sendRequest = async <T>(\n  config: OpenAPIConfig,\n  options: ApiRequestOptions,\n  url: string,\n  body: any,\n  formData: FormData | undefined,\n  headers: Record<string, string>,\n  onCancel: OnCancel,\n  axiosClient: AxiosInstance,\n): Promise<AxiosResponse<T>> => {\n  const source = axios.CancelToken.source();\n\n  const requestConfig: AxiosRequestConfig = {\n    url,\n    headers,\n    data: body ?? formData,\n    method: options.method,\n    withCredentials: config.WITH_CREDENTIALS,\n    cancelToken: source.token,\n    responseType: options.responseType,\n  };\n\n  onCancel(() => source.cancel(\"The user aborted a request.\"));\n\n  try {\n    const response = await axiosClient.request(requestConfig);\n    return response;\n  } catch (error) {\n    const axiosError = error as AxiosError<T>;\n    if (axiosError.response) {\n      return axiosError.response;\n    }\n    throw error;\n  }\n};\n\nexport const getResponseHeader = (\n  response: AxiosResponse<any>,\n  responseHeader?: string,\n): string | undefined => {\n  if (responseHeader) {\n    const content = response.headers[responseHeader];\n    if (isString(content)) {\n      return content;\n    }\n  }\n  return undefined;\n};\n\nexport const getResponseBody = (response: AxiosResponse<any>): any => {\n  if (response.status !== 204) {\n    return response.data;\n  }\n  return undefined;\n};\n\nexport const catchErrorCodes = (\n  options: ApiRequestOptions,\n  result: ApiResult,\n): void => {\n  const errors: Record<number, string> = {\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    500: \"Internal Server Error\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    ...options.errors,\n  };\n\n  const error = errors[result.status];\n  if (error) {\n    throw new ApiError(options, result, error);\n  }\n\n  if (!result.ok) {\n    const errorStatus = result.status ?? \"unknown\";\n    const errorStatusText = result.statusText ?? \"unknown\";\n    const errorBody = (() => {\n      try {\n        return JSON.stringify(result.body, null, 2);\n      } catch (e) {\n        return undefined;\n      }\n    })();\n\n    throw new ApiError(\n      options,\n      result,\n      `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`,\n    );\n  }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @param axiosClient The axios client instance to use\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(\n  config: OpenAPIConfig,\n  options: ApiRequestOptions,\n  axiosClient: AxiosInstance = axios,\n): CancelablePromise<T> => {\n  return new CancelablePromise(async (resolve, reject, onCancel) => {\n    // Get a nicely formatted timedelta to display after requests.\n    const startTime = Date.now();\n    const getElapsedTime = (): string => {\n      const ellapsedMilliseconds = Date.now() - startTime;\n      if (ellapsedMilliseconds < 1000) {\n        return `${ellapsedMilliseconds} ms`;\n      }\n      const ellapsedSeconds = ellapsedMilliseconds / 1000;\n      if (ellapsedSeconds < 60) {\n        return `${ellapsedSeconds.toFixed(2)} s`;\n      }\n      const ellapsedMinutes = ellapsedSeconds / 60;\n      if (ellapsedMinutes < 60) {\n        return `${ellapsedMinutes.toFixed(2)} m`;\n      }\n      const ellapsedHours = ellapsedMinutes / 60;\n      return `${ellapsedHours.toFixed(2)} h`;\n    };\n\n    const url = getUrl(config, options);\n    const logPrefix = `${options.method} ${url}`;\n    try {\n      const formData = getFormData(options);\n      const body = getRequestBody(options);\n      const headers = await getHeaders(config, options, formData);\n\n      if (!onCancel.isCancelled) {\n        config.logger?.debug(`${logPrefix} requested`);\n        const response = await sendRequest<T>(\n          config,\n          options,\n          url,\n          body,\n          formData,\n          headers,\n          onCancel,\n          axiosClient,\n        );\n        const responseBody = getResponseBody(response);\n        const responseHeader = getResponseHeader(\n          response,\n          options.responseHeader,\n        );\n\n        const result: ApiResult = {\n          url,\n          ok: isSuccess(response.status),\n          status: response.status,\n          statusText: response.statusText,\n          body: responseHeader ?? responseBody,\n        };\n        const responseMessage = `${logPrefix} ${response.status} ${\n          response.statusText\n        } (${getElapsedTime()})`;\n        if (!result.body || typeof result.body === \"string\") {\n          config.logger?.debug(\n            `${responseMessage} - ${result.body || \"<empty-body>\"}`,\n          );\n        } else if (options.responseType === \"stream\") {\n          config.logger?.debug(`${responseMessage} - <streaming-response>`);\n        } else if (options.responseType === \"blob\") {\n          config.logger?.debug(`${responseMessage} - <blob-response>`);\n        } else {\n          config.logger?.debug(result.body, responseMessage);\n        }\n\n        catchErrorCodes(options, result);\n\n        resolve(result.body);\n      }\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      config.logger?.debug(\n        `${logPrefix} ERROR (${getElapsedTime()}) - ${errorMessage}`,\n      );\n      reject(error);\n    }\n  });\n};\n","import { File as NodeFile } from \"buffer\";\n\nimport { FormData as NodeFormData } from \"formdata-node\";\n\nexport function assertType<T>(value: unknown) {\n  function isType<T>(value: unknown): value is T {\n    return true || value;\n  }\n  if (!isType<T>(value)) throw new Error(\"Impossible.\");\n}\n\nexport type { NodeFile, NodeFormData };\nexport type BrowserFile = File;\nexport type BrowserFormData = FormData;\n\nexport const File = process.env.BROWSER_BUILD ? window.File : NodeFile;\nexport const FormData = process.env.BROWSER_BUILD\n  ? window.FormData\n  : NodeFormData;\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from \"./ApiRequestOptions\";\nimport type { ApiResult } from \"./ApiResult\";\n\nexport class ApiError extends Error {\n  public readonly url: string;\n  public readonly status: number;\n  public readonly statusText: string;\n  public readonly body: any;\n  public readonly request: ApiRequestOptions;\n\n  constructor(\n    request: ApiRequestOptions,\n    response: ApiResult,\n    message: string,\n  ) {\n    super(message);\n\n    this.name = \"ApiError\";\n    this.url = response.url;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.body = response.body;\n    this.request = request;\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nexport class CancelError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"CancelError\";\n  }\n\n  public get isCancelled(): boolean {\n    return true;\n  }\n}\n\nexport interface OnCancel {\n  readonly isResolved: boolean;\n  readonly isRejected: boolean;\n  readonly isCancelled: boolean;\n\n  (cancelHandler: () => void): void;\n}\n\nexport class CancelablePromise<T> implements Promise<T> {\n  #isResolved: boolean;\n  #isRejected: boolean;\n  #isCancelled: boolean;\n  readonly #cancelHandlers: (() => void)[];\n  readonly #promise: Promise<T>;\n  #resolve?: (value: T | PromiseLike<T>) => void;\n  #reject?: (reason?: any) => void;\n\n  constructor(\n    executor: (\n      resolve: (value: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void,\n      onCancel: OnCancel,\n    ) => void,\n  ) {\n    this.#isResolved = false;\n    this.#isRejected = false;\n    this.#isCancelled = false;\n    this.#cancelHandlers = [];\n    this.#promise = new Promise<T>((resolve, reject) => {\n      this.#resolve = resolve;\n      this.#reject = reject;\n\n      const onResolve = (value: T | PromiseLike<T>): void => {\n        if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n          return;\n        }\n        this.#isResolved = true;\n        this.#resolve?.(value);\n      };\n\n      const onReject = (reason?: any): void => {\n        if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n          return;\n        }\n        this.#isRejected = true;\n        this.#reject?.(reason);\n      };\n\n      const onCancel = (cancelHandler: () => void): void => {\n        if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n          return;\n        }\n        this.#cancelHandlers.push(cancelHandler);\n      };\n\n      Object.defineProperty(onCancel, \"isResolved\", {\n        get: (): boolean => this.#isResolved,\n      });\n\n      Object.defineProperty(onCancel, \"isRejected\", {\n        get: (): boolean => this.#isRejected,\n      });\n\n      Object.defineProperty(onCancel, \"isCancelled\", {\n        get: (): boolean => this.#isCancelled,\n      });\n\n      return executor(onResolve, onReject, onCancel as OnCancel);\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Cancellable Promise\";\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n    onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,\n  ): Promise<TResult1 | TResult2> {\n    return this.#promise.then(onFulfilled, onRejected);\n  }\n\n  public catch<TResult = never>(\n    onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,\n  ): Promise<T | TResult> {\n    return this.#promise.catch(onRejected);\n  }\n\n  public finally(onFinally?: (() => void) | null): Promise<T> {\n    return this.#promise.finally(onFinally);\n  }\n\n  public cancel(): void {\n    if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n      return;\n    }\n    this.#isCancelled = true;\n    if (this.#cancelHandlers.length) {\n      try {\n        for (const cancelHandler of this.#cancelHandlers) {\n          cancelHandler();\n        }\n      } catch (error) {\n        console.warn(\"Cancellation threw an error\", error);\n        return;\n      }\n    }\n    this.#cancelHandlers.length = 0;\n    this.#reject?.(new CancelError(\"Request aborted\"));\n  }\n\n  public get isCancelled(): boolean {\n    return this.#isCancelled;\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from \"./ApiRequestOptions\";\nimport { BaseHttpRequest } from \"./BaseHttpRequest\";\nimport type { CancelablePromise } from \"./CancelablePromise\";\nimport type { OpenAPIConfig } from \"./OpenAPI\";\nimport { request as __request } from \"./request\";\n\nexport class AxiosHttpRequest extends BaseHttpRequest {\n  constructor(config: OpenAPIConfig) {\n    super(config);\n  }\n\n  /**\n   * Request method\n   * @param options The request options from the service\n   * @returns CancelablePromise<T>\n   * @throws ApiError\n   */\n  public override request<T>(options: ApiRequestOptions): CancelablePromise<T> {\n    return __request(this.config, options);\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ActionResponse } from \"../models/ActionResponse\";\nimport type { APIKeyResponse } from \"../models/APIKeyResponse\";\nimport type { ObtainApikeyInput } from \"../models/ObtainApikeyInput\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\nexport class AuthorizationService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Generate API Key\n   * Generates a long-term API Key from your account's username and password.\n   * @param requestBody\n   * @returns APIKeyResponse OK\n   * @throws ApiError\n   */\n  public apikeyGenerate(\n    requestBody: ObtainApikeyInput,\n  ): CancelablePromise<APIKeyResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/apikey/generate\",\n      body: requestBody,\n      mediaType: \"application/json\",\n      errors: {\n        401: `Unauthorized`,\n        412: `Precondition Failed`,\n      },\n    });\n  }\n\n  /**\n   * Generate long-term API Key (requires prior authentication)\n   * Return a long-term API key for the user's team.\n   * @param name An optional name or tag to assign to the generated API Key.\n   * @returns APIKeyResponse Created\n   * @throws ApiError\n   */\n  public apikeyGenerateWithAuth(\n    name?: string,\n  ): CancelablePromise<APIKeyResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/v1/apikey/generate\",\n      query: {\n        name: name,\n      },\n      errors: {\n        412: `Precondition Failed`,\n      },\n    });\n  }\n\n  /**\n   * API Key List\n   * Return a list of API Keys for the team.\n   * @returns APIKeyResponse OK\n   * @throws ApiError\n   */\n  public apikeyList(): CancelablePromise<Array<APIKeyResponse>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/apikey/list\",\n      errors: {\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Delete API Key\n   * Mark the specified API Key as deleted.\n   * @param apikeyId The UUID4 identifier associated with this API Key.\n   * @returns ActionResponse OK\n   * @throws ApiError\n   */\n  public apikeyDelete(apikeyId: string): CancelablePromise<ActionResponse> {\n    return this.httpRequest.request({\n      method: \"DELETE\",\n      url: \"/api/v1/apikey/{apikey_id}/delete\",\n      path: {\n        apikey_id: apikeyId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ActionResponse } from \"../models/ActionResponse\";\nimport type { CircuitInfoResponse } from \"../models/CircuitInfoResponse\";\nimport type { ProofInfoResponse } from \"../models/ProofInfoResponse\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\nexport class CircuitsService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Create Circuit\n   * Create a circuit.\n   * @param formData\n   * @returns CircuitInfoResponse Created\n   * @throws ApiError\n   */\n  public circuitCreate(\n    formData: // This is a manual edit to allow `FormData` to be passed in directly:\n    | FormData // DO NOT REMOVE THIS!\n      | {\n          files: Array<Blob>;\n          /**\n           * Tags for a circuit.\n           */\n          tags?: Array<string>;\n        },\n  ): CancelablePromise<CircuitInfoResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/v1/circuit/create\",\n      formData: formData,\n      mediaType: \"multipart/form-data\",\n      errors: {\n        412: `Precondition Failed`,\n        422: `Unprocessable Entity`,\n        500: `Internal Server Error`,\n        501: `Not Implemented`,\n      },\n    });\n  }\n\n  /**\n   * Circuit List\n   * Return the list of all circuit infos.\n   * @returns CircuitInfoResponse OK\n   * @throws ApiError\n   */\n  public circuitList(): CancelablePromise<Array<CircuitInfoResponse>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/list\",\n      errors: {\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Circuit Detail\n   * Get info for an existing circuit.\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @param includeVerificationKey Indicates whether to include the verification key in the response.\n   * @returns CircuitInfoResponse OK\n   * @throws ApiError\n   */\n  public circuitDetail(\n    circuitId: string,\n    includeVerificationKey: boolean = true,\n  ): CancelablePromise<CircuitInfoResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/{circuit_id}/detail\",\n      path: {\n        circuit_id: circuitId,\n      },\n      query: {\n        include_verification_key: includeVerificationKey,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Delete Circuit\n   * Mark the specified circuit and any of its related proofs as deleted.\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @returns ActionResponse OK\n   * @throws ApiError\n   */\n  public circuitDelete(circuitId: string): CancelablePromise<ActionResponse> {\n    return this.httpRequest.request({\n      method: \"DELETE\",\n      url: \"/api/v1/circuit/{circuit_id}/delete\",\n      path: {\n        circuit_id: circuitId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Circuit Proofs\n   * Return a list of proof infos for the provided circuit_id.\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @returns ProofInfoResponse OK\n   * @throws ApiError\n   */\n  public circuitProofs(\n    circuitId: string,\n  ): CancelablePromise<Array<ProofInfoResponse>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/{circuit_id}/proofs\",\n      path: {\n        circuit_id: circuitId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Create Proof for Circuit\n   * Prove a circuit with specific inputs.\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @param formData\n   * @returns ProofInfoResponse Created\n   * @throws ApiError\n   */\n  public proofCreate(\n    circuitId: string,\n    formData: {\n      /**\n       * A string representing proof input which may be formatted as JSON for any framework. Noir circuits optionally accept TOML formatted proof input.\n       */\n      proof_input: string;\n      /**\n       * A boolean indicating whether to perform an internal verification check during the proof creation.\n       */\n      perform_verify?: boolean;\n      /**\n       * Internal prover implementation setting.\n       */\n      prover_implementation?: string;\n    },\n  ): CancelablePromise<ProofInfoResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/v1/circuit/{circuit_id}/prove\",\n      path: {\n        circuit_id: circuitId,\n      },\n      formData: formData,\n      mediaType: \"application/x-www-form-urlencoded\",\n      errors: {\n        404: `Not Found`,\n        412: `Precondition Failed`,\n        501: `Not Implemented`,\n      },\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ActionResponse } from \"../models/ActionResponse\";\nimport type { ProofInfoResponse } from \"../models/ProofInfoResponse\";\nimport type { SmartContractVerifierResponse } from \"../models/SmartContractVerifierResponse\";\nimport type { TeamMeResponse } from \"../models/TeamMeResponse\";\nimport type { UserMeResponse } from \"../models/UserMeResponse\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\n// DO NOT REMOVE\ntype BinaryResponseType = typeof globalThis extends { ReadableStream: unknown }\n  ? Blob\n  : NodeJS.ReadableStream;\n\nexport class InternalService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Circuit Download\n   * Return the gzipped tarball for the specified circuit.\n   * @param circuitId\n   * @returns binary OK\n   * @throws ApiError\n   */\n  public circuitDownload(\n    circuitId: string,\n    // DO NOT REMOVE\n  ): CancelablePromise<BinaryResponseType> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/{circuit_id}/download\",\n      path: {\n        circuit_id: circuitId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n      responseType: process.env.BROWSER_BUILD ? \"blob\" : \"stream\", // DO NOT REMOVE\n    });\n  }\n\n  /**\n   * Circuit Smart Contract Verifier\n   * Get smart contract verifier for existing circuit\n   * @param circuitId The circuit identifer of the circuit.\n   * This can take one of the following forms:\n   *\n   * 1. `<CIRCUIT_ID>` - The unique UUID4 ID for an exact version of a compiled circuit.\n   * 2. `<CIRCUIT_NAME>` - The name of a circuit owned by the authenticated team. This will default to\n   * the most recent version of the circuit tagged as `latest`.\n   * 3. `<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by the authenticated team and an explicit\n   * tag. This corresponds to the most recent compilation of the circuit with the specified tag.\n   * 4. `<TEAM_NAME>/<CIRCUIT_NAME>` - The name of a circuit owned by the specified team.  This will\n   * default to the most recent version of the circuit tagged as `latest`.\n   * 5. `<TEAM_NAME>/<CIRCUIT_NAME>:<TAG>` - The name of a circuit owned by a specified team and an\n   * explicit tag. This corresponds to the most recent compilation of the team's circuit with the\n   * specified tag.\n   * @returns SmartContractVerifierResponse OK\n   * @throws ApiError\n   */\n  public circuitSmartContractVerifier(\n    circuitId: string,\n  ): CancelablePromise<SmartContractVerifierResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/circuit/{circuit_id}/smart_contract_verifier\",\n      path: {\n        circuit_id: circuitId,\n      },\n      errors: {\n        404: `Not Found`,\n        412: `Precondition Failed`,\n        500: `Internal Server Error`,\n        501: `Not Implemented`,\n      },\n    });\n  }\n\n  /**\n   * Change user password (requires JWT authentication)\n   * Change password for a user.\n   *\n   * This endpoint requires JWT authentication in order\n   * to know which user is making the request. It expects to receive\n   * an authenticated user in `request.auth`.\n   *\n   * We subsequently verify the old password and then update the user's password.\n   * @param formData\n   * @returns ActionResponse OK\n   * @throws ApiError\n   */\n  public passwordChangeWithJwtAuth(formData: {\n    /**\n     * Old password.\n     */\n    old_password: string;\n    /**\n     * New password.\n     */\n    new_password: string;\n  }): CancelablePromise<ActionResponse> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/v1/password/change\",\n      formData: formData,\n      mediaType: \"application/x-www-form-urlencoded\",\n      errors: {\n        422: `Unprocessable Entity`,\n      },\n    });\n  }\n\n  /**\n   * Proof List\n   * Return the list of all proof infos.\n   * @returns ProofInfoResponse OK\n   * @throws ApiError\n   */\n  public proofList(): CancelablePromise<Array<ProofInfoResponse>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/proof/list\",\n      errors: {\n        500: `Internal Server Error`,\n      },\n    });\n  }\n\n  /**\n   * Return the JSON schema for `sindri.json` manifest files\n   * Return the JSON schema for `sindri.json` manifest files\n   * @returns any OK\n   * @throws ApiError\n   */\n  public sindriManifestSchema(): CancelablePromise<Record<string, any>> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/sindri-manifest-schema.json\",\n    });\n  }\n\n  /**\n   * Obtain team details for the currently authenticated team\n   * Return details about the currently authenticated team.\n   * @returns TeamMeResponse OK\n   * @throws ApiError\n   */\n  public teamMe(): CancelablePromise<TeamMeResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/team/me\",\n    });\n  }\n\n  /**\n   * Obtain user details (requires JWT authentication)\n   * Return details about the user and their teams.\n   *\n   * This endpoint requires JWT authentication in order\n   * to know which user is making the request. It expects to receive\n   * an authenticated user in `request.auth`.\n   * @returns UserMeResponse OK\n   * @throws ApiError\n   */\n  public userMeWithJwtAuth(): CancelablePromise<UserMeResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/user/me\",\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ActionResponse } from \"../models/ActionResponse\";\nimport type { ProofInfoResponse } from \"../models/ProofInfoResponse\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\nexport class ProofsService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Proof Detail\n   * Get info for an existing proof.\n   * @param proofId The UUID4 identifier associated with this proof.\n   * @param includeProof Indicates whether to include the proof in the response.\n   * @param includePublic Indicates whether to include public inputs in the response.\n   * @param includeSmartContractCalldata Indicates whether to include the proof and public formatted as smart contract calldata in the response.\n   * @param includeVerificationKey Indicates whether to include the circuit's verification key in the response.\n   * @returns ProofInfoResponse OK\n   * @throws ApiError\n   */\n  public proofDetail(\n    proofId: string,\n    includeProof: boolean = true,\n    includePublic: boolean = true,\n    includeSmartContractCalldata: boolean = false,\n    includeVerificationKey: boolean = true,\n  ): CancelablePromise<ProofInfoResponse> {\n    return this.httpRequest.request({\n      method: \"GET\",\n      url: \"/api/v1/proof/{proof_id}/detail\",\n      path: {\n        proof_id: proofId,\n      },\n      query: {\n        include_proof: includeProof,\n        include_public: includePublic,\n        include_smart_contract_calldata: includeSmartContractCalldata,\n        include_verification_key: includeVerificationKey,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n        501: `Not Implemented`,\n      },\n    });\n  }\n\n  /**\n   * Delete Proof\n   * Mark the specified proof as deleted.\n   * @param proofId The UUID4 identifier associated with this proof.\n   * @returns ActionResponse OK\n   * @throws ApiError\n   */\n  public proofDelete(proofId: string): CancelablePromise<ActionResponse> {\n    return this.httpRequest.request({\n      method: \"DELETE\",\n      url: \"/api/v1/proof/{proof_id}/delete\",\n      path: {\n        proof_id: proofId,\n      },\n      errors: {\n        404: `Not Found`,\n        500: `Internal Server Error`,\n      },\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { Schema } from \"../models/Schema\";\nimport type { TokenObtainPairInputSchema } from \"../models/TokenObtainPairInputSchema\";\nimport type { TokenObtainPairOutputSchema } from \"../models/TokenObtainPairOutputSchema\";\nimport type { TokenRefreshInputSchema } from \"../models/TokenRefreshInputSchema\";\nimport type { TokenRefreshOutputSchema } from \"../models/TokenRefreshOutputSchema\";\nimport type { TokenVerifyInputSchema } from \"../models/TokenVerifyInputSchema\";\n\nimport type { CancelablePromise } from \"../core/CancelablePromise\";\nimport type { BaseHttpRequest } from \"../core/BaseHttpRequest\";\n\nexport class TokenService {\n  constructor(public readonly httpRequest: BaseHttpRequest) {}\n\n  /**\n   * Obtain Token\n   * @param requestBody\n   * @returns TokenObtainPairOutputSchema OK\n   * @throws ApiError\n   */\n  public fd3Aaa7BControllerObtainToken(\n    requestBody: TokenObtainPairInputSchema,\n  ): CancelablePromise<TokenObtainPairOutputSchema> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/token/pair\",\n      body: requestBody,\n      mediaType: \"application/json\",\n    });\n  }\n\n  /**\n   * Refresh Token\n   * @param requestBody\n   * @returns TokenRefreshOutputSchema OK\n   * @throws ApiError\n   */\n  public b87E0720ControllerRefreshToken(\n    requestBody: TokenRefreshInputSchema,\n  ): CancelablePromise<TokenRefreshOutputSchema> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/token/refresh\",\n      body: requestBody,\n      mediaType: \"application/json\",\n    });\n  }\n\n  /**\n   * Verify Token\n   * @param requestBody\n   * @returns Schema OK\n   * @throws ApiError\n   */\n  public d1C092ControllerVerifyToken(\n    requestBody: TokenVerifyInputSchema,\n  ): CancelablePromise<Schema> {\n    return this.httpRequest.request({\n      method: \"POST\",\n      url: \"/api/token/verify\",\n      body: requestBody,\n      mediaType: \"application/json\",\n    });\n  }\n}\n","/* generated using openapi-typescript-codegen -- do no edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { BaseHttpRequest } from './core/BaseHttpRequest';\nimport type { OpenAPIConfig } from './core/OpenAPI';\nimport { AxiosHttpRequest } from './core/AxiosHttpRequest';\n\nimport { AuthorizationService } from './services/AuthorizationService';\nimport { CircuitsService } from './services/CircuitsService';\nimport { InternalService } from './services/InternalService';\nimport { ProofsService } from './services/ProofsService';\nimport { TokenService } from './services/TokenService';\n\ntype HttpRequestConstructor = new (config: OpenAPIConfig) => BaseHttpRequest;\n\nexport class ApiClient {\n\n    public readonly authorization: AuthorizationService;\n    public readonly circuits: CircuitsService;\n    public readonly internal: InternalService;\n    public readonly proofs: ProofsService;\n    public readonly token: TokenService;\n\n    public readonly request: BaseHttpRequest;\n\n    constructor(config?: Partial<OpenAPIConfig>, HttpRequest: HttpRequestConstructor = AxiosHttpRequest) {\n        this.request = new HttpRequest({\n            BASE: config?.BASE ?? 'https://sindri.app',\n            VERSION: config?.VERSION ?? '1.6.14',\n            WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,\n            CREDENTIALS: config?.CREDENTIALS ?? 'include',\n            TOKEN: config?.TOKEN,\n            USERNAME: config?.USERNAME,\n            PASSWORD: config?.PASSWORD,\n            HEADERS: config?.HEADERS,\n            ENCODE_PATH: config?.ENCODE_PATH,\n        });\n\n        this.authorization = new AuthorizationService(this.request);\n        this.circuits = new CircuitsService(this.request);\n        this.internal = new InternalService(this.request);\n        this.proofs = new ProofsService(this.request);\n        this.token = new TokenService(this.request);\n    }\n}\n\n","import fs from \"fs\";\nimport path from \"path\";\n\nimport envPaths from \"env-paths\";\nimport _ from \"lodash\";\nimport { z } from \"zod\";\n\nimport { type Logger } from \"lib/logging\";\n\nconst getConfigPath = (): string => {\n  const paths = envPaths(\"sindri\", {\n    suffix: \"\",\n  });\n  return path.join(paths.config, \"sindri.conf.json\");\n};\n\nconst ConfigSchema = z.object({\n  auth: z\n    .nullable(\n      z.object({\n        apiKey: z.string(),\n        apiKeyId: z.string(),\n        apiKeyName: z.string(),\n        baseUrl: z.string().url(),\n        teamId: z.number(),\n        teamSlug: z.string(),\n      }),\n    )\n    .default(null),\n});\n\ntype ConfigSchema = z.infer<typeof ConfigSchema>;\n\nconst defaultConfig: ConfigSchema = ConfigSchema.parse({});\n\nexport const loadConfig = (logger?: Logger): ConfigSchema => {\n  const configPath = getConfigPath();\n  if (fs.existsSync(configPath)) {\n    logger?.debug(`Loading config from \"${configPath}\".`);\n    try {\n      const configFileContents: string = fs.readFileSync(configPath, {\n        encoding: \"utf-8\",\n      });\n      const loadedConfig = ConfigSchema.parse(JSON.parse(configFileContents));\n      logger?.debug(\"Config loaded successfully.\");\n      return loadedConfig;\n    } catch (error) {\n      logger?.warn(\n        `The config schema in \"${configPath}\" is invalid and will not be used.\\n` +\n          `To remove it and start fresh, run:\\n    rm ${configPath}`,\n      );\n      logger?.debug(error);\n    }\n  }\n  logger?.debug(\n    `Config file \"${configPath}\" does not exist, initializing default config.`,\n  );\n  return _.cloneDeep(defaultConfig);\n};\n\nexport class Config {\n  protected _config!: ConfigSchema;\n  protected readonly logger: Logger | undefined;\n\n  constructor(logger?: Logger) {\n    this.logger = logger;\n    this.reload();\n  }\n\n  get auth(): ConfigSchema[\"auth\"] {\n    return _.cloneDeep(this._config.auth);\n  }\n\n  get config(): ConfigSchema {\n    return _.cloneDeep(this._config);\n  }\n\n  reload() {\n    this._config = loadConfig(this.logger);\n  }\n\n  update(configData: Partial<ConfigSchema>) {\n    // Merge and validate the configs.\n    this.logger?.debug(\"Merging in config update:\");\n    this.logger?.debug(configData);\n    const newConfig: ConfigSchema = _.cloneDeep(this._config);\n    _.merge(newConfig, configData);\n    this._config = ConfigSchema.parse(newConfig);\n\n    // Create the directory if it doesn't exist.\n    const configPath = getConfigPath();\n    const directory = path.dirname(configPath);\n    if (!fs.existsSync(directory)) {\n      fs.mkdirSync(directory, { recursive: true });\n    }\n\n    // Write out the new config.\n    this.logger?.debug(\n      `Writing merged config to \"${configPath}\":`,\n      this._config,\n    );\n    fs.writeFileSync(configPath, JSON.stringify(this._config, null, 2), {\n      encoding: \"utf-8\",\n    });\n  }\n}\n","import pino, { type BaseLogger as Logger } from \"pino\";\nimport pretty from \"pino-pretty\";\n\nexport type { Logger };\n\n/**\n * The minimum log level to print.\n */\nexport type LogLevel =\n  | \"silent\"\n  | \"fatal\"\n  | \"error\"\n  | \"warn\"\n  | \"info\"\n  | \"debug\"\n  | \"trace\";\n\nexport const createLogger = (level?: LogLevel): Logger => {\n  const logger = pino(\n    process.env.BROWSER_BUILD\n      ? {\n          browser: { asObject: true },\n        }\n      : pretty({\n          colorize: true,\n          destination: 2,\n          ignore: \"hostname,pid\",\n          levelFirst: false,\n          sync: true,\n        }),\n  );\n  logger.level =\n    level ?? process.env.NODE_ENV === \"production\" ? \"silent\" : \"info\";\n  return logger;\n};\nexport const logger = createLogger();\n\nexport const print = console.log;\n","import { SindriClient } from \"./client\";\n\nexport default new SindriClient();\n\nexport type * from \"./client\";\nexport type { LogLevel } from \"./logging\";\n","import { Command } from \"@commander-js/extra-typings\";\n\nimport { print } from \"lib/logging\";\nimport sindri from \"lib\";\n\nexport const configListCommand = new Command()\n  .name(\"list\")\n  .description(\"Show the current config.\")\n  .action(async () => {\n    // Reload the config because the log level was `silent` when the config was initially loaded.\n    sindri._config!.reload();\n    print(sindri._config!.config);\n  });\n\nexport const configCommand = new Command()\n  .name(\"config\")\n  .description(\"Commands related to configuration and config files.\")\n  .addCommand(configListCommand);\n","import assert from \"assert\";\nimport path from \"path\";\nimport process from \"process\";\n\nimport { Command } from \"@commander-js/extra-typings\";\n\nimport {\n  checkDockerAvailability,\n  execDockerCommand,\n  findFileUpwards,\n  getDockerImageTags,\n} from \"cli/utils\";\nimport sindri from \"lib\";\nimport { print } from \"lib/logging\";\n\n// Shared globals between the different subcommands.\nlet listTags: boolean;\nlet rootDirectory: string;\nlet tag: string;\n\nconst circomspectCommand = new Command()\n  .name(\"circomspect\")\n  .description(\n    \"Trail of Bit's Circomspect static analysis tool for Circom circuits.\",\n  )\n  .helpOption(false)\n  .addHelpCommand(false)\n  .allowUnknownOption()\n  .passThroughOptions()\n  .argument(\"[args...]\", \"Arguments to pass to the tool.\")\n  .action(async (args) => {\n    if (listTags) return; // Don't run the command if we're just listing tags.\n\n    try {\n      const code = await execDockerCommand(\"circomspect\", args, {\n        logger: sindri.logger,\n        rootDirectory,\n        tag,\n        tty: true,\n      });\n      process.exit(code);\n    } catch (error) {\n      sindri.logger.error(\"Failed to run the circomspect command.\");\n      sindri.logger.debug(error);\n      return process.exit(1);\n    }\n  });\n\nconst nargoCommand = new Command()\n  .name(\"nargo\")\n  .description(\"Aztec Lab's Noir compiler and package manager.\")\n  .helpOption(false)\n  .addHelpCommand(false)\n  .allowUnknownOption()\n  .passThroughOptions()\n  .argument(\"[args...]\", \"Arguments to pass to the tool.\")\n  .action(async (args) => {\n    if (listTags) return; // Don't run the command if we're just listing tags.\n\n    try {\n      const code = await execDockerCommand(\"nargo\", args, {\n        logger: sindri.logger,\n        rootDirectory,\n        tag,\n        tty: true,\n      });\n      process.exit(code);\n    } catch (error) {\n      sindri.logger.error(\"Failed to run the nargo command.\");\n      sindri.logger.debug(error);\n      return process.exit(1);\n    }\n  });\n\nexport const execCommand = new Command()\n  .name(\"exec\")\n  .alias(\"x\")\n  .description(\n    \"Run a ZKP tool in your project root inside of an optimized docker container.\",\n  )\n  .passThroughOptions()\n  .option(\n    \"-l, --list-tags\",\n    \"List the available docker image tags for a given tool.\",\n  )\n  .option(\n    \"-t, --tag <tag>\",\n    \"The version tag of the docker image to use.\",\n    \"auto\",\n  )\n  .addCommand(circomspectCommand)\n  .addCommand(nargoCommand)\n  .hook(\"preAction\", async (command) => {\n    // Store the options in globals for subcommands to access them.\n    const opts = command.opts();\n    listTags = !!opts.listTags;\n    tag = opts.tag;\n\n    // Handle the `--list-tags` option.\n    if (listTags) {\n      const repository = command.args[0];\n      assert(\n        repository,\n        \"The preAction hook should only run if there's a subcommand.\",\n      );\n      try {\n        const tags = await getDockerImageTags(repository);\n        tags.forEach((tag) => print(tag));\n      } catch (error) {\n        sindri.logger.fatal(\"Error listing available docker image tags.\");\n        sindri.logger.error(error);\n        return process.exit(1);\n      }\n      return process.exit(0);\n    }\n\n    // Find the project root.\n    const cwd = process.cwd();\n    const sindriJsonPath = findFileUpwards(/^sindri.json$/i, cwd);\n    if (sindriJsonPath) {\n      rootDirectory = path.dirname(sindriJsonPath);\n    } else {\n      rootDirectory = cwd;\n      sindri.logger.warn(\n        `No \"sindri.json\" file was found in or above \"${cwd}\", ` +\n          \"using the current directory as the project root.\",\n      );\n    }\n    rootDirectory = path.normalize(path.resolve(rootDirectory));\n\n    // Check that docker is installed.\n    if (!(await checkDockerAvailability(sindri.logger))) {\n      sindri.logger.fatal(\n        \"Docker is either not installed or the daemon isn't currently running, but it is \" +\n          'required by \"sindri exec\".\\nPlease install Docker by following the instructions at: ' +\n          \"https://docs.docker.com/get-docker/\",\n      );\n      process.exit(1);\n    }\n  });\n","import assert from \"assert\";\nimport { spawn } from \"child_process\";\nimport { readdirSync, readFileSync } from \"fs\";\nimport fs from \"fs\";\nimport { mkdir, readdir, readFile, stat, writeFile } from \"fs/promises\";\nimport os from \"os\";\nimport path from \"path\";\nimport process from \"process\";\nimport { type Duplex, Writable } from \"stream\";\nimport { fileURLToPath } from \"url\";\n\nimport axios from \"axios\";\nimport { compareVersions } from \"compare-versions\";\nimport Docker from \"dockerode\";\nimport type { Schema } from \"jsonschema\";\nimport nunjucks from \"nunjucks\";\nimport type { PackageJson } from \"type-fest\";\n\nimport type { Logger } from \"lib/logging\";\n\nconst currentFilePath = fileURLToPath(import.meta.url);\nconst currentDirectoryPath = path.dirname(currentFilePath);\n\n/**\n * Checks if a given command exists in the system's PATH.\n *\n * This function attempts to spawn the command with the `--version` flag, assuming that most\n * commands will support it or at least not have side effects when it is passed.\n *\n * @param command - The name of the command to check.\n *\n * @returns A boolean indicating whether the command exists.\n */\nexport function checkCommandExists(command: string): Promise<boolean> {\n  return new Promise((resolve) => {\n    const process = spawn(command, [\"--version\"]);\n\n    process.on(\"error\", () => {\n      // Command could not be spawned or was not found in the PATH\n      resolve(false);\n    });\n\n    process.on(\"exit\", (code) => {\n      // Command exists if there are no errors or the exit code isn't 127.\n      resolve(code !== 127 && code !== null);\n    });\n  });\n}\n\n/**\n * Checks whether we can connect to the Docker daemon.\n *\n * @returns A boolean value indicating whether the Docker daemon is accessible.\n */\nexport async function checkDockerAvailability(\n  logger?: Logger,\n): Promise<boolean> {\n  const docker = new Docker();\n  try {\n    await docker.ping();\n  } catch (error) {\n    logger?.debug(\"Failed to connect to the Docker daemon.\");\n    logger?.debug(error);\n    return false;\n  }\n  logger?.debug(\"Docker daemon is accessible.\");\n  return true;\n}\n\n/**\n * Supported external commands, each must correspond to a `docker-zkp` image repository.\n */\ntype ExternalCommand = \"circomspect\" | \"nargo\";\n\n/**\n * A writable stream that discards all input.\n */\nexport const devNull = new Writable({\n  write(_chunk, _encoding, callback) {\n    callback();\n  },\n});\n\n/**\n * Executes an external command, either locally or in a Docker container.\n *\n * @param command - The command to execute, corresponds to a `docker-zkp` image.\n * @param args - The arguments to pass to the command.\n * @param options - Additional options for the command.\n * @param options.cwd - The current working directory for the executed command.\n * @param options.docker - The `Docker` instance to use for running the command. Defaults to a new\n *   `Docker` instance with default options.\n * @param options.logger - The logger to use for logging messages. There will be no logging if not\n *   specified.\n * @param options.rootDirectory - The project root directory on the host. Will be determined by\n *   searching up the directory tree for a `sindri.json` file if not specified. This directory is\n *   mounted into the Docker container at `/sindri/` if the command is executed in Docker.\n * @param options.tag - The tag of the Docker image to use. Defaults to `auto`, which will map to\n *   the `latest` tag unless a version specifier is found in `sindri.json` that supersedes it.\n * @param options.tty - Whether to use a TTY for the command. Defaults to `false` which means that\n *   the command's output will be ignored.\n *\n * @returns The exit code of the command, or `null` if the command is not available locally or in\n *   Docker.\n */\nexport async function execCommand(\n  command: ExternalCommand,\n  args: string[] = [],\n  {\n    cwd = process.cwd(),\n    docker = new Docker(),\n    logger,\n    rootDirectory,\n    tag = \"auto\",\n    tty = false,\n  }: {\n    cwd?: string;\n    docker?: Docker;\n    logger?: Logger;\n    rootDirectory?: string;\n    tag?: string;\n    tty?: boolean;\n  },\n): Promise<\n  { code: number; method: \"docker\" | \"local\" } | { code: null; method: null }\n> {\n  // Try using a local command first (unless `SINDRI_FORCE_DOCKER` is set).\n  if (isTruthy(process.env.SINDRI_FORCE_DOCKER ?? \"false\")) {\n    logger?.debug(\n      `Forcing docker usage for command \"${command}\" because \"SINDRI_FORCE_DOCKER\" is set to ` +\n        `\"${process.env.SINDRI_FORCE_DOCKER}\".`,\n    );\n  } else if (await checkCommandExists(command)) {\n    logger?.debug(`Executing the \"${command}\" command locally.`);\n    return {\n      code: await execLocalCommand(command, args, { cwd, logger, tty }),\n      method: \"local\",\n    };\n  } else {\n    logger?.debug(\n      `The \"${command}\" command was not found locally, trying Docker instead.`,\n    );\n  }\n\n  // Fall back to using Docker if possible.\n  if (await checkDockerAvailability(logger)) {\n    logger?.debug(`Executing the \"${command}\" command in a Docker container.`);\n    return {\n      code: await execDockerCommand(command, args, {\n        cwd,\n        docker,\n        logger,\n        rootDirectory,\n        tag,\n        tty,\n      }),\n      method: \"docker\",\n    };\n  }\n\n  // There's no way to run the command.\n  logger?.debug(\n    `The \"${command}\" command is not available locally or in Docker.`,\n  );\n  return { code: null, method: null };\n}\n\n/**\n * Executes an external command in a Docker container.\n *\n * @param command - The command to execute, corresponds to a `docker-zkp` image.\n * @param args - The arguments to pass to the command.\n * @param options - Additional options for the command.\n * @param options.cwd - The current working directory on the host for the executed command.\n * @param options.docker - The `Docker` instance to use for running the command. Defaults to a new\n *   `Docker` instance with default options.\n * @param options.logger - The logger to use for logging messages. There will be no logging if not\n *   specified.\n * @param options.rootDirectory - The project root directory on the host. Will be determined by\n *   searching up the directory tree for a `sindri.json` file if not specified. This directory is\n *   mounted into the Docker container at `/sindri/`.\n * @param options.tag - The tag of the Docker image to use. Defaults to `auto`, which will map to\n *   the `latest` tag unless a version specifier is found in `sindri.json` that supersedes it.\n * @param options.tty - Whether to use a TTY for the command. Defaults to `false` which means that\n *  the command's output will be ignored.\n *\n * @returns The exit code of the command.\n */\nexport async function execDockerCommand(\n  command: ExternalCommand,\n  args: string[] = [],\n  {\n    cwd = process.cwd(),\n    docker = new Docker(),\n    logger,\n    rootDirectory,\n    tag = \"auto\",\n    tty = false,\n  }: {\n    cwd?: string;\n    docker?: Docker;\n    logger?: Logger;\n    rootDirectory?: string;\n    tag?: string;\n    tty?: boolean;\n  },\n): Promise<number> {\n  // Find the project root if one wasn't specified.\n  const sindriJsonPath = findFileUpwards(/^sindri.json$/i, cwd);\n  if (!rootDirectory) {\n    if (sindriJsonPath) {\n      rootDirectory = path.dirname(sindriJsonPath);\n    } else {\n      rootDirectory = cwd;\n      logger?.warn(\n        `No \"sindri.json\" file was found in or above \"${cwd}\", ` +\n          `using the current directory as the project root.`,\n      );\n    }\n  }\n  rootDirectory = path.normalize(path.resolve(rootDirectory));\n\n  // Determine the image to use.\n  let image: string;\n  if (command === \"nargo\" && tag === \"auto\") {\n    let tag = \"latest\";\n    if (sindriJsonPath) {\n      try {\n        const sindriJsonContent = await readFile(sindriJsonPath, {\n          encoding: \"utf-8\",\n        });\n        const sindriJson = JSON.parse(sindriJsonContent);\n        if (sindriJson.noirVersion) {\n          tag = sindriJson.noirVersion;\n          if (tag && !tag.startsWith(\"v\")) {\n            tag = `v${tag}`;\n          }\n        }\n      } catch (error) {\n        logger?.error(\n          `Failed to parse the \"${sindriJsonPath}\" file, ` +\n            'using the \"latest\" tag for the \"nargo\" command.',\n        );\n        logger?.debug(error);\n      }\n    } else {\n      logger?.warn(\n        `No \"sindri.json\" file was found in or above \"${cwd}\", ` +\n          'using the \"latest\" tag for the \"nargo\" command.',\n      );\n    }\n    image = `sindrilabs/${command}:${tag}`;\n  } else if ([\"circomspect\", \"nargo\"].includes(command)) {\n    image = `sindrilabs/${command}:${tag === \"auto\" ? \"latest\" : tag}`;\n  } else {\n    throw new Error(`The command \"${command}\" is not supported.`);\n  }\n\n  // Pull the appropriate image.\n  logger?.debug(`Pulling the \"${image}\" image.`);\n  try {\n    await new Promise((resolve, reject) => {\n      docker.pull(\n        image,\n        (error: Error | null, stream: NodeJS.ReadableStream) => {\n          if (error) {\n            reject(error);\n          } else {\n            docker.modem.followProgress(stream, (error, result) =>\n              error ? reject(error) : resolve(result),\n            );\n          }\n        },\n      );\n    });\n  } catch (error) {\n    logger?.error(`Failed to pull the \"${image}\" image.`);\n    logger?.error(error);\n    return process.exit(1);\n  }\n\n  // Remap the root directory to its location on the host system when running in development mode.\n  // This is because the development container has the project root mounted at `/sindri/`, but the\n  // mounts are performed on the host system so the paths need to exist there.\n  let mountDirectory: string = rootDirectory;\n  if (process.env.SINDRI_DEVELOPMENT_HOST_ROOT) {\n    if (rootDirectory === \"/sindri\" || rootDirectory.startsWith(\"/sindri/\")) {\n      mountDirectory = rootDirectory.replace(\n        \"/sindri\",\n        process.env.SINDRI_DEVELOPMENT_HOST_ROOT,\n      );\n      logger?.debug(\n        `Remapped \"${rootDirectory}\" to \"${mountDirectory}\" for bind mount on the Docker host.`,\n      );\n    } else {\n      logger?.fatal(\n        `The root directory path \"${rootDirectory}\" must be under \"/sindri/\"` +\n          'when using \"SINDRI_DEVELOPMENT_HOST_ROOT\".',\n      );\n      return process.exit(1);\n    }\n  }\n\n  // Remap the current working directory to its location inside the container. If the user is in a\n  // subdirectory of the project root, we need to remap the current working directory to the same\n  // subdirectory inside the container.\n  const relativeCwd = path.relative(rootDirectory, cwd);\n  let internalCwd: string;\n  if (relativeCwd.startsWith(\"..\")) {\n    internalCwd = \"/sindri/\";\n    logger?.warn(\n      `The current working directory (\"${cwd}\") is not under the project root ` +\n        `(\"${rootDirectory}\"), will use the project root as the current working directory.`,\n    );\n  } else {\n    internalCwd = path.join(\"/sindri/\", relativeCwd);\n  }\n  logger?.debug(\n    `Remapped the \"${cwd}\" working directory to \"${internalCwd}\" in the Docker container.`,\n  );\n\n  // Run the command with the project root mounted and pipe the output to stdout.\n  const data: { StatusCode: number } = await new Promise((resolve, reject) => {\n    docker\n      .run(\n        image,\n        args,\n        tty ? [process.stdout, process.stderr] : devNull,\n        {\n          AttachStderr: tty,\n          AttachStdin: tty,\n          AttachStdout: tty,\n          HostConfig: {\n            Binds: [\n              // Circuit project root.\n              `${mountDirectory}:/sindri`,\n              // Shared temporary directory.\n              `/tmp/sindri/:/tmp/sindri/`,\n            ],\n          },\n          OpenStdin: tty,\n          StdinOnce: false,\n          Tty: tty,\n          WorkingDir: internalCwd,\n        },\n        (error, data) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(data);\n          }\n        },\n      )\n      .on(\"container\", (container) => {\n        if (!tty) return;\n\n        // Attach stdin/stdout/stderr if we're running in TTY mode.\n        const stream = container.attach(\n          {\n            stream: true,\n            stdin: true,\n            stdout: true,\n            stderr: true,\n          },\n          function (error: Error, stream: Duplex) {\n            if (error) {\n              reject(error);\n            }\n\n            // Connect stdin and stdout.\n            // Note that stderr is redirected into stdout because this is the normal TTY behavior.\n            stream.pipe(process.stdout);\n          },\n        );\n\n        // Ensure the stream is resumed because streams start paused.\n        if (stream) {\n          stream.resume();\n        }\n      });\n  });\n  return data.StatusCode;\n}\n\n/**\n * Executes a command locally.\n *\n * @param command - The command to execute.\n * @param args - The arguments to pass to the command.\n * @param options - Additional options for the command.\n * @param options.cwd - The current working directory for the executed command.\n * @param options.logger - The logger to use for logging messages. There will be no logging if not\n *  specified.\n * @param options.tty - Whether to use a TTY for the command. Defaults to `false` which means that\n *  the command's output will be ignored.\n *\n * @returns The exit code of the command.\n */\nexport async function execLocalCommand(\n  command: ExternalCommand,\n  args: string[] = [],\n  {\n    cwd = process.cwd(),\n    logger,\n    tty = false,\n  }: {\n    cwd?: string;\n    logger?: Logger;\n    tty?: boolean;\n  },\n): Promise<number> {\n  const child = spawn(command, args, {\n    cwd,\n    stdio: tty ? \"inherit\" : \"ignore\",\n  });\n  try {\n    const code: number = await new Promise((resolve, reject) => {\n      child.on(\"error\", (error) => {\n        reject(error);\n      });\n      child.on(\"close\", (code, signal) => {\n        // If the command exits with a signal (e.g. `SIGABRT`), then follow the common convention of\n        // mapping this to an exit code of: 128 + (the signal number).\n        if (code == null && signal != null) {\n          code = 128 + os.constants.signals[signal];\n        }\n        assert(code != null);\n        resolve(code);\n      });\n    });\n    return code;\n  } catch (error) {\n    logger?.error(`Failed to execute the \"${command}\" command.`);\n    logger?.error(error);\n    return process.exit(1);\n  }\n}\n\n/**\n * Checks whether or not a file (including directories) exists.\n *\n * @param filePath - The path of the file to check.\n * @returns A boolean value indicating whether the file path exists.\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    // Note that pkg has some bugs around `fs` function calls, so we can't use `access()` here.\n    // See: https://github.com/vercel/pkg/issues/2020\n    await fs.promises.stat(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Recursively searches for a file in the given directory and its parent directories.\n *\n * @param filename - The name or regular expression of the file to find.\n * @param initialDirectory - The directory to start the search in.\n * @returns The fully qualified path of the first file found, or `null` if none is found.\n */\nexport function findFileUpwards(\n  filename: string | RegExp,\n  initialDirectory: string = currentDirectoryPath,\n): string | null {\n  // List files in the current directory.\n  const files = readdirSync(initialDirectory);\n\n  // Check if any file matches the filename.\n  for (const file of files) {\n    if (\n      typeof filename === \"string\" ? file === filename : filename.test(file)\n    ) {\n      return path.join(initialDirectory, file);\n    }\n  }\n\n  // If the parent directory is the same as the current, we've reached the root.\n  const parentDirectory = path.dirname(initialDirectory);\n  if (parentDirectory === initialDirectory) {\n    return null;\n  }\n\n  // Recursively search in the parent directory.\n  return findFileUpwards(filename, parentDirectory);\n}\n\n/**\n * Retrieves the available tags for a Docker image from DockerHub, ordered from oldest to newest.\n *\n * @param repository - The name of the Docker image repository.\n * @param username - The DockerHub username of the repository owner (default: \"sindrilabs\").\n *\n * @returns An array of available tags for the Docker image.\n */\nexport async function getDockerImageTags(\n  repository: string,\n  username: string = \"sindrilabs\",\n): Promise<string[]> {\n  let url: string | undefined =\n    `https://hub.docker.com/v2/repositories/${username}/${repository}/tags/?page_size=1`;\n  interface Result {\n    last_updated: string;\n    name: string;\n    tag_status: string;\n  }\n  interface Response {\n    count: number;\n    next?: string;\n    previous: string | null;\n    results: Result[];\n  }\n  let results: Result[] = [];\n\n  while (url) {\n    const response: { data: Response } = await axios.get<Response>(url);\n\n    results = results.concat(response.data.results);\n    url = response.data.next; // Update the URL for the next request, or null if no more pages\n  }\n\n  return results\n    .filter(({ tag_status }) => tag_status === \"active\")\n    .filter(({ name }) => name !== \"dev\")\n    .sort((a, b) => a.last_updated.localeCompare(b.last_updated))\n    .map(({ name }) => name)\n    .sort((a, b) =>\n      a === \"latest\" ? 1 : b === \"latest\" ? -1 : compareVersions(a, b),\n    );\n}\n\n/**\n * Determines if a string represents a truthy value.\n *\n * @param {string} str - The string to check for truthiness.\n *\n * @returns {boolean} `true` if the string represents a truthy value, otherwise `false`.\n */\nexport function isTruthy(str: string): boolean {\n  const truthyValues = [\"1\", \"true\", \"t\", \"yes\", \"y\", \"on\"];\n  return truthyValues.includes(str.toLowerCase());\n}\n\n/**\n * Loads the project's `package.json` file.\n *\n * @returns The contents of `package.json`.\n */\nexport function loadPackageJson(): PackageJson {\n  const packageJsonPath = locatePackageJson();\n  const packageJsonContent = readFileSync(packageJsonPath, {\n    encoding: \"utf-8\",\n  });\n  const packageJson: PackageJson = JSON.parse(packageJsonContent);\n  return packageJson;\n}\n\n/**\n * Loads the project's `sindri-manifest.json` file.\n *\n * @returns The contents of `sindri-manifest.json`.\n */\nexport function loadSindriManifestJsonSchema(): Schema {\n  const sindriManifestJsonPath = findFileUpwards(\"sindri-manifest.json\");\n  if (!sindriManifestJsonPath) {\n    throw new Error(\n      \"A `sindri-manifest.json` file was unexpectedly not found.\",\n    );\n  }\n  const sindriManifestJsonContent = readFileSync(sindriManifestJsonPath, {\n    encoding: \"utf-8\",\n  });\n  const sindriManifestJson: Schema = JSON.parse(sindriManifestJsonContent);\n  return sindriManifestJson;\n}\n\n/**\n * Locates the project's `package.json` file.\n *\n * @returns The fully qualified path to `package.json`.\n */\nexport function locatePackageJson(): string {\n  const packageJsonPath = findFileUpwards(\"package.json\");\n  if (!packageJsonPath) {\n    throw new Error(\"A `package.json` file was unexpectedly not found.\");\n  }\n  return packageJsonPath;\n}\n\n/**\n * Recursively copies and populates the contents of a template directory into an output directory.\n *\n * @param templateDirectory - The path to the template directory. Can be an absolute path or a\n *     subdirectory of the `templates/` directory in the project root.\n * @param outputDirectory - The path to the output directory where the populated templates will be\n *     written.\n * @param context - The nunjucks template context.\n * @param logger - The logger to use for debug messages.\n */\nexport async function scaffoldDirectory(\n  templateDirectory: string,\n  outputDirectory: string,\n  context: object,\n  logger?: Logger,\n): Promise<void> {\n  // Normalize the paths and create the output directory if necessary.\n  const fullOutputDirectory = path.resolve(outputDirectory);\n  if (!(await fileExists(fullOutputDirectory))) {\n    await mkdir(fullOutputDirectory, { recursive: true });\n  }\n  const rootTemplateDirectory = findFileUpwards(\"templates\");\n  if (!rootTemplateDirectory) {\n    throw new Error(\"Root template directory not found.\");\n  }\n  const fullTemplateDirectory = path.isAbsolute(templateDirectory)\n    ? templateDirectory\n    : path.resolve(rootTemplateDirectory, templateDirectory);\n  if (!(await fileExists(fullTemplateDirectory))) {\n    throw new Error(`The \"${fullTemplateDirectory}\" directory does not exist.`);\n  }\n\n  // Render a template using two syntaxes:\n  // * hacky `templateVARIABLENAME` syntax.\n  // * `nunjucks` template syntax.\n  const render = (content: string, context: object): string => {\n    let newContent = content;\n    // Poor man's templating with `templateVARIABLENAME`:\n    Object.entries(context).forEach(([key, value]) => {\n      if (typeof value !== \"string\") return;\n      newContent = newContent.replace(\n        new RegExp(`template${key.toUpperCase()}`, \"gi\"),\n        value,\n      );\n    });\n    // Real templating:\n    return nunjucks.renderString(newContent, context);\n  };\n\n  // Process the template directory recursively.\n  const processPath = async (\n    inputPath: string,\n    outputPath: string,\n  ): Promise<void> => {\n    // Handle directories.\n    if ((await stat(inputPath)).isDirectory()) {\n      // Ensure the output directory exists.\n      if (!(await fileExists(outputPath))) {\n        await mkdir(outputPath, { recursive: true });\n        logger?.debug(`Created directory: \"${outputPath}\"`);\n      }\n      if (!(await stat(outputPath)).isDirectory()) {\n        throw new Error(`\"File ${outputPath} exists and is not a directory.`);\n      }\n\n      // Process all files in the directory.\n      const files = await readdir(inputPath);\n      await Promise.all(\n        files.map(async (file) => {\n          // Render the filename so that `outputPath` always corresponds to the true output path.\n          // This handles situations like `{{ circuitName }}.go` where there's a variable in the name.\n          const populatedFile = render(file, context);\n          await processPath(\n            path.join(inputPath, file),\n            path.join(outputPath, populatedFile),\n          );\n        }),\n      );\n      return;\n    }\n\n    // Handle files, rendering them and writing them out.\n    const template = await readFile(inputPath, { encoding: \"utf-8\" });\n    const renderedTemplate = render(template, context);\n    await writeFile(outputPath, renderedTemplate, { encoding: \"utf-8\" });\n    logger?.debug(`Rendered \"${inputPath}\" template to \"${outputPath}\".`);\n  };\n  await processPath(fullTemplateDirectory, fullOutputDirectory);\n}\n","import { execSync } from \"child_process\";\nimport { existsSync, mkdirSync, readdirSync, rmSync, statSync } from \"fs\";\nimport path from \"path\";\nimport process from \"process\";\n\nimport { Command } from \"@commander-js/extra-typings\";\nimport { confirm, input, select } from \"@inquirer/prompts\";\n\nimport { scaffoldDirectory } from \"cli/utils\";\nimport sindri from \"lib\";\n\nexport const initCommand = new Command()\n  .name(\"init\")\n  .description(\"Initialize a new Sindri project.\")\n  .argument(\n    \"[directory]\",\n    \"The directory where the new project should be initialized.\",\n    \".\",\n  )\n  .action(async (directory) => {\n    // Prepare the directory paths.\n    const directoryPath = path.resolve(directory);\n    const directoryName = path.basename(directoryPath);\n\n    // Ensure that the directory exists.\n    if (!existsSync(directoryPath)) {\n      mkdirSync(directoryPath, { recursive: true });\n    } else if (!statSync(directoryPath).isDirectory()) {\n      sindri.logger.warn(\n        `File \"${directoryPath}\" exists and is not a directory, aborting.`,\n      );\n      return process.exit(1);\n    }\n\n    // Check that the directory is empty.\n    const existingFiles = readdirSync(directoryPath);\n    if (existingFiles.length > 0) {\n      const proceed = await confirm({\n        message:\n          `The \"${directoryPath}\" directory already exists and contains files. Continuing will ` +\n          \"overwrite your existing files. Are you *SURE* you would like to proceed?\",\n        default: false,\n      });\n      if (!proceed) {\n        sindri.logger.info(\"Aborting.\");\n        return process.exit(1);\n      }\n    }\n\n    // Collect common fields.\n    const circuitName = await input({\n      message: \"Circuit Name:\",\n      default: directoryName.replace(/[^-a-zA-Z0-9_]/g, \"-\"),\n      validate: (input): boolean | string => {\n        if (input.length === 0) {\n          return \"You must specify a circuit name.\";\n        }\n        if (!/^[-a-zA-Z0-9_]+$/.test(input)) {\n          return \"Only alphanumeric characters, hyphens, and underscores are allowed.\";\n        }\n        return true;\n      },\n    });\n    const circuitType: \"circom\" | \"gnark\" | \"halo2\" | \"noir\" = await select({\n      message: \"Proving Framework:\",\n      default: \"circom\",\n      choices: [\n        { name: \"Circom\", value: \"circom\" },\n        { name: \"Gnark\", value: \"gnark\" },\n        { name: \"Halo2\", value: \"halo2\" },\n        { name: \"Noir\", value: \"noir\" },\n      ],\n    });\n    const context: object = { circuitName, circuitType };\n\n    // Handle individual circuit types.\n    if (circuitType === \"circom\") {\n      // Circom.\n      const provingScheme: \"groth16\" = await select({\n        message: \"Proving Scheme:\",\n        default: \"groth16\",\n        choices: [{ name: \"Groth16\", value: \"groth16\" }],\n      });\n      const curveName: \"bn254\" = await select({\n        message: \"Curve Name:\",\n        default: \"bn254\",\n        choices: [{ name: \"BN254\", value: \"bn254\" }],\n      });\n      const witnessCompiler: \"c++\" | \"wasm\" = await select({\n        message: \"Witness Compiler:\",\n        default: \"c++\",\n        choices: [\n          { name: \"C++\", value: \"c++\" },\n          { name: \"Wasm\", value: \"wasm\" },\n        ],\n      });\n      Object.assign(context, {\n        curveName,\n        provingScheme,\n        witnessCompiler,\n      });\n    } else if (circuitType === \"gnark\") {\n      // Gnark.\n      const packageName = await input({\n        message: \"Go Package Name:\",\n        default: circuitName\n          .replace(/[^a-zA-Z0-9]/g, \"\")\n          .replace(/^[^a-z]*/g, \"\"),\n        validate: (input): boolean | string => {\n          if (input.length === 0) {\n            return \"You must specify a package name.\";\n          }\n          if (!/^[a-z][a-z0-9]*$/.test(input)) {\n            return (\n              \"Package names must begin with a lowercase letter and only be followed by \" +\n              \"alphanumeric characters.\"\n            );\n          }\n          return true;\n        },\n      });\n      const provingScheme: \"groth16\" = await select({\n        message: \"Proving Scheme:\",\n        default: \"groth16\",\n        choices: [{ name: \"Groth16\", value: \"groth16\" }],\n      });\n      const curveName:\n        | \"bn254\"\n        | \"bls12-377\"\n        | \"bls12-381\"\n        | \"bls24-315\"\n        | \"bw6-633\"\n        | \"bw6-761\" = await select({\n        message: \"Curve Name:\",\n        default: \"bn254\",\n        choices: [\n          { name: \"BN254\", value: \"bn254\" },\n          { name: \"BLS12-377\", value: \"bls12-377\" },\n          { name: \"BLS12-381\", value: \"bls12-381\" },\n          { name: \"BLS24-315\", value: \"bls24-315\" },\n          { name: \"BW6-633\", value: \"bw6-633\" },\n          { name: \"BW6-761\", value: \"bw6-761\" },\n        ],\n      });\n      const gnarkCurveName = curveName.toUpperCase().replace(\"-\", \"_\");\n      Object.assign(context, {\n        curveName,\n        gnarkCurveName,\n        packageName,\n        provingScheme,\n      });\n    } else if (circuitType === \"halo2\") {\n      // Halo2.\n      const packageName = await input({\n        message: \"Halo2 Package Name:\",\n        default: circuitName\n          .toLowerCase()\n          .replace(/^[^a-z0-9_]+/, \"_\")\n          .replace(/_+/g, \"_\")\n          .replace(/-+/g, \"-\"),\n        validate: (input): boolean | string => {\n          if (input.length === 0) {\n            return \"You must specify a package name.\";\n          }\n          if (!/^[a-z0-9_]+(?:-[a-z0-9_]+)*$/.test(input)) {\n            return (\n              \"Package names must begin with a lowercase letter, number, or underscore, and only \" +\n              \"be followed by lowercase or numeric characters and underscores (optionally \" +\n              \"separated hyphens).\"\n            );\n          }\n          return true;\n        },\n      });\n      const halo2Version: \"axiom-v0.3.0\" = await select({\n        message: \"Halo2 Base Version:\",\n        default: \"axiom-v0.3.0\",\n        choices: [{ name: \"Axiom v0.3.0\", value: \"axiom-v0.3.0\" }],\n      });\n      const threadBuilder: \"GateThreadBuilder\" | undefined =\n        halo2Version !== \"axiom-v0.3.0\"\n          ? undefined\n          : await select({\n              message: \"Halo2 Base Version:\",\n              default: \"GateThreadBuilder\",\n              choices: [\n                { name: \"Gate Thread Builder\", value: \"GateThreadBuilder\" },\n              ],\n            });\n      // Collect `degree` as a positive integer.\n      const degree: number = parseInt(\n        await input({\n          message: \"Degree:\",\n          default: \"13\",\n          validate: (input): boolean | string => {\n            if (input.length === 0) {\n              return \"You must specify a degree.\";\n            }\n            if (!/^[1-9]\\d*$/.test(input)) {\n              return \"Degree must be a positive integer.\";\n            }\n            return true;\n          },\n        }),\n        10,\n      );\n\n      // Replace hyphens with underscores in the package name.\n      const className = `${packageName.replace(\n        /-/g,\n        \"_\",\n      )}::circuit_def::CircuitInput`;\n\n      Object.assign(context, {\n        className,\n        halo2Version,\n        degree,\n        packageName,\n        threadBuilder,\n      });\n    } else if (circuitType === \"noir\") {\n      const packageName = await input({\n        message: \"Noir Package Name:\",\n        default: circuitName\n          .toLowerCase()\n          .replace(/[- ]/g, \"_\")\n          .replace(/[^a-zA-Z0-9_]+/, \"\")\n          .replace(/_+/g, \"_\"),\n        validate: (input): boolean | string => {\n          if (input.length === 0) {\n            return \"You must specify a package name.\";\n          }\n          if (!/^[a-zA-Z0-9_]+$/.test(input)) {\n            return \"Package names must only contain alphanumeric characters and underscores.\";\n          }\n          return true;\n        },\n      });\n      const noirVersion: \"0.17.0\" | \"0.18.0\" | \"0.19.4\" | \"0.22.0\" | \"0.23.0\" =\n        await select({\n          message: \"Noir Version:\",\n          default: \"0.23.0\",\n          choices: [\n            { name: \"0.17.0\", value: \"0.17.0\" },\n            { name: \"0.18.0\", value: \"0.18.0\" },\n            { name: \"0.19.4\", value: \"0.19.4\" },\n            { name: \"0.22.0\", value: \"0.22.0\" },\n            { name: \"0.23.0\", value: \"0.23.0\" },\n          ],\n        });\n      const provingScheme: \"barretenberg\" = await select({\n        message: \"Proving Scheme:\",\n        default: \"barretenberg\",\n        choices: [{ name: \"Barretenberg\", value: \"barretenberg\" }],\n      });\n      Object.assign(context, {\n        packageName,\n        noirVersion,\n        provingScheme,\n      });\n    } else {\n      sindri.logger.fatal(`Sorry, ${circuitType} is not yet supported.`);\n      return process.exit(1);\n    }\n\n    // Perform the scaffolding.\n    sindri.logger.info(\n      `Proceeding to generate scaffolded project in \"${directoryPath}\".`,\n    );\n    await scaffoldDirectory(\"common\", directoryPath, context, sindri.logger);\n    await scaffoldDirectory(circuitType, directoryPath, context, sindri.logger);\n    // We use this in `common` right now to keep the directory tracked, we can remove this once we\n    // add files there.\n    const gitKeepFile = path.join(directoryPath, \".gitkeep\");\n    if (existsSync(gitKeepFile)) {\n      rmSync(gitKeepFile);\n    }\n    sindri.logger.info(\"Project scaffolding successful.\");\n\n    // Install dependencies.\n    if (circuitType === \"circom\") {\n      let npmInstalled: boolean = false;\n      try {\n        execSync(\"npm --version\");\n        npmInstalled = true;\n      } catch {\n        sindri.logger.warn(\n          \"NPM is not installed, cannot install circomlib as a dependency. \" +\n            \"You will need to install NPM and run `npm install` yourself.\",\n        );\n      }\n      if (npmInstalled) {\n        sindri.logger.info(\"Installing circomlib.\");\n        execSync(\"npm install\", { cwd: directoryPath });\n      }\n    }\n\n    // Optionally, initialize a git repository.\n    let gitInstalled: boolean = false;\n    try {\n      execSync(\"git --version\");\n      gitInstalled = true;\n    } catch {\n      sindri.logger.debug(\n        \"Git is not installed, skipping git initialization questions.\",\n      );\n    }\n    const gitAlreadyInitialized = existsSync(path.join(directoryPath, \".git\"));\n    if (gitInstalled && !gitAlreadyInitialized) {\n      const initializeGit = await confirm({\n        message: `Would you like to initialize a git repository in \"${directoryPath}\"?`,\n        default: true,\n      });\n      if (initializeGit) {\n        sindri.logger.info(\n          `Initializing git repository in \"${directoryPath}\".`,\n        );\n        try {\n          execSync(\"git init .\", { cwd: directoryPath });\n          execSync(\"git add .\", { cwd: directoryPath });\n          execSync(\"git commit -m 'Initial commit.'\", { cwd: directoryPath });\n          sindri.logger.info(\"Successfully initialized git repository.\");\n        } catch (error) {\n          sindri.logger.error(\n            \"Error occurred while initializing the git repository.\",\n          );\n          // Node.js doesn't seem to have a typed version of this error, so we assert it as\n          // something that's at least in the right ballpark.\n          const execError = error as NodeJS.ErrnoException & {\n            output: Buffer | string;\n            stderr: Buffer | string;\n            stdout: Buffer | string;\n          };\n          // The output is a really long list of numbers because it's a buffer, so truncate it.\n          const noisyKeys: Array<\"output\" | \"stderr\" | \"stdout\"> = [\n            \"output\",\n            \"stderr\",\n            \"stdout\",\n          ];\n          noisyKeys.forEach((key) => {\n            if (key in execError) {\n              execError[key] = \"<truncated>\";\n            }\n          });\n          sindri.logger.error(execError);\n        }\n      }\n    }\n  });\n","import { Blob } from \"buffer\";\nimport { existsSync, readFileSync } from \"fs\";\nimport path from \"path\";\nimport process from \"process\";\n\nimport { Command } from \"@commander-js/extra-typings\";\nimport { FormData } from \"formdata-node\";\nimport walk from \"ignore-walk\";\nimport tar from \"tar\";\n\nimport { findFileUpwards } from \"cli/utils\";\nimport sindri from \"lib\";\nimport { ApiError } from \"lib/api\";\n\nexport const deployCommand = new Command()\n  .name(\"deploy\")\n  .description(\"Deploy the current Sindri project.\")\n  .option(\"-t, --tag <tag...>\", \"Tag to apply to the circuit.\", [\"latest\"])\n  .option(\"-u, --untagged\", \"Discard the current circuit after compiling.\")\n  .argument(\"[directory]\", \"The location of the Sindri project to deploy.\", \".\")\n  .action(async (directory, { tag: tags, untagged }) => {\n    // Validate the tags and \"untagged\" option.\n    if (untagged) {\n      if (tags.length !== 1 || tags[0] !== \"latest\") {\n        sindri.logger.error(\n          \"You cannot use both the `--tag` and `--untagged` options together.\",\n        );\n        return process.exit(1);\n      }\n    } else {\n      for (const tag of tags) {\n        if (!/^[-a-zA-Z0-9_.]+$/.test(tag)) {\n          sindri.logger.error(\n            `\"${tag}\" is not a valid tag. Tags may only contain alphanumeric characters, ` +\n              \"underscores, hyphens, and periods.\",\n          );\n          return process.exit(1);\n        }\n      }\n    }\n\n    // Find `sindri.json` and move into the root of the project directory.\n    const directoryPath = path.resolve(directory);\n    if (!existsSync(directoryPath)) {\n      sindri.logger.error(\n        `The \"${directoryPath}\" directory does not exist. Aborting.`,\n      );\n      return process.exit(1);\n    }\n    const sindriJsonPath = findFileUpwards(/^sindri.json$/i, directoryPath);\n    if (!sindriJsonPath) {\n      sindri.logger.error(\n        `No \"sindri.json\" file was found in or above \"${directoryPath}\". Aborting.`,\n      );\n      return process.exit(1);\n    }\n    sindri.logger.debug(`Found \"sindri.json\" at \"${sindriJsonPath}\".`);\n    const rootDirectory = path.dirname(sindriJsonPath);\n    sindri.logger.debug(`Changing current directory to \"${rootDirectory}\".`);\n    process.chdir(rootDirectory);\n\n    // Load `sindri.json`.\n    let sindriJson: object = {};\n    try {\n      const sindriJsonContent = readFileSync(sindriJsonPath, {\n        encoding: \"utf-8\",\n      });\n      sindriJson = JSON.parse(sindriJsonContent);\n      sindri.logger.debug(\n        `Successfully loaded \"sindri.json\" from \"${sindriJsonPath}\":`,\n      );\n      sindri.logger.debug(sindriJson);\n    } catch (error) {\n      sindri.logger.fatal(\n        `Error loading \"${sindriJsonPath}\", perhaps it is not valid JSON?`,\n      );\n      sindri.logger.error(error);\n      return process.exit(1);\n    }\n    if (!(\"name\" in sindriJson)) {\n      sindri.logger.error('No \"name\" field found in \"sindri.json\". Aborting.');\n      return process.exit(1);\n    }\n    const circuitName = sindriJson.name;\n\n    // Check that the API client is authorized.\n    if (!sindri.apiKey || !sindri.baseUrl) {\n      sindri.logger.warn(\"You must login first with `sindri login`.\");\n      return process.exit(1);\n    }\n\n    // Create a project tarball and prepare the form data for upload.\n    const files = walk\n      .sync({\n        follow: true,\n        ignoreFiles: [\".sindriignore\"],\n        path: \".\",\n      })\n      .filter(\n        (file) =>\n          // Always exclude `.git` subdirectories.\n          !/(^|\\/)\\.git(\\/|$)/.test(file),\n      );\n    // Always include the `sindri.json` file.\n    const sindriJsonFilename = path.basename(sindriJsonPath);\n    if (!files.includes(sindriJsonFilename)) {\n      files.push(sindriJsonFilename);\n    }\n    const formData = new FormData();\n    const tarballFilename = `${circuitName}.tar.gz`;\n    sindri.logger.info(\n      `Creating \"${tarballFilename}\" package with ${files.length} files.`,\n    );\n    formData.append(\n      \"files\",\n      new Blob([\n        tar\n          .c(\n            {\n              gzip: true,\n              onwarn: (code: string, message: string) => {\n                sindri.logger.warn(\n                  `While creating tarball: ${code} - ${message}`,\n                );\n              },\n              prefix: `${circuitName}/`,\n              sync: true,\n            },\n            files,\n          )\n          // @ts-expect-error - @types/tar doesn't handle the `sync` option correctly.\n          .read(),\n      ]),\n      tarballFilename,\n    );\n\n    // Attach the tags to the form data.\n    if (untagged) {\n      formData.append(\"tags\", \"\");\n    } else {\n      for (const tag of tags) {\n        formData.append(\"tags\", tag);\n      }\n    }\n\n    // Upload the tarball.\n    let circuitId: string | undefined;\n    try {\n      sindri.logger.info(\"Circuit compilation initiated.\");\n      const response = await sindri._client.circuits.circuitCreate(formData);\n      circuitId = response.circuit_id;\n    } catch (error) {\n      if (error instanceof ApiError && error.status === 401) {\n        sindri.logger.error(\n          \"Your credentials are invalid. Please log in again with `sindri login`.\",\n        );\n      } else {\n        sindri.logger.fatal(\"An unknown error occurred.\");\n        sindri.logger.error(error);\n        return process.exit(1);\n      }\n    }\n    if (!circuitId) {\n      sindri.logger.error(\"No circuit ID was returned from the API. Aborting.\");\n      return process.exit(1);\n    }\n\n    // Poll for circuit compilation to complete.\n    const startTime = Date.now();\n    while (true) {\n      try {\n        sindri.logger.debug(\"Polling for circuit compilation status.\");\n        const response = await sindri._client.circuits.circuitDetail(\n          circuitId,\n          false,\n        );\n\n        const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);\n        if (response.status === \"Ready\") {\n          sindri.logger.info(\n            `Circuit compiled successfully after ${elapsedSeconds} seconds.`,\n          );\n          break;\n        } else if (response.status === \"Failed\") {\n          sindri.logger.error(\n            `Circuit compilation failed after ${elapsedSeconds} seconds: ` +\n              (response.error ?? \"Unknown error.\"),\n          );\n          return process.exit(1);\n        } else if (response.status === \"Queued\") {\n          sindri.logger.debug(\"Circuit compilation is queued.\");\n        } else if (response.status === \"In Progress\") {\n          sindri.logger.debug(\"Circuit compilation is in progress.\");\n        }\n      } catch (error) {\n        sindri.logger.fatal(\n          \"An unknown error occurred while polling for compilation to finish.\",\n        );\n        sindri.logger.error(error);\n        return process.exit(1);\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n  });\n","import assert from \"assert\";\nimport { randomUUID } from \"crypto\";\nimport { existsSync, readFileSync, unlinkSync } from \"fs\";\nimport path from \"path\";\nimport process from \"process\";\n\nimport { Command } from \"@commander-js/extra-typings\";\nimport type { Schema } from \"jsonschema\";\nimport { Validator as JsonValidator } from \"jsonschema\";\nimport type { Log as SarifLog, Result as SarifResult } from \"sarif\";\n\nimport {\n  execCommand,\n  findFileUpwards,\n  loadSindriManifestJsonSchema,\n} from \"cli/utils\";\nimport sindri from \"lib\";\n\nexport const lintCommand = new Command()\n  .name(\"lint\")\n  .description(\"Lint the current Sindri project for potential issues.\")\n  .argument(\n    \"[directory]\",\n    \"The directory, or subdirectory, of the project to lint.\",\n    \".\",\n  )\n  .action(async (directory) => {\n    // Track the error and warning counts as we go.\n    let errorCount: number = 0;\n    let warningCount: number = 0;\n\n    // Load the Sindri Manifest JSON Schema.\n    let sindriManifestJsonSchema: Schema | undefined;\n    try {\n      sindriManifestJsonSchema = loadSindriManifestJsonSchema();\n      if (!sindriManifestJsonSchema) {\n        throw new Error('No \"sindri-manifest.json\" file found.');\n      }\n      sindri.logger.debug('Successfully loaded \"sindri-manifest.json\".');\n    } catch (error) {\n      sindri.logger.error(\n        'No \"sindri-manifest.json\" JSON Schema file found. Aborting.',\n      );\n      return process.exit(1);\n    }\n\n    // Find `sindri.json` and move into the root of the project directory.\n    const directoryPath = path.resolve(directory);\n    if (!existsSync(directoryPath)) {\n      sindri.logger.error(\n        `The \"${directoryPath}\" directory does not exist. Aborting.`,\n      );\n      return process.exit(1);\n    }\n    const sindriJsonPath = findFileUpwards(/^sindri.json$/i, directoryPath);\n    if (!sindriJsonPath) {\n      sindri.logger.error(\n        `No \"sindri.json\" file was found in or above \"${directoryPath}\". Aborting.`,\n      );\n      return process.exit(1);\n    }\n    sindri.logger.debug(`Found \"sindri.json\" at \"${sindriJsonPath}\".`);\n    const rootDirectory = path.dirname(sindriJsonPath);\n    sindri.logger.debug(`Changing current directory to \"${rootDirectory}\".`);\n    process.chdir(directoryPath);\n\n    // Load `sindri.json`.\n    let sindriJson: object = {};\n    try {\n      const sindriJsonContent = readFileSync(sindriJsonPath, {\n        encoding: \"utf-8\",\n      });\n      sindriJson = JSON.parse(sindriJsonContent);\n      sindri.logger.debug(\n        `Successfully loaded \"sindri.json\" from \"${sindriJsonPath}\":`,\n      );\n      sindri.logger.debug(sindriJson);\n    } catch (error) {\n      sindri.logger.fatal(\n        `Error loading \"${sindriJsonPath}\", perhaps it is not valid JSON?`,\n      );\n      sindri.logger.error(error);\n      return process.exit(1);\n    }\n\n    // Determine the circuit type and manually discriminate the subschema type to narrow down the\n    // schema so that the user gets more relevant validation errors.\n    assert(Array.isArray(sindriManifestJsonSchema.anyOf));\n    let subSchema: Schema | undefined;\n    if (!(\"circuitType\" in sindriJson) || !sindriJson.circuitType) {\n      subSchema = undefined;\n    } else if (sindriJson.circuitType === \"circom\") {\n      subSchema = sindriManifestJsonSchema.anyOf.find((option: Schema) =>\n        /circom/i.test(option[\"$ref\"] ?? \"\"),\n      );\n    } else if (sindriJson.circuitType === \"gnark\") {\n      subSchema = sindriManifestJsonSchema.anyOf.find((option: Schema) =>\n        /gnark/i.test(option[\"$ref\"] ?? \"\"),\n      );\n    } else if (sindriJson.circuitType === \"halo2\") {\n      if (\n        \"halo2Version\" in sindriJson &&\n        sindriJson.halo2Version === \"axiom-v0.2.2\"\n      ) {\n        subSchema = sindriManifestJsonSchema.anyOf.find((option: Schema) =>\n          /halo2axiomv022/i.test(option[\"$ref\"] ?? \"\"),\n        );\n      } else if (\n        \"halo2Version\" in sindriJson &&\n        sindriJson.halo2Version === \"axiom-v0.3.0\"\n      ) {\n        subSchema = sindriManifestJsonSchema.anyOf.find((option: Schema) =>\n          /halo2axiomv030/i.test(option[\"$ref\"] ?? \"\"),\n        );\n      } else {\n        // We can't discriminate the different halo2 manifests if there's not a valid `halo2Version`\n        // so we'll just filter down the `anyOf` to the halo2 manifests instead of picking one.\n        subSchema = {\n          anyOf: sindriManifestJsonSchema.anyOf.filter((option: Schema) =>\n            /halo2/i.test(option[\"$ref\"] ?? \"\"),\n          ),\n        };\n      }\n    } else if (sindriJson.circuitType === \"noir\") {\n      subSchema = sindriManifestJsonSchema.anyOf.find((option: Schema) =>\n        /noir/i.test(option[\"$ref\"] ?? \"\"),\n      );\n    }\n    if (subSchema) {\n      delete sindriManifestJsonSchema.anyOf;\n      sindriManifestJsonSchema = { ...sindriManifestJsonSchema, ...subSchema };\n    } else {\n      sindri.logger.warn(\n        `Circuit type is not configured in \"${sindriJsonPath}\" so some linting steps will be ` +\n          \"skipped and the manifest linting output will be very noisy. Please correct \" +\n          '\"circuiType\" in \"sindri.json\" and rerun \"sindri lint\" to get better linting.',\n      );\n      warningCount += 1;\n    }\n    const circuitType: \"circom\" | \"gnark\" | \"halo2\" | \"noir\" | null =\n      \"circuitType\" in sindriJson &&\n      typeof sindriJson.circuitType === \"string\" &&\n      [\"circom\", \"gnark\", \"halo2\", \"noir\"].includes(sindriJson.circuitType)\n        ? (sindriJson.circuitType as \"circom\" | \"gnark\" | \"halo2\" | \"noir\")\n        : null;\n    if (circuitType) {\n      sindri.logger.debug(`Detected circuit type \"${circuitType}\".`);\n    } else {\n      sindri.logger.debug(\"No circuit type detected!\");\n    }\n\n    // Validate `sindri.json`.\n    const manifestValidator = new JsonValidator();\n    const validationStatus = manifestValidator.validate(\n      sindriJson,\n      sindriManifestJsonSchema,\n      { nestedErrors: true },\n    );\n    if (validationStatus.valid) {\n      sindri.logger.info(`Sindri manifest file \"${sindriJsonPath}\" is valid.`);\n    } else {\n      sindri.logger.warn(\n        `Sindri manifest file \"${sindriJsonPath}\" contains errors:`,\n      );\n      for (const error of validationStatus.errors) {\n        const prefix =\n          error.property\n            .replace(/^instance/, \"sindri.json\")\n            .replace(/\\./g, \":\") +\n          (typeof error.schema === \"object\" && error.schema.title\n            ? `:${error.schema.title}`\n            : \"\");\n        sindri.logger.error(`${prefix} ${error.message}`);\n        errorCount += 1;\n      }\n    }\n\n    // Check for a project README.\n    const readmePath = path.join(rootDirectory, \"README.md\");\n    if (!existsSync(readmePath)) {\n      sindri.logger.warn(\n        `No project README was found at \"${readmePath}\", consider adding one.`,\n      );\n      warningCount += 1;\n    } else {\n      sindri.logger.debug(`README file found at \"${readmePath}\".`);\n    }\n\n    // Run Circomspect for Circom circuits.\n    if (circuitType === \"circom\") {\n      try {\n        // Run Circomspect and parse the results.\n        sindri.logger.info(\n          \"Running static analysis with Circomspect by Trail of Bits...\",\n        );\n        const sarifFile = path.join(\n          \"/\",\n          \"tmp\",\n          \"sindri\",\n          `circomspect-${randomUUID()}.sarif`,\n        );\n        let sarif: SarifLog | undefined;\n        let ranInDocker: boolean;\n        try {\n          const circuitPath: string =\n            \"circuitPath\" in sindriJson && sindriJson.circuitPath\n              ? (sindriJson.circuitPath as string)\n              : \"circuit.circom\";\n          const { method } = await execCommand(\n            \"circomspect\",\n            [\"--level\", \"INFO\", \"--sarif-file\", sarifFile, circuitPath],\n            {\n              cwd: rootDirectory,\n              logger: sindri.logger,\n              rootDirectory,\n              tty: false,\n            },\n          );\n          ranInDocker = method === \"docker\";\n          if (method !== null) {\n            sindri.logger.debug(\"Parsing Circomspect SARIF results.\");\n            const sarifContent = readFileSync(sarifFile, {\n              encoding: \"utf-8\",\n            });\n            sarif = JSON.parse(sarifContent);\n          } else {\n            sindri.logger.warn(\n              \"Circomspect is not installed, skipping circomspect static analysis.\\n\" +\n                \"Please install Docker by following the directions at: \" +\n                \"https://docs.docker.com/get-docker/\\n\" +\n                \"Or install Circomspect by following the directions at: \" +\n                \"https://github.com/trailofbits/circomspect#installing-circomspect\",\n            );\n            warningCount += 1;\n          }\n        } catch (error) {\n          sindri.logger.fatal(\n            `Error running Circomspect in \"${rootDirectory}\".`,\n          );\n          sindri.logger.error(error);\n          errorCount += 1;\n        } finally {\n          try {\n            unlinkSync(sarifFile);\n          } catch {\n            // The file might not have been created successfully, so this is probably fine.\n            sindri.logger.debug(\n              `Failed to delete temporary SARIF file \"${sarifFile}\".`,\n            );\n          }\n        }\n\n        if (sarif) {\n          // Sort the results by file, line, and column; the order we want to display them in.\n          const results: SarifResult[] = sarif.runs[0]?.results ?? [];\n          results.sort((a: SarifResult, b: SarifResult) => {\n            if (\n              !a?.locations?.length ||\n              !b?.locations?.length ||\n              !a.locations[0]?.physicalLocation?.artifactLocation?.uri ||\n              !b.locations[0]?.physicalLocation?.artifactLocation?.uri ||\n              a.locations[0]?.physicalLocation?.region?.startLine == null ||\n              b.locations[0]?.physicalLocation?.region?.startLine == null ||\n              a.locations[0]?.physicalLocation?.region?.startColumn == null ||\n              b.locations[0]?.physicalLocation?.region?.startColumn == null\n            ) {\n              return 0;\n            }\n            const uriComparison =\n              a.locations[0].physicalLocation.artifactLocation.uri.localeCompare(\n                b.locations[0].physicalLocation.artifactLocation.uri,\n              );\n            if (uriComparison !== 0) return uriComparison;\n            const lineComparision =\n              a.locations[0].physicalLocation.region.startLine -\n              b.locations[0].physicalLocation.region.startLine;\n            if (lineComparision !== 0) return lineComparision;\n            const columnComparision =\n              a.locations[0].physicalLocation.region.startColumn -\n              b.locations[0].physicalLocation.region.startColumn;\n            return columnComparision;\n          });\n\n          // Log out the circomspect results.\n          let circomspectIssueFound = false;\n          results.forEach((result: SarifResult) => {\n            if (\n              !result?.locations?.length ||\n              !result.locations[0]?.physicalLocation?.artifactLocation?.uri ||\n              result.locations[0]?.physicalLocation?.region?.startLine ==\n                null ||\n              result.locations[0]?.physicalLocation?.region?.startColumn ==\n                null ||\n              !result?.message?.text\n            ) {\n              sindri.logger.warn(\n                \"Circomspect result is missing required fields, skipping.\",\n              );\n              sindri.logger.debug(result, \"Missing Circomspect result fields:\");\n              return;\n            }\n\n            const filePath = path.relative(\n              ranInDocker ? \"/sindri/\" : rootDirectory,\n              result.locations[0].physicalLocation.artifactLocation.uri.replace(\n                /^file:\\/\\//,\n                \"\",\n              ),\n            );\n            const { startColumn, startLine } =\n              result.locations[0].physicalLocation.region;\n            const logMessage =\n              `${filePath}:${startLine}:${startColumn} ` +\n              `${result.message.text} [Circomspect: ${result.ruleId}]`;\n            if (result.level === \"error\") {\n              sindri.logger.error(logMessage);\n              circomspectIssueFound = true;\n              errorCount += 1;\n            } else if (result.level === \"warning\") {\n              sindri.logger.warn(logMessage);\n              circomspectIssueFound = true;\n              warningCount += 1;\n            } else {\n              sindri.logger.debug(logMessage);\n            }\n          });\n          if (!circomspectIssueFound) {\n            sindri.logger.info(\"No issues found with Circomspect, good job!\");\n          }\n        }\n      } catch (error) {\n        sindri.logger.fatal(\"Error running Circomspect, aborting.\");\n        sindri.logger.debug(error);\n        return process.exit(1);\n      }\n    }\n\n    // Summarize the errors and warnings.\n    if (errorCount === 0 && warningCount === 0) {\n      sindri.logger.info(\"No issues found, good job!\");\n    } else {\n      sindri.logger.warn(\n        `Found ${errorCount + warningCount} problems ` +\n          `(${errorCount} errors, ${warningCount} warnings).`,\n      );\n      if (errorCount > 0) {\n        sindri.logger.error(`Linting failed with ${errorCount} errors.`);\n        return process.exit(1);\n      }\n    }\n  });\n","import os from \"os\";\nimport process from \"process\";\n\nimport { Command } from \"@commander-js/extra-typings\";\nimport {\n  confirm,\n  input,\n  password as passwordInput,\n  select,\n} from \"@inquirer/prompts\";\n\nimport sindri from \"lib\";\nimport { ApiError, type TeamMeResponse } from \"lib/api\";\nimport { Config } from \"lib/config\";\n\nexport const loginCommand = new Command()\n  .name(\"login\")\n  .description(\"Authorize the client.\")\n  .option(\n    \"-u, --base-url <URL>\",\n    \"The base URL for the Sindri API. Mainly useful for development.\",\n    \"https://sindri.app\",\n  )\n  .action(async ({ baseUrl }) => {\n    const config = new Config();\n    // Check if they're already authenticated, and prompt for confirmation if so.\n    const auth = config.auth;\n    if (!auth) {\n      let teamMeResponse: TeamMeResponse | undefined;\n      try {\n        teamMeResponse = await sindri._client.internal.teamMe();\n      } catch (error) {\n        if (error instanceof ApiError && error.status === 401) {\n          sindri.logger.warn(\n            \"Existing credentials found, but invalid. Please continue logging in to update them.\",\n          );\n        } else {\n          sindri.logger.fatal(\"An unknown error occurred.\");\n          sindri.logger.error(error);\n          return process.exit(1);\n        }\n      }\n\n      if (teamMeResponse) {\n        const proceed = await confirm({\n          message:\n            `You are already logged in as ${teamMeResponse.team.slug} on ${sindri.baseUrl}, ` +\n            \"are you sure you want to proceed?\",\n          default: false,\n        });\n        if (!proceed) {\n          sindri.logger.info(\"Aborting.\");\n          return;\n        }\n      }\n    }\n\n    // Collect details for generating an API key.\n    const username = await input({ message: \"Username:\" });\n    const password = await passwordInput({ mask: true, message: \"Password:\" });\n    const name = await input({\n      default: `${os.hostname()}-sdk`,\n      message: \"New API Key Name:\",\n    });\n\n    // Generate an API key for one of their teams.\n    try {\n      // Generate a JWT token to authenticate the user.\n      sindri._clientConfig.BASE = baseUrl;\n      const tokenResult =\n        await sindri._client.token.fd3Aaa7BControllerObtainToken({\n          username,\n          password,\n        });\n      sindri._clientConfig.TOKEN = tokenResult.access;\n\n      // Fetch their teams and have the user select one.\n      const userResult = await sindri._client.internal.userMeWithJwtAuth();\n      const teamId = await select({\n        message: \"Select a Organization:\",\n        choices: userResult.teams.map(({ id, slug }) => ({\n          name: slug,\n          value: id,\n        })),\n      });\n      const team = userResult.teams.find((team) => team.id === teamId);\n      if (!team) {\n        throw new Error(\"No organization selected.\");\n      }\n\n      // Generate an API key.\n      sindri._clientConfig.HEADERS = {\n        ...sindri._clientConfig.HEADERS,\n        \"Sindri-Team-Id\": `${teamId}`,\n      };\n      const apiKeyResult = await sindri._client.authorization.apikeyGenerate({\n        username,\n        password,\n        name,\n      });\n      const apiKey = apiKeyResult.api_key;\n      const apiKeyId = apiKeyResult.id;\n      const apiKeyName = apiKeyResult.name;\n      if (!apiKey || !apiKeyId || !apiKeyName) {\n        throw new Error(\"Error generating API key.\");\n      }\n\n      // Store the new auth information.\n      config.update({\n        auth: {\n          apiKey,\n          apiKeyId,\n          apiKeyName,\n          baseUrl,\n          teamId,\n          teamSlug: team.slug,\n        },\n      });\n      sindri.logger.info(\n        \"You have successfully authorized the client with your Sindri account.\",\n      );\n    } catch (error) {\n      sindri.logger.fatal(\"An irrecoverable error occurred.\");\n      sindri.logger.error(error);\n      process.exit(1);\n    }\n  });\n","import { Command } from \"@commander-js/extra-typings\";\nimport { confirm } from \"@inquirer/prompts\";\n\nimport sindri from \"lib\";\nimport { Config } from \"lib/config\";\n\nexport const logoutCommand = new Command()\n  .name(\"logout\")\n  .description(\"Remove the current client authorization credentials.\")\n  .action(async () => {\n    // Check whether we're currently authenticated.\n    const config = new Config();\n    const auth = config.auth;\n    if (!auth) {\n      sindri.logger.error(\"You must log in first with `sindri login`.\");\n      return;\n    }\n\n    // Optionally revoke the current key.\n    const revokeKey = await confirm({\n      message: `Would you like to also revoke the \"${auth.apiKeyName}\" API key? (recommended)`,\n      default: true,\n    });\n    if (revokeKey) {\n      try {\n        await sindri._client.authorization.apikeyDelete(auth.apiKeyId);\n        sindri.logger.info(`Successfully revoked \"${auth.apiKeyName}\" key.`);\n      } catch (error) {\n        sindri.logger.warn(\n          `Error revoking \"${auth.apiKeyName}\" key, proceeding to clear credentials anyway.`,\n        );\n        sindri.logger.error(error);\n      }\n    } else {\n      sindri.logger.warn(\"Skipping revocation of existing key.\");\n    }\n\n    // Clear the existing credentials.\n    config.update({ auth: null });\n    sindri.logger.info(\"You have successfully logged out.\");\n  });\n","import fs from \"fs\";\nimport path from \"path\";\nimport process from \"process\";\n\nimport { Command } from \"@commander-js/extra-typings\";\n\nimport { findFileUpwards } from \"cli/utils\";\nimport sindri from \"lib\";\nimport { ApiError } from \"lib/api\";\nimport { print } from \"lib/logging\";\n\nconst readStdin = async (): Promise<string> => {\n  let inputData = \"\";\n  return new Promise((resolve) => {\n    process.stdin.on(\"data\", (chunk) => (inputData += chunk));\n    process.stdin.on(\"end\", () => resolve(inputData));\n  });\n};\n\nconst proofCreateCommand = new Command()\n  .name(\"create\")\n  .description(\"Create a proof for the circuit.\")\n  .option(\n    \"-i, --input <input>\",\n    \"Input file for the proof (defaults to stdin if non-TTY; \" +\n      \"`input.json`, `example-input.json`, or `Prover.toml` otherwise).\",\n  )\n  .option(\"-t, --tag <tag>\", \"Tag to generate the proof from.\", \"latest\")\n  .option(\n    \"-v, --verify\",\n    \"Perform verification of the proof after creating it.\",\n  )\n  .action(async ({ input, tag, verify }) => {\n    // Check that the API client is authorized.\n    if (!sindri.apiKey || !sindri.baseUrl) {\n      sindri.logger.warn(\"You must login first with `sindri login`.\");\n      return process.exit(1);\n    }\n\n    // Find `sindri.json` and move into the root of the project directory.\n    const currentDirectoryPath = path.resolve(\".\");\n    if (!fs.existsSync(currentDirectoryPath)) {\n      sindri.logger.error(\n        `The \"${currentDirectoryPath}\" directory does not exist. Aborting.`,\n      );\n      return process.exit(1);\n    }\n    const sindriJsonPath = findFileUpwards(\n      /^sindri.json$/i,\n      currentDirectoryPath,\n    );\n    if (!sindriJsonPath) {\n      sindri.logger.error(\n        `No \"sindri.json\" file was found in or above \"${currentDirectoryPath}\". Aborting.`,\n      );\n      return process.exit(1);\n    }\n    sindri.logger.debug(`Found \"sindri.json\" at \"${sindriJsonPath}\".`);\n    const rootDirectory = path.dirname(sindriJsonPath);\n    sindri.logger.debug(`Changing current directory to \"${rootDirectory}\".`);\n    process.chdir(rootDirectory);\n\n    // Load `sindri.json` and find the circuit name.\n    let sindriJson: object = {};\n    try {\n      const sindriJsonContent = fs.readFileSync(sindriJsonPath, {\n        encoding: \"utf-8\",\n      });\n      sindriJson = JSON.parse(sindriJsonContent);\n      sindri.logger.debug(\n        `Successfully loaded \"sindri.json\" from \"${sindriJsonPath}\":`,\n      );\n      sindri.logger.debug(sindriJson);\n    } catch (error) {\n      sindri.logger.fatal(\n        `Error loading \"${sindriJsonPath}\", perhaps it is not valid JSON?`,\n      );\n      sindri.logger.error(error);\n      return process.exit(1);\n    }\n    if (!(\"name\" in sindriJson)) {\n      sindri.logger.error('No \"name\" field found in \"sindri.json\". Aborting.');\n      return process.exit(1);\n    }\n    const circuitName = sindriJson.name;\n\n    // Reed in the proof input.\n    let proofInput: string | undefined;\n    if (input && fs.existsSync(input)) {\n      // Read from the specified input file.\n      proofInput = fs.readFileSync(input, \"utf-8\");\n    } else if (!process.stdin.isTTY || input === \"-\") {\n      // Read from stdin in a non-TTY context.\n      proofInput = await readStdin();\n    }\n    if (!proofInput || !proofInput.trim()) {\n      // Try to load from common input filenames.\n      const defaultInputFiles = [\n        \"input.json\",\n        \"example-input.json\",\n        \"Prover.toml\",\n      ];\n      for (const file of defaultInputFiles) {\n        const qualifiedFile = path.join(rootDirectory, file);\n        if (fs.existsSync(file)) {\n          proofInput = fs.readFileSync(qualifiedFile, \"utf-8\");\n          break;\n        }\n      }\n\n      if (!proofInput) {\n        console.error(\n          \"No input file specified, none of the default files found, and not in a non-TTY context.\",\n        );\n        process.exit(1);\n      }\n    }\n\n    // Only Circom supports smart contract calldata right now, so we only enable it for that circuit\n    // type. We'll need to update this as we add support for more circuit types.\n    const includeSmartContractCalldata =\n      \"circuitType\" in sindriJson &&\n      typeof sindriJson.circuitType === \"string\" &&\n      [\"circom\"].includes(sindriJson.circuitType);\n\n    const circuitIdentifier = `${circuitName}:${tag}`;\n    try {\n      // Poll for proof generation to complete.\n      const startTime = Date.now();\n      const response = await sindri.proveCircuit(\n        circuitIdentifier,\n        proofInput,\n        !!verify,\n        includeSmartContractCalldata,\n      );\n      const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);\n\n      // Check that the status is \"Ready\" or log an error.\n      if (response.status === \"Ready\") {\n        sindri.logger.info(\n          `Proof generated successfully after ${elapsedSeconds} seconds.`,\n        );\n      } else if (response.status === \"Failed\") {\n        sindri.logger.error(\n          `Proof generation failed after ${elapsedSeconds} seconds: ` +\n            (response.error ?? \"Unknown error.\"),\n        );\n        return process.exit(1);\n      } else {\n        sindri.logger.fatal(`Unexpected response status: ${response.status}`);\n        return process.exit(1);\n      }\n\n      // Print out the formatted proof response.\n      print(\n        JSON.stringify(\n          {\n            proofId: response.proof_id,\n            proof: response.proof,\n            public: response.public,\n            // TODO: We need to figure out if this is the format we want to expose.\n            // smart_contract_calldata: response.smart_contract_calldata,\n            verification_key: response.verification_key,\n          },\n          null,\n          2,\n        ),\n      );\n    } catch (error) {\n      // TODO: Better error handling.\n      if (error instanceof ApiError && error.status === 404) {\n        sindri.logger.error(\n          `No circuit found with the name \"${circuitName}\" and tag \"${tag}\".`,\n        );\n      } else {\n        sindri.logger.fatal(\"An unknown error occurred.\");\n        sindri.logger.error(error);\n      }\n      return process.exit(1);\n    }\n  });\n\nexport const proofCommand = new Command()\n  .name(\"proof\")\n  .description(\"Commands related to proofs for the current circuit.\")\n  .addCommand(proofCreateCommand);\n","import process from \"process\";\n\nimport { Command } from \"@commander-js/extra-typings\";\n\nimport sindri from \"lib\";\nimport { ApiError } from \"lib/api\";\nimport { print } from \"lib/logging\";\n\nexport const whoamiCommand = new Command()\n  .name(\"whoami\")\n  .description(\"Display the currently authorized organization name.\")\n  .action(async () => {\n    // Check that the API client is authorized.\n    if (!sindri.apiKey || !sindri.baseUrl) {\n      sindri.logger.warn(\"You must login first with `sindri login`.\");\n      return process.exit(1);\n    }\n\n    try {\n      const response = await sindri._client.internal.teamMe();\n      print(response.team.slug);\n    } catch (error) {\n      if (error instanceof ApiError && error.status === 401) {\n        sindri.logger.error(\n          \"Your credentials are invalid. Please log in again with `sindri login`.\",\n        );\n      } else {\n        sindri.logger.fatal(\"An unknown error occurred.\");\n        sindri.logger.error(error);\n        return process.exit(1);\n      }\n    }\n  });\n"],"mappings":"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","names":["cli_exports","__export","program","__toCommonJS","getImportMetaUrl","importMetaUrl","import_process","import_extra_typings","import_assert","import_fs","import_path","import_process","import_extra_typings","import_tar","import_promises","import_path","import_gzip_js","import_ignore_walk","import_tar","import_tar_js","BaseHttpRequest","config","import_axios","import_buffer","import_formdata_node","File","NodeFile","FormData","NodeFormData","ApiError","request","response","message","CancelError","message","CancelablePromise","#isResolved","#isRejected","#isCancelled","#cancelHandlers","#promise","#resolve","#reject","executor","resolve","reject","onResolve","value","onReject","reason","onCancel","cancelHandler","onFulfilled","onRejected","onFinally","error","isDefined","value","isString","isStringWithValue","isBlob","isFormData","FormData","isSuccess","status","base64","str","getQueryString","params","qs","append","key","process","v","k","getUrl","config","options","encoder","path","substring","group","url","getFormData","formData","_","resolve","resolver","getHeaders","token","username","password","additionalHeaders","formHeaders","headers","credentials","getRequestBody","sendRequest","body","onCancel","axiosClient","source","axios","requestConfig","error","axiosError","getResponseHeader","response","responseHeader","content","getResponseBody","catchErrorCodes","result","ApiError","errorStatus","errorStatusText","errorBody","request","CancelablePromise","reject","startTime","getElapsedTime","ellapsedMilliseconds","ellapsedSeconds","ellapsedMinutes","logPrefix","responseBody","responseMessage","errorMessage","AxiosHttpRequest","BaseHttpRequest","config","options","request","AuthorizationService","httpRequest","requestBody","name","apikeyId","CircuitsService","httpRequest","formData","circuitId","includeVerificationKey","InternalService","httpRequest","circuitId","formData","ProofsService","httpRequest","proofId","includeProof","includePublic","includeSmartContractCalldata","includeVerificationKey","TokenService","httpRequest","requestBody","ApiClient","config","HttpRequest","AxiosHttpRequest","AuthorizationService","CircuitsService","InternalService","ProofsService","TokenService","import_fs","import_path","import_env_paths","import_lodash","import_zod","getConfigPath","paths","envPaths","path","ConfigSchema","defaultConfig","loadConfig","logger","configPath","fs","configFileContents","loadedConfig","error","_","Config","configData","newConfig","directory","import_pino","import_pino_pretty","createLogger","level","logger","pino","pretty","print","SindriClient","_SindriClient","authOptions","ApiClient","versionTag","createLogger","Config","level","project","tags","formData","FormData","tag","projectStats","tarballFilename","path","tarballContent","File","sindriJsonPath","sindriJsonContent","sindriJson","circuitName","files","walk","file","sindriJsonFilename","a","b","tarStream","tar","code","message","sindriJsonFile","tarball","Tar","content","resolve","gzippedTarball","gzip","tarFile","oldHeaders","createResponse","circuitId","response","proofId","proofInput","verify","includeSmartContractCalldata","lib_default","SindriClient","cloneCommand","circuit","directory","match","lib_default","process","assert","circuitName","outputDirectory","path","fs","responseStream","error","ApiError","resolve","reject","tar","code","message","import_extra_typings","configListCommand","lib_default","print","configCommand","import_assert","import_path","import_process","import_extra_typings","import_assert","import_child_process","import_fs","import_promises","import_os","import_path","import_process","import_stream","import_url","import_axios","import_compare_versions","import_dockerode","import_nunjucks","currentFilePath","importMetaUrl","currentDirectoryPath","path","checkCommandExists","command","resolve","process","code","checkDockerAvailability","logger","docker","Docker","error","devNull","_chunk","_encoding","callback","execCommand","args","cwd","rootDirectory","tag","tty","isTruthy","execLocalCommand","execDockerCommand","sindriJsonPath","findFileUpwards","image","sindriJsonContent","sindriJson","reject","stream","result","mountDirectory","relativeCwd","internalCwd","data","container","child","signal","os","assert","fileExists","filePath","fs","filename","initialDirectory","files","file","parentDirectory","getDockerImageTags","repository","username","url","results","response","axios","tag_status","name","a","b","str","loadSindriManifestJsonSchema","sindriManifestJsonPath","findFileUpwards","sindriManifestJsonContent","scaffoldDirectory","templateDirectory","outputDirectory","context","logger","fullOutputDirectory","path","fileExists","rootTemplateDirectory","findFileUpwards","fullTemplateDirectory","render","content","newContent","key","value","nunjucks","processPath","inputPath","outputPath","files","file","populatedFile","template","renderedTemplate","listTags","rootDirectory","tag","circomspectCommand","args","code","execDockerCommand","lib_default","process","error","nargoCommand","execCommand","command","opts","repository","assert","getDockerImageTags","print","cwd","sindriJsonPath","findFileUpwards","path","checkDockerAvailability","import_child_process","import_fs","import_path","import_process","import_extra_typings","import_prompts","initCommand","directory","directoryPath","path","directoryName","lib_default","process","circuitName","input","circuitType","context","provingScheme","curveName","witnessCompiler","packageName","gnarkCurveName","halo2Version","threadBuilder","degree","className","noirVersion","scaffoldDirectory","gitKeepFile","npmInstalled","gitInstalled","gitAlreadyInitialized","error","execError","key","import_buffer","import_fs","import_path","import_process","import_extra_typings","import_formdata_node","import_ignore_walk","import_tar","deployCommand","directory","tags","untagged","lib_default","process","tag","directoryPath","path","sindriJsonPath","findFileUpwards","rootDirectory","sindriJson","sindriJsonContent","error","circuitName","files","walk","file","sindriJsonFilename","formData","tarballFilename","tar","code","message","circuitId","ApiError","startTime","response","elapsedSeconds","resolve","import_assert","import_crypto","import_fs","import_path","import_process","import_extra_typings","import_jsonschema","lintCommand","directory","errorCount","warningCount","sindriManifestJsonSchema","loadSindriManifestJsonSchema","lib_default","process","directoryPath","path","sindriJsonPath","findFileUpwards","rootDirectory","sindriJson","sindriJsonContent","error","assert","subSchema","option","circuitType","validationStatus","JsonValidator","prefix","readmePath","sarifFile","sarif","ranInDocker","circuitPath","method","execCommand","sarifContent","results","a","b","uriComparison","lineComparision","circomspectIssueFound","result","filePath","startColumn","startLine","logMessage","import_os","import_process","import_extra_typings","import_prompts","loginCommand","baseUrl","config","Config","teamMeResponse","lib_default","error","ApiError","process","username","password","passwordInput","name","os","tokenResult","userResult","teamId","id","slug","team","apiKeyResult","apiKey","apiKeyId","apiKeyName","import_extra_typings","import_prompts","logoutCommand","config","Config","auth","lib_default","error","import_fs","import_path","import_process","import_extra_typings","readStdin","inputData","resolve","process","chunk","proofCreateCommand","input","tag","verify","lib_default","currentDirectoryPath","path","fs","sindriJsonPath","findFileUpwards","rootDirectory","sindriJson","sindriJsonContent","error","circuitName","proofInput","defaultInputFiles","file","qualifiedFile","includeSmartContractCalldata","circuitIdentifier","startTime","response","elapsedSeconds","print","ApiError","proofCommand","import_process","import_extra_typings","whoamiCommand","lib_default","process","response","print","error","ApiError","version","versionTag","program","cloneCommand","configCommand","execCommand","initCommand","deployCommand","lintCommand","loginCommand","logoutCommand","proofCommand","whoamiCommand","command","debug","quiet","lib_default"]}